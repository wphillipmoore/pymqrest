{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pymqrest","text":""},{"location":"#overview","title":"Overview","text":"<p>pymqrest provides a Python-friendly interface to IBM MQ queue manager administration via the <code>runCommandJSON</code> REST endpoint. It translates between Python <code>snake_case</code> attribute names and native MQSC parameter names, wraps every MQSC command as a typed method, and handles authentication, CSRF tokens, and error propagation.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>~144 command methods covering all MQSC verbs and qualifiers</li> <li>Bidirectional attribute mapping between developer-friendly names and MQSC parameters</li> <li>Idempotent ensure methods for declarative object management</li> <li>Bulk sync operations for configuration-as-code workflows</li> <li>Zero runtime dependencies \u2014 stdlib only</li> <li>Transport abstraction for easy testing with mock transports</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pymqrest\n</code></pre> <p>Or with uv:</p> <pre><code>uv add pymqrest\n</code></pre>"},{"location":"#status","title":"Status","text":"<p>This project is in beta. The API surface, mapping tables, and return shapes are stable but may evolve.</p>"},{"location":"#license","title":"License","text":"<p>GNU General Public License v3.0</p>"},{"location":"ai-engineering/","title":"AI-assisted engineering","text":""},{"location":"ai-engineering/#transparency-statement","title":"Transparency statement","text":"<p>The mq-rest-admin project is an AI-assisted engineering effort. Significant portions of each language implementation were developed collaboratively between a human engineer and AI coding agents. This page documents what was AI-generated, what was human-designed, and how quality was maintained.</p>"},{"location":"ai-engineering/#tools-used","title":"Tools used","text":"<ul> <li>Claude Code (Anthropic) \u2014 interactive pair-programming agent</li> <li>Codex (OpenAI) \u2014 autonomous task execution agent</li> </ul>"},{"location":"ai-engineering/#what-was-ai-generated","title":"What was AI-generated","text":"<p>Mapping data bootstrap: The canonical <code>mapping-data.json</code> was originally bootstrapped from IBM MQ 9.4 documentation using an AI-assisted extraction pipeline. The pipeline parsed MQSC and PCF command references to propose <code>snake_case</code> attribute names, value mappings, and command metadata for all 48 qualifiers. The automated output was then reviewed, customized, and rationalized by hand. <code>mapping-data.json</code> is now maintained directly as the sole authoritative source \u2014 the extraction pipeline is archived in the Python repository at <code>docs/archive/extraction/</code>.</p> <p>Command method generation: The ~144 MQSC command wrapper methods in each language implementation are generated from the command definitions in <code>mapping-data.json</code>. Each method is a thin wrapper with the correct verb, qualifier, and return type.</p> <p>Mapping documentation: The 48 qualifier mapping pages in the documentation were generated from the same mapping data source.</p> <p>Implementation code: Much of the session, mapping, transport, and test code was written through AI-assisted pair programming, with the AI agent proposing implementations and the human engineer reviewing, refining, and directing the design.</p>"},{"location":"ai-engineering/#what-was-human-designed","title":"What was human-designed","text":"<p>Architecture and API design: The overall design \u2014 single-endpoint via <code>runCommandJSON</code>, qualifier-based mapping, method naming conventions, return shape rules, error handling strategy \u2014 was conceived and directed by the human engineer.</p> <p>Quality standards: The requirement for comprehensive test coverage and the validation gate pipeline were human-defined standards. Each language implementation enforces its own quality tooling as a CI hard gate.</p> <p>Design decisions: Key choices like the mapping opt-out mechanism, strict vs lenient modes, the transport abstraction, and error handling patterns were human decisions refined through discussion.</p>"},{"location":"ai-engineering/#quality-assurance","title":"Quality assurance","text":"<p>AI-generated code is held to the same standards as human-written code. Every guardrail listed below is enforced as a CI hard gate \u2014 pull requests that violate any check cannot merge.</p>"},{"location":"ai-engineering/#test-coverage","title":"Test coverage","text":"<p>All production code is covered by unit tests with 100% line and branch coverage enforced at the CI level. Coverage is measured per-build and any drop below 100% fails the pipeline. Each language uses its ecosystem's standard coverage tool (JaCoCo, pytest-cov, go tool cover).</p>"},{"location":"ai-engineering/#static-analysis-and-linting","title":"Static analysis and linting","text":"<p>Each implementation runs language-appropriate linters and static analysis tools as CI hard gates:</p> <ul> <li>Formatting: Automatic formatting enforcement ensures consistent   style regardless of author (human or AI). Formatting is checked, not   just applied, so unformatted code fails CI.</li> <li>Lint rules: Comprehensive lint rulesets catch code smells, unused   imports, naming violations, and anti-patterns.</li> <li>Bug analysis: Static analysis tools detect potential bugs, null   pointer risks, concurrency issues, and security vulnerabilities.</li> <li>Type checking: Where applicable, strict type checking ensures type   safety across the entire source tree.</li> </ul>"},{"location":"ai-engineering/#security-scanning","title":"Security scanning","text":"<ul> <li>CodeQL: GitHub's semantic code analysis runs on every pull request,   detecting injection flaws, insecure data handling, and other   vulnerability classes via deep data flow and taint tracking.</li> <li>Semgrep: Pattern-based SAST provides custom security rule coverage   across all languages, complementing CodeQL with broader language   support and project-specific rule authoring.</li> <li>Trivy: Filesystem vulnerability scanning detects known CVEs in   dependencies, lock files, and configuration files across all   language ecosystems.</li> <li>Dependency auditing: Every build audits runtime dependencies for   known CVEs using language-native tools (pip-audit, govulncheck,   Maven dependency verification). Vulnerable dependencies fail the   pipeline.</li> <li>License compliance: Dependency licenses are checked against an   allow-list of approved open-source licenses. Unapproved licenses   fail the build.</li> </ul>"},{"location":"ai-engineering/#validation-pipeline","title":"Validation pipeline","text":"<p>Each repository provides a single command that runs the same checks as CI \u2014 formatting, linting, type checking, tests, coverage enforcement, and static analysis. This ensures developers (human and AI) can verify changes locally before pushing.</p>"},{"location":"ai-engineering/#integration-testing","title":"Integration testing","text":"<p>Containerized IBM MQ queue managers provide real MQSC command validation. Integration tests verify that mapping assumptions hold against actual MQ responses, catching mismatches between the mapping data and real queue manager behavior.</p>"},{"location":"ai-engineering/#git-hooks","title":"Git hooks","text":"<p>Local git hooks enforce standards before code reaches CI:</p> <ul> <li>Conventional Commits: The <code>commit-msg</code> hook validates that every   commit message follows the <code>type(scope): description</code> format.</li> <li>Co-author validation: The <code>commit-msg</code> hook checks that   <code>Co-Authored-By</code> trailers match the repository's approved identity   list \u2014 unapproved AI identities are rejected.</li> <li>Branch protection: The <code>pre-commit</code> hook blocks commits to   protected branches (<code>main</code>, <code>develop</code>, <code>release/*</code>) and enforces   the repository's branching model naming convention.</li> </ul>"},{"location":"ai-engineering/#ci-gate-structure","title":"CI gate structure","text":"<p>Pull requests must pass all of the following independent CI jobs before merging:</p> <ol> <li>standards-compliance \u2014 Conventional Commit format, co-author    validation, PR issue linkage, markdown standards, repository profile</li> <li>dependency-audit \u2014 Vulnerability scanning and license compliance</li> <li>release-gates \u2014 Version format and divergence checks for    release-targeting PRs</li> <li>test-and-validate \u2014 Full validation pipeline across multiple    language/runtime versions</li> <li>codeql \u2014 GitHub semantic security analysis</li> <li>trivy \u2014 Filesystem vulnerability scanning across all ecosystems</li> <li>semgrep \u2014 Pattern-based SAST with language-specific rulesets</li> <li>integration-tests \u2014 End-to-end tests against containerized MQ</li> </ol> <p>A docs-only detection job allows documentation changes to skip test-and-validate, CodeQL, Trivy, Semgrep, and integration tests while still requiring standards compliance and dependency audit.</p>"},{"location":"ai-engineering/#the-co-authored-by-convention","title":"The <code>Co-Authored-By</code> convention","text":"<p>Commits that involved AI assistance include a <code>Co-Authored-By</code> trailer identifying the agent used:</p> <pre><code>Co-Authored-By: wphillipmoore-claude &lt;255925739+wphillipmoore-claude@users.noreply.github.com&gt;\nCo-Authored-By: wphillipmoore-codex &lt;255923655+wphillipmoore-codex@users.noreply.github.com&gt;\n</code></pre> <p>This provides a transparent, auditable record of AI involvement in the project's git history.</p>"},{"location":"ai-engineering/#python-specific-quality-standards","title":"Python-specific quality standards","text":"<p>100% test coverage: Every line and branch of production code is covered by unit tests. Coverage is enforced as a CI hard gate.</p> <p>Strict typing: Both mypy and ty type checkers run in strict mode against the entire source tree.</p> <p>Comprehensive linting: Ruff runs with all rule categories enabled. The few per-file exceptions (like missing docstrings in generated code) are explicitly configured.</p> <p>Validation pipeline: <code>scripts/dev/validate_local.py</code> runs the same checks as CI, including dependency auditing, lock file verification, and commit message validation.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#component-overview","title":"Component overview","text":"<p>The library is organized around four core components:</p> Session The main entry point. Owns authentication, base URL construction,   request/response handling, and diagnostic state. Provides generated   command methods for all MQSC commands. A single session represents a   connection to one queue manager's REST API. Command methods ~144 generated MQSC command methods. Each method is a thin wrapper that   calls the internal command dispatcher with the correct command verb and   qualifier. Method names follow the pattern <code>verb_qualifier</code> (or   <code>verbQualifier</code> in camelCase languages), mapping directly to MQSC   commands. For example, <code>DISPLAY QUEUE</code> becomes <code>display_queue</code> /   <code>displayQueue</code>, and <code>DEFINE QLOCAL</code> becomes <code>define_qlocal</code> /   <code>defineQlocal</code>. Ensure methods 16 idempotent ensure methods for declarative object management. Each   method checks current state with DISPLAY, then DEFINE, ALTER, or no-ops   as needed. Returns an ensure result indicating what action was taken.   The queue manager variant is a special singleton (no name, no DEFINE).   Only changed attributes are sent in ALTER commands, preserving   <code>ALTDATE</code>/<code>ALTTIME</code> audit timestamps. Mapping pipeline Bidirectional attribute translation between developer-friendly names and   native MQSC parameter names. Includes key mapping (attribute names),   value mapping (enumerated values), and key-value mapping (combined   name+value translations). The mapping tables were bootstrapped from   IBM MQ 9.4 documentation and cover all standard MQSC attributes. Exception hierarchy Structured error types for transport failures, malformed responses,   authentication errors, MQSC command errors, and polling timeouts.   All exceptions carry diagnostic context including the full MQ response   payload when available. <p>In the Python implementation, the core components map to these modules:</p> <ul> <li><code>MQRESTSession</code> (<code>session.py</code>): The main entry point. Owns   authentication, base URL construction, request/response handling, and   diagnostic state. Inherits generated command methods from   <code>MQRESTCommandMixin</code>.</li> <li><code>MQRESTCommandMixin</code> (<code>commands.py</code>): Provides ~144 generated MQSC   command methods. Each method is a thin wrapper that calls <code>_mqsc_command</code>   with the correct command verb and qualifier.</li> <li><code>MQRESTEnsureMixin</code> (<code>ensure.py</code>): Provides 16 idempotent <code>ensure_*</code>   methods for declarative object management. <code>ensure_qmgr()</code> is a special   singleton variant (no name, no DEFINE).</li> <li>Mapping pipeline (<code>mapping.py</code>, <code>mapping_data.py</code>): Bidirectional   attribute translation between Python <code>snake_case</code> names and native MQSC   parameter names. See the mapping pipeline for   details.</li> <li>Exception hierarchy (<code>exceptions.py</code>): Structured error types rooted   at <code>MQRESTError</code>. All exceptions carry diagnostic context.</li> </ul>"},{"location":"architecture/#request-lifecycle","title":"Request lifecycle","text":"<p>Every MQSC command follows the same path through the system:</p> <pre><code>Method call (e.g. displayQueue / display_queue)\n  \u2192 command dispatcher\n    \u2192 Map request attributes (friendly names \u2192 MQSC)\n    \u2192 Map response parameter names\n    \u2192 Map WHERE keyword\n    \u2192 Build runCommandJSON payload\n    \u2192 Transport POST\n    \u2192 Parse JSON response\n    \u2192 Extract commandResponse items\n    \u2192 Flatten nested objects\n    \u2192 Map response attributes (MQSC \u2192 friendly names)\n  \u2192 Return result\n</code></pre>"},{"location":"architecture/#build-phase","title":"Build phase","text":"<ol> <li>The command method calls the internal dispatcher with the MQSC verb (e.g.    <code>DISPLAY</code>), qualifier (e.g. <code>QUEUE</code>), and user-supplied parameters.</li> <li>If mapping is enabled, request attributes are translated from friendly names    to MQSC parameter names via the qualifier's request key map and request    value map.</li> <li>Response parameter names are mapped similarly.</li> <li>A <code>WHERE</code> clause keyword, if provided, is mapped through the same qualifier    key maps.</li> <li>The <code>runCommandJSON</code> payload is assembled and sent via the transport.</li> </ol>"},{"location":"architecture/#parse-phase","title":"Parse phase","text":"<ol> <li>The JSON response is parsed and validated.</li> <li>Error codes (<code>overallCompletionCode</code>, <code>overallReasonCode</code>, per-item    <code>completionCode</code>/<code>reasonCode</code>) are checked. Errors raise a command    exception.</li> <li>The <code>parameters</code> dict is extracted from each <code>commandResponse</code> item.</li> <li>Nested <code>objects</code> lists (e.g. from <code>DISPLAY CONN TYPE(HANDLE)</code>) are    flattened into the parent parameter set.</li> <li>If mapping is enabled, response attributes are translated from MQSC to    friendly names.</li> </ol> <p>In Python, the command dispatcher is the internal <code>_mqsc_command()</code> method on <code>MQRESTSession</code>. Every public command method (e.g. <code>display_queue()</code>, <code>define_qlocal()</code>) delegates to it with the appropriate verb and qualifier.</p> <p>The session retains diagnostic state from the most recent command for inspection:</p> <pre><code>session.display_queue(\"MY.QUEUE\")\n\nsession.last_command_payload    # the JSON sent to MQ\nsession.last_response_payload   # the parsed JSON response\nsession.last_http_status        # HTTP status code\nsession.last_response_text      # raw response body\n</code></pre>"},{"location":"architecture/#transport-abstraction","title":"Transport abstraction","text":"<p>The session object does not make HTTP calls directly. Instead, it delegates to a transport interface that defines a single method for posting JSON payloads:</p> <ul> <li>URL: The fully-qualified endpoint URL.</li> <li>Payload: The <code>runCommandJSON</code> request body.</li> <li>Headers: Authentication, CSRF token, and optional gateway headers.</li> <li>Timeout: Per-request timeout duration.</li> <li>TLS verification: Whether to verify server certificates.</li> </ul> <p>The transport returns a response object containing the HTTP status code, response body, and response headers.</p> <p>The default implementation wraps the language's standard HTTP client. Tests inject a mock transport to avoid network calls, making the entire command pipeline testable without an MQ server.</p> <p>In Python, the transport is defined by the <code>MQRESTTransport</code> protocol:</p> <pre><code>class MQRESTTransport(Protocol):\n    def post_json(\n        self,\n        url: str,\n        payload: Mapping[str, object],\n        *,\n        headers: Mapping[str, str],\n        timeout_seconds: float | None,\n        verify_tls: bool,\n    ) -&gt; TransportResponse: ...\n</code></pre> <p>The default implementation, <code>RequestsTransport</code>, wraps the <code>requests</code> library.</p> <p>For testing, inject a mock transport:</p> <pre><code>from unittest.mock import MagicMock\n\nmock_transport = MagicMock(spec=MQRESTTransport)\nmock_transport.post_json.return_value = TransportResponse(\n    status_code=200,\n    text='{\"commandResponse\": []}',\n    headers={},\n)\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"admin\", \"passw0rd\"),\n    transport=mock_transport,\n)\n</code></pre> <p>This makes the entire command pipeline testable without an MQ server.</p>"},{"location":"architecture/#single-endpoint-design","title":"Single-endpoint design","text":"<p>All MQSC operations go through a single REST endpoint:</p> <pre><code>POST /ibmmq/rest/v2/admin/action/qmgr/{qmgr}/mqsc\n</code></pre> <p>The <code>runCommandJSON</code> payload specifies the MQSC verb, qualifier, object name, parameters, and response parameters. This design means the library needs exactly one HTTP method and one URL pattern to cover all MQSC commands.</p> <p>In Python, this means every command method on <code>MQRESTSession</code> ultimately calls the same <code>post_json()</code> method on the transport with the same URL pattern. The only variation is the JSON payload content.</p>"},{"location":"architecture/#gateway-routing","title":"Gateway routing","text":"<p>The MQ REST API is available on all supported IBM MQ platforms (Linux, AIX, Windows, z/OS, and IBM i). The library is developed and tested against the Linux implementation.</p> <p>In enterprise environments, a gateway queue manager can route MQSC commands to remote queue managers via MQ channels \u2014 the same mechanism used by <code>runmqsc -w</code> and the MQ Console.</p> <p>When a gateway queue manager is configured on the session:</p> <ul> <li>The URL path targets the remote queue manager:   <code>POST /admin/action/qmgr/{TARGET_QM}/mqsc</code></li> <li>The <code>ibm-mq-rest-gateway-qmgr</code> HTTP header names the local queue manager   that routes the command.</li> </ul> <p>When no gateway is configured (the default), no gateway header is sent and the REST API talks directly to the queue manager in the URL. This makes the feature purely additive \u2014 existing sessions are unaffected.</p> <pre><code>Client                     Gateway QM (QM1)              Target QM (QM2)\n  \u2502                              \u2502                              \u2502\n  \u2502  POST /qmgr/QM2/mqsc        \u2502                              \u2502\n  \u2502  Header: gateway-qmgr=QM1   \u2502                              \u2502\n  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502   MQSC via MQ channel        \u2502\n  \u2502                              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                              \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                              \u2502\n</code></pre>"},{"location":"architecture/#prerequisites","title":"Prerequisites","text":"<ul> <li>The gateway queue manager must have a running REST API.</li> <li>MQ channels must be configured between the gateway and target queue managers.</li> <li>A QM alias (QREMOTE with empty RNAME) must map the target QM name to the   correct transmission queue on the gateway.</li> </ul> <p>In Python, configure gateway routing via the <code>gateway_qmgr</code> parameter:</p> <pre><code>session = MQRESTSession(\n    rest_base_url=\"https://qm1-host:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM2\",           # target (remote) queue manager\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    gateway_qmgr=\"QM1\",        # local gateway queue manager\n)\n</code></pre>"},{"location":"architecture/#zero-runtime-dependencies","title":"Zero runtime dependencies","text":"<p>The library uses only the Python standard library plus <code>requests</code> for HTTP. No other runtime dependencies are required.</p>"},{"location":"architecture/#generated-command-methods","title":"Generated command methods","text":"<p>The 144 command methods in <code>MQRESTCommandMixin</code> are generated from <code>MAPPING_DATA[\"commands\"]</code> by <code>scripts/dev/generate_commands.py</code>. Each method:</p> <ul> <li>Accepts <code>name</code>, <code>request_parameters</code>, <code>response_parameters</code>, and   <code>where</code> (for DISPLAY commands).</li> <li>Calls <code>self._mqsc_command()</code> with the correct verb and qualifier.</li> <li>Returns <code>list[dict[str, object]]</code> for DISPLAY commands, <code>None</code> for   others.</li> </ul> <p>Queue manager commands (<code>DISPLAY QMGR</code>, <code>DISPLAY QMSTATUS</code>, etc.) have singleton helpers that return <code>dict | None</code> instead of a list.</p>"},{"location":"architecture/#ensure-pipeline","title":"Ensure pipeline","text":"<p>See ensure methods for details on the idempotent create-or-update pipeline.</p>"},{"location":"architecture/#sync-pipeline","title":"Sync pipeline","text":"<p>See sync methods for details on the synchronous polling pipeline.</p>"},{"location":"ensure-methods/","title":"Declarative object management","text":""},{"location":"ensure-methods/#the-problem-with-alter","title":"The problem with ALTER","text":"<p>Every <code>alter_*()</code> call sends an <code>ALTER</code> command to the queue manager, even when every specified attribute already matches the current state. MQ updates <code>ALTDATE</code> and <code>ALTTIME</code> on every <code>ALTER</code>, regardless of whether any values actually changed. This makes <code>ALTER</code> unsuitable for declarative configuration management where idempotency matters \u2014 running the same configuration twice should not corrupt audit timestamps.</p>"},{"location":"ensure-methods/#the-ensure-pattern","title":"The ensure pattern","text":"<p>The <code>ensure_*()</code> methods implement a declarative upsert pattern:</p> <ol> <li>DEFINE the object when it does not exist.</li> <li>ALTER only the attributes that differ from the current state.</li> <li>Do nothing when all specified attributes already match,    preserving <code>ALTDATE</code> and <code>ALTTIME</code>.</li> </ol> <p>Each call returns an <code>EnsureResult</code> indicating what action was taken:</p> <pre><code>from pymqrest import EnsureAction, EnsureResult\n\nclass EnsureAction(enum.Enum):\n    CREATED = \"created\"      # Object did not exist, was defined\n    UPDATED = \"updated\"      # Object existed, attributes were altered\n    UNCHANGED = \"unchanged\"  # Object existed, no changes needed\n\n@dataclass(frozen=True)\nclass EnsureResult:\n    action: EnsureAction\n    changed: tuple[str, ...] = ()  # Attribute names that triggered ALTER\n</code></pre>"},{"location":"ensure-methods/#basic-usage","title":"Basic usage","text":"<pre><code>from pymqrest import MQRESTSession, EnsureAction, EnsureResult\nfrom pymqrest.auth import LTPAAuth\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    verify_tls=False,\n)\n\n# First call \u2014 queue does not exist yet\nresult = session.ensure_qlocal(\n    \"APP.REQUEST.Q\",\n    request_parameters={\n        \"max_queue_depth\": 50000,\n        \"description\": \"Application request queue\",\n    },\n)\nassert result.action is EnsureAction.CREATED\n\n# Second call \u2014 same attributes, nothing to change\nresult = session.ensure_qlocal(\n    \"APP.REQUEST.Q\",\n    request_parameters={\n        \"max_queue_depth\": 50000,\n        \"description\": \"Application request queue\",\n    },\n)\nassert result.action is EnsureAction.UNCHANGED\n\n# Third call \u2014 description changed, only that attribute is altered\nresult = session.ensure_qlocal(\n    \"APP.REQUEST.Q\",\n    request_parameters={\n        \"max_queue_depth\": 50000,\n        \"description\": \"Updated request queue\",\n    },\n)\nassert result.action is EnsureAction.UPDATED\nassert result.changed == (\"description\",)\n</code></pre>"},{"location":"ensure-methods/#comparison-logic","title":"Comparison logic","text":"<p>The ensure methods compare only the attributes the caller passes in <code>request_parameters</code> against the current state returned by <code>DISPLAY</code>. Attributes not specified by the caller are ignored.</p> <p>Comparison is:</p> <ul> <li>Case-insensitive \u2014 <code>\"ENABLED\"</code> matches <code>\"enabled\"</code>.</li> <li>Type-normalizing \u2014 integer <code>5000</code> matches string <code>\"5000\"</code>.</li> <li>Whitespace-trimming \u2014 <code>\" YES \"</code> matches <code>\"YES\"</code>.</li> </ul> <p>An attribute present in <code>request_parameters</code> but absent from the <code>DISPLAY</code> response is treated as changed and included in the <code>ALTER</code>.</p>"},{"location":"ensure-methods/#selective-alter","title":"Selective ALTER","text":"<p>When an update is needed, only the changed attributes are sent in the <code>ALTER</code> command. Attributes that already match are excluded from the request. This minimizes the scope of each <code>ALTER</code> to the strict delta.</p>"},{"location":"ensure-methods/#available-methods","title":"Available methods","text":"<p>Each method targets a specific MQ object type with the correct MQSC qualifier triple (DISPLAY / DEFINE / ALTER):</p> Method Object type DISPLAY DEFINE ALTER <code>ensure_qmgr()</code> Queue manager <code>QMGR</code> \u2014 <code>QMGR</code> <code>ensure_qlocal()</code> Local queue <code>QUEUE</code> <code>QLOCAL</code> <code>QLOCAL</code> <code>ensure_qremote()</code> Remote queue <code>QUEUE</code> <code>QREMOTE</code> <code>QREMOTE</code> <code>ensure_qalias()</code> Alias queue <code>QUEUE</code> <code>QALIAS</code> <code>QALIAS</code> <code>ensure_qmodel()</code> Model queue <code>QUEUE</code> <code>QMODEL</code> <code>QMODEL</code> <code>ensure_channel()</code> Channel <code>CHANNEL</code> <code>CHANNEL</code> <code>CHANNEL</code> <code>ensure_authinfo()</code> Auth info <code>AUTHINFO</code> <code>AUTHINFO</code> <code>AUTHINFO</code> <code>ensure_listener()</code> Listener <code>LISTENER</code> <code>LISTENER</code> <code>LISTENER</code> <code>ensure_namelist()</code> Namelist <code>NAMELIST</code> <code>NAMELIST</code> <code>NAMELIST</code> <code>ensure_process()</code> Process <code>PROCESS</code> <code>PROCESS</code> <code>PROCESS</code> <code>ensure_service()</code> Service <code>SERVICE</code> <code>SERVICE</code> <code>SERVICE</code> <code>ensure_topic()</code> Topic <code>TOPIC</code> <code>TOPIC</code> <code>TOPIC</code> <code>ensure_sub()</code> Subscription <code>SUB</code> <code>SUB</code> <code>SUB</code> <code>ensure_stgclass()</code> Storage class <code>STGCLASS</code> <code>STGCLASS</code> <code>STGCLASS</code> <code>ensure_comminfo()</code> Comm info <code>COMMINFO</code> <code>COMMINFO</code> <code>COMMINFO</code> <code>ensure_cfstruct()</code> CF structure <code>CFSTRUCT</code> <code>CFSTRUCT</code> <code>CFSTRUCT</code> <p>Most methods share the same signature:</p> <pre><code>def ensure_qlocal(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n</code></pre> <p><code>response_parameters</code> is not exposed \u2014 the ensure logic always requests <code>[\"all\"]</code> internally so it can compare the full current state.</p>"},{"location":"ensure-methods/#queue-manager-singleton","title":"Queue manager (singleton)","text":"<p><code>ensure_qmgr()</code> has no <code>name</code> parameter because the queue manager is a singleton that always exists.  It can only return <code>UPDATED</code> or <code>UNCHANGED</code> (never <code>CREATED</code>):</p> <pre><code>def ensure_qmgr(\n    self,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n</code></pre> <p>This makes it ideal for asserting queue manager-level settings such as statistics, monitoring, events, and logging attributes without corrupting <code>ALTDATE</code>/<code>ALTTIME</code> on every run.</p>"},{"location":"ensure-methods/#attribute-mapping","title":"Attribute mapping","text":"<p>The ensure methods participate in the same mapping pipeline as all other command methods. Pass <code>snake_case</code> attribute names in <code>request_parameters</code> and the mapping layer translates them to MQSC names for the DISPLAY, DEFINE, and ALTER commands automatically.</p>"},{"location":"ensure-methods/#configuration-management-example","title":"Configuration management example","text":"<p>The ensure pattern is designed for scripts that declare desired state:</p> <pre><code>def configure_queue_manager(session):\n    \"\"\"Ensure queue manager attributes are set for production.\"\"\"\n    result = session.ensure_qmgr(request_parameters={\n        \"queue_statistics\": \"on\",\n        \"channel_statistics\": \"on\",\n        \"queue_monitoring\": \"medium\",\n        \"channel_monitoring\": \"medium\",\n    })\n    print(f\"Queue manager: {result.action.value}\")\n\n    queues = {\n        \"APP.REQUEST.Q\": {\"max_queue_depth\": 50000, \"default_persistence\": \"yes\"},\n        \"APP.REPLY.Q\": {\"max_queue_depth\": 10000, \"default_persistence\": \"no\"},\n        \"APP.DLQ\": {\"max_queue_depth\": 100000, \"default_persistence\": \"yes\"},\n    }\n\n    for name, attrs in queues.items():\n        result = session.ensure_qlocal(name, request_parameters=attrs)\n        print(f\"{name}: {result.action.value}\")\n</code></pre> <p>Running this script repeatedly produces no side effects when the configuration is already correct. Only genuine changes trigger <code>ALTER</code> commands, keeping <code>ALTDATE</code>/<code>ALTTIME</code> accurate.</p>"},{"location":"examples/","title":"Examples","text":"<p>The <code>examples/</code> directory contains practical scripts that demonstrate common MQ administration tasks using <code>pymqrest</code>. Each script is self-contained and can be run against the local Docker environment.</p>"},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>Start the multi-queue-manager Docker environment and seed both queue managers:</p> <pre><code>./scripts/dev/mq_start.sh\n./scripts/dev/mq_seed.sh\n</code></pre> <p>This starts two queue managers (<code>QM1</code> on port 9443, <code>QM2</code> on port 9444) on a shared Docker network. See local MQ container for details.</p>"},{"location":"examples/#running-examples","title":"Running examples","text":"<p>Each script reads connection details from environment variables with sensible defaults for the local Docker setup:</p> <pre><code>uv run python3 examples/health_check.py\nuv run python3 examples/queue_depth_monitor.py\nuv run python3 examples/channel_status.py\nuv run python3 examples/queue_status.py\nuv run python3 examples/dlq_inspector.py\nuv run python3 examples/provision_environment.py\n</code></pre>"},{"location":"examples/#health-check","title":"Health check","text":"<p><code>examples/health_check.py</code> connects to one or more queue managers and checks:</p> <ul> <li>Queue manager attributes via <code>display_qmgr()</code></li> <li>Running status via <code>display_qmstatus()</code></li> <li>Command server availability via <code>display_cmdserv()</code></li> <li>Listener definitions via <code>display_listener()</code></li> </ul> <p>Produces a pass/fail summary for each queue manager. Set <code>MQ_REST_BASE_URL_QM2</code> to also check QM2:</p> <pre><code>MQ_REST_BASE_URL_QM2=https://localhost:9444/ibmmq/rest/v2 \\\n    uv run python3 examples/health_check.py\n</code></pre>"},{"location":"examples/#queue-depth-monitor","title":"Queue depth monitor","text":"<p><code>examples/queue_depth_monitor.py</code> displays all local queues with their current depth and flags queues approaching capacity:</p> <ul> <li>Lists all local queues via <code>display_queue()</code></li> <li>Calculates depth percentage (<code>current_queue_depth / max_queue_depth</code>)</li> <li>Flags queues above a configurable threshold (default 80%)</li> </ul> <p>Set <code>DEPTH_THRESHOLD_PCT</code> to change the warning threshold:</p> <pre><code>DEPTH_THRESHOLD_PCT=50 uv run python3 examples/queue_depth_monitor.py\n</code></pre>"},{"location":"examples/#channel-status-report","title":"Channel status report","text":"<p><code>examples/channel_status.py</code> cross-references channel definitions with live channel status:</p> <ul> <li>Retrieves definitions via <code>display_channel()</code></li> <li>Retrieves live status via <code>display_chstatus()</code></li> <li>Identifies channels that are defined but not running</li> </ul>"},{"location":"examples/#queue-status-and-connection-handles","title":"Queue status and connection handles","text":"<p><code>examples/queue_status.py</code> demonstrates how <code>pymqrest</code> handles the nested <code>objects</code> response structure returned by <code>TYPE(HANDLE)</code> queries:</p> <ul> <li>Retrieves per-handle queue status via <code>display_qstatus()</code> with   <code>request_parameters={\"type\": \"HANDLE\"}</code></li> <li>Retrieves per-handle connection details via <code>display_conn()</code> with   <code>request_parameters={\"connection_info_type\": \"HANDLE\"}</code></li> <li>Shows that <code>pymqrest</code> transparently flattens the nested response into   uniform flat dicts \u2014 each result contains both parent-scoped and   per-handle attributes</li> </ul> <p>The results may be empty if no applications have active handles on the queue manager.</p>"},{"location":"examples/#dead-letter-queue-inspector","title":"Dead letter queue inspector","text":"<p><code>examples/dlq_inspector.py</code> inspects the dead letter queue configuration:</p> <ul> <li>Reads the DLQ name from <code>display_qmgr()</code></li> <li>Queries DLQ depth and capacity via <code>display_queue()</code></li> <li>Suggests actions based on queue state</li> </ul>"},{"location":"examples/#environment-provisioner","title":"Environment provisioner","text":"<p><code>examples/provision_environment.py</code> demonstrates bulk provisioning across two queue managers:</p> <ul> <li>Defines local queues, transmission queues, and remote queue definitions</li> <li>Creates sender/receiver channel pairs between QM1 and QM2</li> <li>Verifies provisioned objects with display commands</li> <li>Includes a teardown function that removes all created objects</li> </ul> <p>Requires both QM1 and QM2:</p> <pre><code>uv run python3 examples/provision_environment.py\n</code></pre>"},{"location":"examples/#testability","title":"Testability","text":"<p>Each example exposes its core logic as a function that accepts an <code>MQRESTSession</code> and returns structured data. The <code>__main__</code> block handles session construction from environment variables. This allows integration tests to call the functions directly:</p> <pre><code>from pymqrest import MQRESTSession\nfrom pymqrest.auth import LTPAAuth\nfrom examples.health_check import check_health\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    verify_tls=False,\n)\n\nresult = check_health(session)\nassert result.passed\n</code></pre> <p>Integration tests for all examples are in <code>tests/integration/test_examples.py</code> and run with:</p> <pre><code>PYMQREST_RUN_INTEGRATION=1 uv run pytest tests/integration/test_examples.py\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.12 or later</li> <li>IBM MQ: A running queue manager with the administrative REST API enabled</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install <code>pymqrest</code> from source using uv:</p> <pre><code>uv add pymqrest\n</code></pre> <p>Or with pip:</p> <pre><code>pip install pymqrest\n</code></pre>"},{"location":"getting-started/#creating-a-session","title":"Creating a session","text":"<p>All interaction with IBM MQ goes through an <code>MQRESTSession</code>. You need the REST API base URL, queue manager name, and credentials:</p> <pre><code>from pymqrest import MQRESTSession\nfrom pymqrest.auth import LTPAAuth\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    verify_tls=False,  # for local development only\n)\n</code></pre>"},{"location":"getting-started/#running-a-command","title":"Running a command","text":"<p>Every MQSC command has a corresponding method on the session. Method names follow the pattern <code>&lt;verb&gt;_&lt;qualifier&gt;</code> in lowercase:</p> <pre><code># DISPLAY QUEUE \u2014 returns a list of dicts\nqueues = session.display_queue(name=\"SYSTEM.*\")\n\nfor queue in queues:\n    print(queue[\"queue_name\"], queue.get(\"current_queue_depth\"))\n</code></pre> <pre><code># DISPLAY QMGR \u2014 returns a single dict or None\nqmgr = session.display_qmgr()\nif qmgr:\n    print(qmgr[\"queue_manager_name\"])\n</code></pre>"},{"location":"getting-started/#attribute-mapping","title":"Attribute mapping","text":"<p>By default, <code>pymqrest</code> maps between Python-friendly <code>snake_case</code> names and MQSC parameter names. This applies to both request and response attributes:</p> <pre><code># With mapping enabled (default)\nqueues = session.display_queue(\n    name=\"MY.QUEUE\",\n    response_parameters=[\"current_queue_depth\", \"max_queue_depth\"],\n)\n# Returns: [{\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}]\n\n# With mapping disabled\nqueues = session.display_queue(\n    name=\"MY.QUEUE\",\n    response_parameters=[\"CURDEPTH\", \"MAXDEPTH\"],\n    map_attributes=False,\n)\n# Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre> <p>Mapping can be disabled at the session level or per method call:</p> <pre><code># Disable mapping for the entire session\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    map_attributes=False,\n)\n</code></pre> <p>See mapping pipeline for a detailed explanation of how mapping works.</p>"},{"location":"getting-started/#strict-vs-lenient-mapping","title":"Strict vs lenient mapping","text":"<p>By default, mapping runs in strict mode. Unknown attribute names or values raise a <code>MappingError</code>. In lenient mode, unknown attributes pass through unchanged:</p> <pre><code># Lenient mode \u2014 unknown attributes pass through\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    mapping_strict=False,\n)\n</code></pre>"},{"location":"getting-started/#custom-mapping-overrides","title":"Custom mapping overrides","text":"<p>Sites with existing naming conventions can override individual entries in the built-in mapping tables without forking or replacing them entirely. Pass a <code>mapping_overrides</code> dict when creating the session:</p> <pre><code>session = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    verify_tls=False,\n    mapping_overrides={\n        \"qualifiers\": {\n            \"queue\": {\n                \"response_key_map\": {\n                    \"CURDEPTH\": \"queue_depth\",        # override built-in \"current_queue_depth\"\n                    \"MAXDEPTH\": \"queue_max_depth\",    # override built-in \"max_queue_depth\"\n                },\n            },\n        },\n    },\n)\n\nqueues = session.display_queue(name=\"MY.QUEUE\")\n# Returns: [{\"queue_depth\": 0, \"queue_max_depth\": 5000, ...}]\n</code></pre> <p>Overrides are sparse \u2014 you only specify the entries you want to change. All other mappings in the qualifier continue to work as normal. In the example above, only <code>CURDEPTH</code> and <code>MAXDEPTH</code> are remapped; every other queue attribute keeps its default <code>snake_case</code> name.</p> <p>Request-side mappings work the same way:</p> <pre><code>session = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    verify_tls=False,\n    mapping_overrides={\n        \"qualifiers\": {\n            \"queue\": {\n                \"request_key_map\": {\n                    \"queue_depth\": \"CURDEPTH\",     # use your name on the request side too\n                },\n                \"response_key_map\": {\n                    \"CURDEPTH\": \"queue_depth\",     # and on the response side\n                },\n            },\n        },\n    },\n)\n\n# Now \"queue_depth\" works in WHERE filters, response_parameters, etc.\nqueues = session.display_queue(where=\"queue_depth GT 100\")\n</code></pre> <p>Overrides support all five sub-maps per qualifier: <code>request_key_map</code>, <code>request_value_map</code>, <code>request_key_value_map</code>, <code>response_key_map</code>, and <code>response_value_map</code>. See mapping pipeline for details on how each sub-map is used.</p> <p>Invalid override structures raise <code>ValueError</code> or <code>TypeError</code> at session construction time, so errors are caught early.</p>"},{"location":"getting-started/#gateway-queue-manager","title":"Gateway queue manager","text":"<p>The MQ REST API is available on all supported IBM MQ platforms (Linux, AIX, Windows, z/OS, and IBM i). pymqrest is developed and tested against the Linux implementation only.</p> <p>In enterprise environments, a gateway queue manager can route MQSC commands to remote queue managers via MQ channels \u2014 the same mechanism used by <code>runmqsc -w</code> and the MQ Console.</p> <p>To use a gateway, pass <code>gateway_qmgr</code> when creating the session. The <code>qmgr_name</code> parameter specifies the target (remote) queue manager, while <code>gateway_qmgr</code> names the local queue manager whose REST API routes the command:</p> <pre><code>from pymqrest import MQRESTSession\nfrom pymqrest.auth import BasicAuth\n\n# Route commands to QM2 through QM1's REST API\nsession = MQRESTSession(\n    rest_base_url=\"https://qm1-host:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM2\",           # target queue manager\n    credentials=BasicAuth(\"mqadmin\", \"mqadmin\"),\n    gateway_qmgr=\"QM1\",        # local gateway queue manager\n    verify_tls=False,\n)\n\nqmgr = session.display_qmgr()\n# Returns QM2's queue manager attributes, routed through QM1\n</code></pre> <p>Prerequisites:</p> <ul> <li>The gateway queue manager must have a running REST API.</li> <li>MQ channels must be configured between the gateway and target queue managers.</li> <li>A QM alias (QREMOTE with empty RNAME) must map the target QM name to the   correct transmission queue on the gateway.</li> </ul>"},{"location":"getting-started/#error-handling","title":"Error handling","text":"<p><code>DISPLAY</code> commands return an empty list when no objects match. Queue manager display methods return <code>None</code> when no match is found. Non-display commands raise <code>MQRESTCommandError</code> on failure:</p> <pre><code>from pymqrest.exceptions import MQRESTCommandError\n\n# Empty list \u2014 no exception\nresult = session.display_queue(name=\"NONEXISTENT.*\")\nassert result == []\n\n# Define raises on error\ntry:\n    session.define_qlocal(name=\"MY.QUEUE\")\nexcept MQRESTCommandError as error:\n    print(error)\n    print(error.payload)  # full MQ response payload\n</code></pre>"},{"location":"getting-started/#diagnostic-state","title":"Diagnostic state","text":"<p>The session retains the most recent request and response for inspection:</p> <pre><code>session.display_queue(name=\"MY.QUEUE\")\n\nprint(session.last_command_payload)    # the JSON sent to MQ\nprint(session.last_response_payload)   # the parsed JSON response\nprint(session.last_http_status)        # HTTP status code\nprint(session.last_response_text)      # raw response body\n</code></pre>"},{"location":"mapping-pipeline/","title":"Mapping pipeline","text":""},{"location":"mapping-pipeline/#the-three-namespace-problem","title":"The three-namespace problem","text":"<p>IBM MQ uses multiple naming conventions depending on the interface:</p> MQSC names (e.g. <code>CURDEPTH</code>, <code>DEFPSIST</code>) Short, uppercase tokens used in MQSC commands and the REST API's   <code>runCommandJSON</code> endpoint. PCF names (e.g. <code>CurrentQDepth</code>, <code>DefPersistence</code>) CamelCase names from the Programmable Command Formats. Not used   directly by <code>pymqrest</code>, but they form the intermediate namespace in   the mapping pipeline. Developer names (e.g. <code>current_queue_depth</code>, <code>default_persistence</code>) Human-readable <code>snake_case</code> names for use in application code. <p>The mapping pipeline translates between MQSC and developer names. PCF names were used as an intermediate reference during the original extraction process that bootstrapped the mapping tables but do not appear at runtime.</p> <pre><code># With mapping enabled (default) \u2014 developer names\nqueues = session.display_queue(\n    name=\"MY.QUEUE\",\n    response_parameters=[\"current_queue_depth\", \"max_queue_depth\"],\n)\n# Returns: [{\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}]\n\n# With mapping disabled \u2014 native MQSC names\nqueues = session.display_queue(\n    name=\"MY.QUEUE\",\n    response_parameters=[\"CURDEPTH\", \"MAXDEPTH\"],\n    map_attributes=False,\n)\n# Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre>"},{"location":"mapping-pipeline/#qualifier-based-mapping","title":"Qualifier-based mapping","text":"<p>Mappings are organized by qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>), not by command. A single qualifier's mapping tables serve all commands that operate on that object type. For example, the <code>queue</code> qualifier covers <code>DISPLAY QUEUE</code>, <code>DEFINE QLOCAL</code>, <code>DELETE QALIAS</code>, and all other queue-related commands.</p> <p>This design avoids duplicating mapping data across commands and reflects how MQSC attributes are shared across command verbs.</p> <p>See qualifier mapping reference for the complete per-qualifier reference.</p>"},{"location":"mapping-pipeline/#request-mapping-flow","title":"Request mapping flow","text":"<p>When mapping is enabled, request attributes are translated before sending to the MQ REST API:</p> <ol> <li> <p>Key mapping: Each <code>snake_case</code> attribute name is looked up in the    qualifier's <code>request_key_map</code>. If found, the key is replaced with the    MQSC parameter name.</p> </li> <li> <p>Value mapping: For attributes with enumerated values, the    qualifier's <code>request_value_map</code> translates Python values to MQSC    values (e.g. <code>\"yes\"</code> \u2192 <code>\"YES\"</code>).</p> </li> <li> <p>Key-value mapping: Some attributes require both key and value to    change simultaneously. The <code>request_key_value_map</code> handles cases    where a single Python attribute expands to a different MQSC key+value    pair (e.g. <code>channel_type=\"server_connection\"</code> \u2192    <code>CHLTYPE(\"SVRCONN\")</code>).</p> </li> </ol> <pre><code>session.define_qlocal(\n    name=\"MY.QUEUE\",\n    request_parameters={\n        \"max_queue_depth\": 50000,\n        \"default_persistence\": \"yes\",\n        \"description\": \"Application queue\",\n    },\n)\n\n# After request mapping, the JSON payload sent to MQ contains:\n# { \"MAXDEPTH\": 50000, \"DEFPSIST\": \"YES\", \"DESCR\": \"Application queue\" }\n</code></pre>"},{"location":"mapping-pipeline/#response-mapping-flow","title":"Response mapping flow","text":"<p>Response attributes are translated after receiving the MQ REST response:</p> <ol> <li> <p>Key mapping: Each MQSC parameter name from the response is looked    up in the qualifier's <code>response_key_map</code>. If found, the key is    replaced with the <code>snake_case</code> name.</p> </li> <li> <p>Value mapping: Enumerated MQSC values are translated to    Python-friendly values via the <code>response_value_map</code> (e.g. <code>\"YES\"</code> \u2192    <code>\"yes\"</code>).</p> </li> </ol> <pre><code>queues = session.display_queue(\n    name=\"MY.QUEUE\",\n    response_parameters=[\"current_queue_depth\", \"max_queue_depth\"],\n)\n\n# MQ returns MQSC names:  {\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}\n# After response mapping:  {\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}\n</code></pre>"},{"location":"mapping-pipeline/#response-parameter-mapping","title":"Response parameter mapping","text":"<p>When the caller specifies <code>response_parameters</code> (the list of attributes to return), those names are also mapped from <code>snake_case</code> to MQSC before being sent in the request. This allows callers to request specific attributes using Python names.</p> <p>Response parameter macros (like <code>CFCONLOS</code> for channel status) are recognized and passed through without mapping.</p>"},{"location":"mapping-pipeline/#where-keyword-mapping","title":"WHERE keyword mapping","text":"<p>The <code>where</code> parameter on DISPLAY methods accepts a filter expression like <code>\"current_queue_depth GT 100\"</code>. The first token (the keyword) is mapped from <code>snake_case</code> to the MQSC name. The rest of the expression is passed through unchanged.</p>"},{"location":"mapping-pipeline/#strict-vs-lenient-mode","title":"Strict vs lenient mode","text":"<p>Strict mode (default): Any attribute name or value that cannot be mapped raises a <code>MappingError</code>. This catches typos and unsupported attributes early.</p> <p>Lenient mode (<code>mapping_strict=False</code>): Unknown attribute names and values pass through unchanged. This is useful when working with attributes not yet covered by the mapping tables.</p> <p>The mode is set at session creation and applies to all mapping operations. It cannot be overridden per-call.</p> <pre><code># Strict mode (default) \u2014 unknown attributes raise MappingError\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    mapping_strict=True,\n)\n\n# Lenient mode \u2014 unknown attributes pass through unchanged\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    mapping_strict=False,\n)\n</code></pre>"},{"location":"mapping-pipeline/#qualifier-resolution","title":"Qualifier resolution","text":"<p>When a command is executed, the mapping qualifier is resolved by:</p> <ol> <li>Looking up the command key (e.g. <code>\"DISPLAY QUEUE\"</code>) in    <code>MAPPING_DATA[\"commands\"]</code> for an explicit qualifier.</li> <li>Falling back to a hardcoded default map (e.g. <code>QLOCAL</code> \u2192 <code>queue</code>,    <code>CHANNEL</code> \u2192 <code>channel</code>).</li> <li>As a last resort, lowercasing the MQSC qualifier.</li> </ol> <p>This means <code>DEFINE QLOCAL</code>, <code>DEFINE QREMOTE</code>, and <code>DISPLAY QUEUE</code> all resolve to the <code>queue</code> qualifier and share the same mapping tables.</p>"},{"location":"mapping-pipeline/#custom-mapping-overrides","title":"Custom mapping overrides","text":"<p>The built-in mapping tables cover all standard MQSC attributes, but sites may use different <code>snake_case</code> conventions. The <code>mapping_overrides</code> parameter on <code>MQRESTSession</code> lets you layer sparse changes on top of the built-in data without replacing it.</p>"},{"location":"mapping-pipeline/#how-merging-works","title":"How merging works","text":"<p>Overrides are merged at the key level within each sub-map:</p> <pre><code>mapping_overrides = {\n    \"qualifiers\": {\n        \"queue\": {\n            \"response_key_map\": {\n                \"CURDEPTH\": \"queue_depth\",   # replaces the built-in mapping for CURDEPTH\n            },\n        },\n    },\n}\n</code></pre> <p>When this override is applied:</p> <ol> <li>The built-in <code>MAPPING_DATA</code> is deep-copied (the original is never mutated).</li> <li>The <code>queue</code> qualifier's <code>response_key_map</code> is updated: the entry for    <code>CURDEPTH</code> changes from <code>\"current_queue_depth\"</code> to <code>\"queue_depth\"</code>.</li> <li>All other entries in <code>response_key_map</code> (and all other sub-maps) remain    unchanged.</li> </ol> <p>This means you only specify the entries you want to change. A single override entry doesn't affect the hundreds of other mappings.</p>"},{"location":"mapping-pipeline/#supported-override-keys","title":"Supported override keys","text":"<p>The top level of <code>mapping_overrides</code> accepts two keys:</p> <ul> <li><code>commands</code>: Override command-level metadata (e.g. which qualifier a   command resolves to). Each command entry is shallow-merged.</li> <li><code>qualifiers</code>: Override qualifier mapping tables. Each qualifier supports   five sub-maps:</li> <li><code>request_key_map</code> \u2014 <code>snake_case</code> \u2192 MQSC key mapping for requests</li> <li><code>request_value_map</code> \u2014 value translations for request attributes</li> <li><code>request_key_value_map</code> \u2014 combined key+value translations for requests</li> <li><code>response_key_map</code> \u2014 MQSC \u2192 <code>snake_case</code> key mapping for responses</li> <li><code>response_value_map</code> \u2014 value translations for response attributes</li> </ul>"},{"location":"mapping-pipeline/#adding-new-qualifiers","title":"Adding new qualifiers","text":"<p>You can add mappings for qualifiers not yet covered by the built-in data:</p> <pre><code>mapping_overrides = {\n    \"qualifiers\": {\n        \"custom_object\": {\n            \"request_key_map\": {\"my_attr\": \"MYATTR\"},\n            \"response_key_map\": {\"MYATTR\": \"my_attr\"},\n            \"request_value_map\": {},\n            \"response_value_map\": {},\n        },\n    },\n}\n</code></pre>"},{"location":"mapping-pipeline/#validation","title":"Validation","text":"<p>The override structure is validated at session construction time. Invalid shapes raise <code>TypeError</code> (wrong types) or <code>ValueError</code> (unknown keys) immediately, so errors are caught before any commands are sent.</p>"},{"location":"mapping-pipeline/#opting-out","title":"Opting out","text":"<p>Mapping can be disabled entirely or selectively:</p> <p>Session-level: Pass <code>map_attributes=False</code> when creating the session.</p> <p>Per-call: Pass <code>map_attributes=False</code> to any command method. This overrides the session default for that single call.</p> <p>When mapping is disabled, attributes pass through in their native MQSC form.</p> <pre><code># Session-level opt-out\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    map_attributes=False,\n)\n\n# Per-call opt-out (overrides session default for one call)\nqueues = session.display_queue(\n    name=\"MY.QUEUE\",\n    response_parameters=[\"CURDEPTH\", \"MAXDEPTH\"],\n    map_attributes=False,\n)\n# Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre>"},{"location":"sync-methods/","title":"Synchronous start/stop/restart","text":""},{"location":"sync-methods/#the-problem-with-fire-and-forget","title":"The problem with fire-and-forget","text":"<p>All MQSC <code>START</code> and <code>STOP</code> commands are fire-and-forget \u2014 they return immediately without waiting for the object to reach its target state. In practice, tooling that provisions infrastructure needs to wait until a channel is <code>RUNNING</code> or a listener is <code>STOPPED</code> before proceeding to the next step. Writing polling loops by hand is error-prone and clutters business logic with retry mechanics.</p>"},{"location":"sync-methods/#the-sync-pattern","title":"The sync pattern","text":"<p>The <code>*_sync</code> and <code>restart_*</code> methods wrap the fire-and-forget commands with a polling loop that issues <code>DISPLAY *STATUS</code> until the object reaches a stable state or the timeout expires.</p> <p>Each call returns a <code>SyncResult</code> describing what happened:</p> <pre><code>from pymqrest import SyncConfig, SyncOperation, SyncResult\n\nclass SyncOperation(enum.Enum):\n    STARTED = \"started\"      # Object confirmed running\n    STOPPED = \"stopped\"      # Object confirmed stopped\n    RESTARTED = \"restarted\"  # Stop-then-start completed\n\n@dataclass(frozen=True)\nclass SyncResult:\n    operation: SyncOperation\n    polls: int                # Number of status polls issued\n    elapsed_seconds: float    # Wall-clock time from command to confirmation\n</code></pre> <p>Polling is controlled by a <code>SyncConfig</code> dataclass:</p> <pre><code>@dataclass(frozen=True)\nclass SyncConfig:\n    timeout_seconds: float = 30.0      # Max wait before raising\n    poll_interval_seconds: float = 1.0  # Seconds between polls\n</code></pre> <p>If the object does not reach the target state within the timeout, <code>MQRESTTimeoutError</code> is raised.</p>"},{"location":"sync-methods/#basic-usage","title":"Basic usage","text":"<pre><code>from pymqrest import MQRESTSession, SyncConfig, SyncOperation\nfrom pymqrest.auth import BasicAuth\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=BasicAuth(\"mqadmin\", \"mqadmin\"),\n    verify_tls=False,\n)\n\n# Start a channel and wait until it is RUNNING\nresult = session.start_channel_sync(\"TO.PARTNER\")\nassert result.operation is SyncOperation.STARTED\nprint(f\"Channel running after {result.polls} poll(s), {result.elapsed_seconds:.1f}s\")\n\n# Stop a listener and wait until it is STOPPED\nresult = session.stop_listener_sync(\"TCP.LISTENER\")\nassert result.operation is SyncOperation.STOPPED\n</code></pre>"},{"location":"sync-methods/#restart-convenience","title":"Restart convenience","text":"<p>The <code>restart_*</code> methods perform a synchronous stop followed by a synchronous start. Each phase gets the full timeout independently \u2014 worst case is 2x the configured timeout.</p> <p>The returned <code>SyncResult</code> reports total polls and total elapsed time across both phases:</p> <pre><code>result = session.restart_channel(\"TO.PARTNER\")\nassert result.operation is SyncOperation.RESTARTED\nprint(f\"Restarted in {result.elapsed_seconds:.1f}s ({result.polls} total polls)\")\n</code></pre>"},{"location":"sync-methods/#custom-timeout-and-poll-interval","title":"Custom timeout and poll interval","text":"<p>Pass a <code>SyncConfig</code> to override the defaults:</p> <pre><code>from pymqrest import SyncConfig\n\n# Aggressive polling for fast local development\nfast = SyncConfig(timeout_seconds=10.0, poll_interval_seconds=0.25)\nresult = session.start_service_sync(\"MY.SVC\", config=fast)\n\n# Patient polling for remote queue managers\npatient = SyncConfig(timeout_seconds=120.0, poll_interval_seconds=5.0)\nresult = session.start_channel_sync(\"REMOTE.CHL\", config=patient)\n</code></pre>"},{"location":"sync-methods/#timeout-handling","title":"Timeout handling","text":"<p>When the timeout expires, <code>MQRESTTimeoutError</code> is raised with diagnostic attributes:</p> <pre><code>from pymqrest import MQRESTTimeoutError, SyncConfig\n\ntry:\n    session.start_channel_sync(\n        \"BROKEN.CHL\",\n        config=SyncConfig(timeout_seconds=15.0),\n    )\nexcept MQRESTTimeoutError as err:\n    print(f\"Object: {err.name}\")       # \"BROKEN.CHL\"\n    print(f\"Operation: {err.operation}\")  # \"start\"\n    print(f\"Elapsed: {err.elapsed:.1f}s\")  # 15.0\n</code></pre> <p><code>MQRESTTimeoutError</code> inherits from <code>MQRESTError</code>, so existing <code>except MQRESTError</code> handlers will catch it.</p>"},{"location":"sync-methods/#available-methods","title":"Available methods","text":"Method Operation START/STOP qualifier Status qualifier <code>start_channel_sync()</code> Start <code>CHANNEL</code> <code>CHSTATUS</code> <code>stop_channel_sync()</code> Stop <code>CHANNEL</code> <code>CHSTATUS</code> <code>restart_channel()</code> Restart <code>CHANNEL</code> <code>CHSTATUS</code> <code>start_listener_sync()</code> Start <code>LISTENER</code> <code>LSSTATUS</code> <code>stop_listener_sync()</code> Stop <code>LISTENER</code> <code>LSSTATUS</code> <code>restart_listener()</code> Restart <code>LISTENER</code> <code>LSSTATUS</code> <code>start_service_sync()</code> Start <code>SERVICE</code> <code>SVSTATUS</code> <code>stop_service_sync()</code> Stop <code>SERVICE</code> <code>SVSTATUS</code> <code>restart_service()</code> Restart <code>SERVICE</code> <code>SVSTATUS</code> <p>All methods share the same signature:</p> <pre><code>def start_channel_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n</code></pre> <p>The <code>config</code> parameter is keyword-only for API clarity.</p>"},{"location":"sync-methods/#status-detection","title":"Status detection","text":"<p>The polling loop checks the <code>STATUS</code> attribute in the <code>DISPLAY *STATUS</code> response. The target values are:</p> <ul> <li>Start: <code>RUNNING</code></li> <li>Stop: <code>STOPPED</code></li> </ul>"},{"location":"sync-methods/#channel-stop-edge-case","title":"Channel stop edge case","text":"<p>When a channel stops, its <code>CHSTATUS</code> record may disappear entirely (the <code>DISPLAY CHSTATUS</code> response returns no rows). The channel sync methods treat an empty status result as successfully stopped. Listener and service status records are always present, so empty results are not treated as stopped for those object types.</p>"},{"location":"sync-methods/#attribute-mapping","title":"Attribute mapping","text":"<p>The sync methods call <code>_mqsc_command</code> internally, so they participate in the same mapping pipeline as all other command methods. The status key is checked using both the mapped <code>snake_case</code> name and the raw MQSC name, so polling works correctly regardless of whether mapping is enabled or disabled.</p>"},{"location":"sync-methods/#provisioning-example","title":"Provisioning example","text":"<p>The sync methods pair naturally with the ensure methods for end-to-end provisioning:</p> <pre><code>from pymqrest import SyncConfig\n\nconfig = SyncConfig(timeout_seconds=60.0)\n\n# Ensure listeners exist for application and admin traffic\nsession.ensure_listener(\"APP.LISTENER\", request_parameters={\n    \"transport_type\": \"TCP\",\n    \"port\": 1415,\n    \"start_mode\": \"MQSVC_CONTROL_Q_MGR\",\n})\nsession.ensure_listener(\"ADMIN.LISTENER\", request_parameters={\n    \"transport_type\": \"TCP\",\n    \"port\": 1416,\n    \"start_mode\": \"MQSVC_CONTROL_Q_MGR\",\n})\n\n# Start them synchronously\nsession.start_listener_sync(\"APP.LISTENER\", config=config)\nsession.start_listener_sync(\"ADMIN.LISTENER\", config=config)\n\nprint(\"Listeners ready\")\n</code></pre>"},{"location":"sync-methods/#rolling-restart-example","title":"Rolling restart example","text":"<p>Restart all listeners with error handling \u2014 useful when a queue manager serves multiple TCP ports for different client populations:</p> <pre><code>from pymqrest import MQRESTTimeoutError, SyncConfig\n\nlisteners = [\"APP.LISTENER\", \"ADMIN.LISTENER\", \"PARTNER.LISTENER\"]\nconfig = SyncConfig(timeout_seconds=30.0, poll_interval_seconds=2.0)\n\nfor name in listeners:\n    try:\n        result = session.restart_listener(name, config=config)\n        print(f\"{name}: restarted in {result.elapsed_seconds:.1f}s\")\n    except MQRESTTimeoutError as err:\n        print(f\"{name}: timed out after {err.elapsed:.1f}s\")\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core","title":"Core","text":"<ul> <li>Session \u2014 <code>MQRESTSession</code> class and construction options</li> <li>Commands \u2014 MQSC command methods</li> <li>Transport \u2014 <code>MQRESTTransport</code> protocol and mock testing</li> </ul>"},{"location":"api/#authentication","title":"Authentication","text":"<ul> <li>Auth \u2014 Credential types (LTPA, Basic, Certificate)</li> </ul>"},{"location":"api/#mapping","title":"Mapping","text":"<ul> <li>Mapping \u2014 Attribute mapping internals and override modes</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":"<ul> <li>Exceptions \u2014 Error types and handling patterns</li> </ul>"},{"location":"api/#patterns","title":"Patterns","text":"<ul> <li>Ensure \u2014 Idempotent object management methods</li> <li>Sync \u2014 Synchronous polling operations</li> </ul>"},{"location":"api/auth/","title":"Authentication","text":"<p>The authentication module provides credential types for the three authentication modes supported by the IBM MQ REST API: mutual TLS (mTLS) client certificates, LTPA token, and HTTP Basic.</p> <p>Pass a credential object to <code>MQRESTSession</code> via the <code>credentials</code> keyword argument. Always use TLS (<code>https://</code>) for production deployments to protect credentials and data in transit.</p> <pre><code>from pymqrest import MQRESTSession, BasicAuth, LTPAAuth, CertificateAuth\n\n# mTLS client certificate auth \u2014 strongest; no shared secrets\nsession = MQRESTSession(\"https://...\", \"QM1\", credentials=CertificateAuth(\"/cert.pem\", \"/key.pem\"))\n\n# LTPA token auth \u2014 credentials sent once at login, then cookie-based\nsession = MQRESTSession(\"https://...\", \"QM1\", credentials=LTPAAuth(\"user\", \"pass\"))\n\n# Basic auth \u2014 credentials sent with every request\nsession = MQRESTSession(\"https://...\", \"QM1\", credentials=BasicAuth(\"user\", \"pass\"))\n</code></pre>"},{"location":"api/auth/#credential-types","title":"Credential Types","text":"<p>Mutual TLS (mTLS) client certificate authentication.</p> <p>The client certificate is configured on the transport layer. No <code>Authorization</code> header is sent.</p> <p>Attributes:</p> Name Type Description <code>cert_path</code> <code>str</code> <p>Path to the client certificate PEM file.</p> <code>key_path</code> <code>str | None</code> <p>Path to the private key PEM file, or <code>None</code> if the key is included in the certificate file.</p> Source code in <code>src/pymqrest/auth.py</code> <pre><code>@dataclass(frozen=True)\nclass CertificateAuth:\n    \"\"\"Mutual TLS (mTLS) client certificate authentication.\n\n    The client certificate is configured on the transport layer.\n    No ``Authorization`` header is sent.\n\n    Attributes:\n        cert_path: Path to the client certificate PEM file.\n        key_path: Path to the private key PEM file, or ``None``\n            if the key is included in the certificate file.\n\n    \"\"\"\n\n    cert_path: str\n    key_path: str | None = None\n</code></pre> <p>LTPA token-based authentication credentials.</p> <p>The session performs an LTPA login at construction time and uses the returned <code>LtpaToken2</code> cookie for subsequent requests.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>Username for the LTPA login request.</p> <code>password</code> <code>str</code> <p>Password for the LTPA login request.</p> Source code in <code>src/pymqrest/auth.py</code> <pre><code>@dataclass(frozen=True)\nclass LTPAAuth:\n    \"\"\"LTPA token-based authentication credentials.\n\n    The session performs an LTPA login at construction time and uses\n    the returned ``LtpaToken2`` cookie for subsequent requests.\n\n    Attributes:\n        username: Username for the LTPA login request.\n        password: Password for the LTPA login request.\n\n    \"\"\"\n\n    username: str\n    password: str\n</code></pre> <p>HTTP Basic authentication credentials.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>Username for HTTP Basic authentication.</p> <code>password</code> <code>str</code> <p>Password for HTTP Basic authentication.</p> Source code in <code>src/pymqrest/auth.py</code> <pre><code>@dataclass(frozen=True)\nclass BasicAuth:\n    \"\"\"HTTP Basic authentication credentials.\n\n    Attributes:\n        username: Username for HTTP Basic authentication.\n        password: Password for HTTP Basic authentication.\n\n    \"\"\"\n\n    username: str\n    password: str\n</code></pre>"},{"location":"api/auth/#choosing-between-ltpa-and-basic-authentication","title":"Choosing between LTPA and Basic authentication","text":"<p>Both LTPA and Basic authentication use a username and password. The key difference is how often those credentials cross the wire.</p> <p>LTPA is the recommended choice for username/password authentication. Credentials are sent once during the <code>/login</code> request; subsequent API calls carry only the LTPA cookie. This reduces credential exposure and is more efficient for sessions that issue many commands. All examples and documentation in this project use LTPA as the default.</p> <p>Use Basic authentication as a fallback when:</p> <ul> <li>The mqweb configuration does not enable the <code>/login</code> endpoint (for   example, minimal container images that only expose the REST API).</li> <li>A reverse proxy or API gateway handles authentication and forwards a   Basic auth header; cookie-based flows may not survive the proxy.</li> <li>Single-command scripts where the login round-trip doubles the request   count for no security benefit.</li> <li>Long-running sessions where LTPA token expiry (typically two hours)   could cause mid-operation failures; pymqrest does not currently   re-authenticate automatically.</li> <li>Local development or CI against a <code>localhost</code> container, where   transport security is not a concern.</li> </ul>"},{"location":"api/auth/#type-alias","title":"Type Alias","text":"<p>Type alias for the supported credential types.</p>"},{"location":"api/commands/","title":"Commands","text":""},{"location":"api/commands/#overview","title":"Overview","text":"<p><code>MQRESTSession</code> provides ~144 command methods, one for each MQSC command verb + qualifier combination. Each method is a thin wrapper that calls the internal command dispatcher with the correct verb and qualifier. Method names follow the pattern <code>&lt;verb&gt;_&lt;qualifier&gt;</code> in lowercase, mapping directly to MQSC commands (e.g. <code>DISPLAY QUEUE</code> becomes <code>display_queue()</code>).</p>"},{"location":"api/commands/#method-signature-pattern","title":"Method signature pattern","text":"<pre><code># DISPLAY commands return a list\nqueues = session.display_queue(name=\"APP.*\")\nqueues = session.display_queue(\n    name=\"APP.*\",\n    response_parameters=[\"current_queue_depth\", \"max_queue_depth\"],\n    where=\"current_queue_depth GT 100\",\n)\n\n# Non-DISPLAY commands return None\nsession.define_qlocal(name=\"MY.QUEUE\", request_parameters={\"max_queue_depth\": 50000})\nsession.alter_channel(name=\"MY.CHANNEL\", request_parameters={\"description\": \"Updated\"})\nsession.delete_queue(name=\"MY.QUEUE\")\n\n# Queue manager singletons return a single dict\nqmgr = session.display_qmgr()\nstatus = session.display_qmstatus()\n</code></pre>"},{"location":"api/commands/#parameters","title":"Parameters","text":"<p>All methods accept these optional parameters:</p> Parameter Description <code>name</code> Object name or wildcard pattern (e.g. <code>\"MY.QUEUE\"</code>, <code>\"APP.*\"</code>). Required for most non-QMGR commands. <code>request_parameters</code> Request attributes as a dict. Mapped from <code>snake_case</code> when mapping is enabled. <code>response_parameters</code> List of attribute names to include in the response. Defaults to <code>[\"all\"]</code>. <code>where</code> Filter expression for DISPLAY commands (e.g. <code>\"current_queue_depth GT 100\"</code>). The keyword is mapped from <code>snake_case</code> when mapping is enabled. <code>map_attributes</code> Override the session-level mapping setting for this single call."},{"location":"api/commands/#return-values","title":"Return values","text":"<ul> <li>DISPLAY commands: <code>list[dict[str, object]]</code> \u2014 one dict per matched object.   An empty list means no objects matched (not an error).</li> <li>Queue manager singletons (<code>display_qmgr</code>, <code>display_qmstatus</code>,   <code>display_cmdserv</code>): <code>dict[str, object] | None</code>.</li> <li>Non-DISPLAY commands: <code>None</code> on success; raises <code>MQRESTCommandError</code>   on failure.</li> </ul>"},{"location":"api/commands/#display-methods","title":"DISPLAY methods","text":"Method MQSC command Qualifier mapping <code>display_apstatus()</code> <code>DISPLAY APSTATUS</code> apstatus <code>display_archive()</code> <code>DISPLAY ARCHIVE</code> archive <code>display_authinfo()</code> <code>DISPLAY AUTHINFO</code> authinfo <code>display_authrec()</code> <code>DISPLAY AUTHREC</code> authrec <code>display_authserv()</code> <code>DISPLAY AUTHSERV</code> authserv <code>display_cfstatus()</code> <code>DISPLAY CFSTATUS</code> cfstatus <code>display_cfstruct()</code> <code>DISPLAY CFSTRUCT</code> cfstruct <code>display_channel()</code> <code>DISPLAY CHANNEL</code> channel <code>display_chinit()</code> <code>DISPLAY CHINIT</code> chinit <code>display_chlauth()</code> <code>DISPLAY CHLAUTH</code> chlauth <code>display_chstatus()</code> <code>DISPLAY CHSTATUS</code> chstatus <code>display_clusqmgr()</code> <code>DISPLAY CLUSQMGR</code> clusqmgr <code>display_cmdserv()</code> <code>DISPLAY CMDSERV</code> cmdserv <code>display_comminfo()</code> <code>DISPLAY COMMINFO</code> comminfo <code>display_conn()</code> <code>DISPLAY CONN</code> conn <code>display_entauth()</code> <code>DISPLAY ENTAUTH</code> entauth <code>display_group()</code> <code>DISPLAY GROUP</code> group <code>display_listener()</code> <code>DISPLAY LISTENER</code> listener <code>display_log()</code> <code>DISPLAY LOG</code> log <code>display_lsstatus()</code> <code>DISPLAY LSSTATUS</code> lsstatus <code>display_maxsmsgs()</code> <code>DISPLAY MAXSMSGS</code> maxsmsgs <code>display_namelist()</code> <code>DISPLAY NAMELIST</code> namelist <code>display_policy()</code> <code>DISPLAY POLICY</code> policy <code>display_process()</code> <code>DISPLAY PROCESS</code> process <code>display_pubsub()</code> <code>DISPLAY PUBSUB</code> pubsub <code>display_qmgr()</code> <code>DISPLAY QMGR</code> qmgr <code>display_qmstatus()</code> <code>DISPLAY QMSTATUS</code> qmgr <code>display_qstatus()</code> <code>DISPLAY QSTATUS</code> queue <code>display_queue()</code> <code>DISPLAY QUEUE</code> queue <code>display_sbstatus()</code> <code>DISPLAY SBSTATUS</code> sbstatus <code>display_security()</code> <code>DISPLAY SECURITY</code> security <code>display_service()</code> <code>DISPLAY SERVICE</code> service <code>display_smds()</code> <code>DISPLAY SMDS</code> smds <code>display_smdsconn()</code> <code>DISPLAY SMDSCONN</code> smdsconn <code>display_stgclass()</code> <code>DISPLAY STGCLASS</code> stgclass <code>display_sub()</code> <code>DISPLAY SUB</code> sub <code>display_svstatus()</code> <code>DISPLAY SVSTATUS</code> svstatus <code>display_tcluster()</code> <code>DISPLAY TCLUSTER</code> tcluster <code>display_thread()</code> <code>DISPLAY THREAD</code> thread <code>display_topic()</code> <code>DISPLAY TOPIC</code> topic <code>display_tpstatus()</code> <code>DISPLAY TPSTATUS</code> tpstatus <code>display_trace()</code> <code>DISPLAY TRACE</code> trace <code>display_usage()</code> <code>DISPLAY USAGE</code> usage"},{"location":"api/commands/#define-methods","title":"DEFINE methods","text":"Method MQSC command Qualifier mapping <code>define_authinfo()</code> <code>DEFINE AUTHINFO</code> authinfo <code>define_buffpool()</code> <code>DEFINE BUFFPOOL</code> buffpool <code>define_cfstruct()</code> <code>DEFINE CFSTRUCT</code> cfstruct <code>define_channel()</code> <code>DEFINE CHANNEL</code> channel <code>define_comminfo()</code> <code>DEFINE COMMINFO</code> comminfo <code>define_listener()</code> <code>DEFINE LISTENER</code> listener <code>define_log()</code> <code>DEFINE LOG</code> log <code>define_maxsmsgs()</code> <code>DEFINE MAXSMSGS</code> maxsmsgs <code>define_namelist()</code> <code>DEFINE NAMELIST</code> namelist <code>define_process()</code> <code>DEFINE PROCESS</code> process <code>define_psid()</code> <code>DEFINE PSID</code> psid <code>define_qalias()</code> <code>DEFINE QALIAS</code> queue <code>define_qlocal()</code> <code>DEFINE QLOCAL</code> queue <code>define_qmodel()</code> <code>DEFINE QMODEL</code> queue <code>define_qremote()</code> <code>DEFINE QREMOTE</code> queue <code>define_service()</code> <code>DEFINE SERVICE</code> service <code>define_stgclass()</code> <code>DEFINE STGCLASS</code> stgclass <code>define_sub()</code> <code>DEFINE SUB</code> sub <code>define_topic()</code> <code>DEFINE TOPIC</code> topic"},{"location":"api/commands/#delete-methods","title":"DELETE methods","text":"Method MQSC command Qualifier mapping <code>delete_authinfo()</code> <code>DELETE AUTHINFO</code> authinfo <code>delete_authrec()</code> <code>DELETE AUTHREC</code> authrec <code>delete_buffpool()</code> <code>DELETE BUFFPOOL</code> buffpool <code>delete_cfstruct()</code> <code>DELETE CFSTRUCT</code> cfstruct <code>delete_channel()</code> <code>DELETE CHANNEL</code> channel <code>delete_comminfo()</code> <code>DELETE COMMINFO</code> comminfo <code>delete_listener()</code> <code>DELETE LISTENER</code> listener <code>delete_namelist()</code> <code>DELETE NAMELIST</code> namelist <code>delete_policy()</code> <code>DELETE POLICY</code> policy <code>delete_process()</code> <code>DELETE PROCESS</code> process <code>delete_psid()</code> <code>DELETE PSID</code> psid <code>delete_queue()</code> <code>DELETE QUEUE</code> queue <code>delete_service()</code> <code>DELETE SERVICE</code> service <code>delete_stgclass()</code> <code>DELETE STGCLASS</code> stgclass <code>delete_sub()</code> <code>DELETE SUB</code> sub <code>delete_topic()</code> <code>DELETE TOPIC</code> topic"},{"location":"api/commands/#alter-methods","title":"ALTER methods","text":"Method MQSC command Qualifier mapping <code>alter_authinfo()</code> <code>ALTER AUTHINFO</code> authinfo <code>alter_buffpool()</code> <code>ALTER BUFFPOOL</code> buffpool <code>alter_cfstruct()</code> <code>ALTER CFSTRUCT</code> cfstruct <code>alter_channel()</code> <code>ALTER CHANNEL</code> channel <code>alter_comminfo()</code> <code>ALTER COMMINFO</code> comminfo <code>alter_listener()</code> <code>ALTER LISTENER</code> listener <code>alter_namelist()</code> <code>ALTER NAMELIST</code> namelist <code>alter_process()</code> <code>ALTER PROCESS</code> process <code>alter_psid()</code> <code>ALTER PSID</code> psid <code>alter_qmgr()</code> <code>ALTER QMGR</code> qmgr <code>alter_security()</code> <code>ALTER SECURITY</code> security <code>alter_service()</code> <code>ALTER SERVICE</code> service <code>alter_smds()</code> <code>ALTER SMDS</code> smds <code>alter_stgclass()</code> <code>ALTER STGCLASS</code> stgclass <code>alter_sub()</code> <code>ALTER SUB</code> sub <code>alter_topic()</code> <code>ALTER TOPIC</code> topic <code>alter_trace()</code> <code>ALTER TRACE</code> trace"},{"location":"api/commands/#set-methods","title":"SET methods","text":"Method MQSC command Qualifier mapping <code>set_archive()</code> <code>SET ARCHIVE</code> archive <code>set_authrec()</code> <code>SET AUTHREC</code> authrec <code>set_chlauth()</code> <code>SET CHLAUTH</code> chlauth <code>set_log()</code> <code>SET LOG</code> log <code>set_policy()</code> <code>SET POLICY</code> policy"},{"location":"api/commands/#start-methods","title":"START methods","text":"Method MQSC command Qualifier mapping <code>start_channel()</code> <code>START CHANNEL</code> channel <code>start_chinit()</code> <code>START CHINIT</code> chinit <code>start_cmdserv()</code> <code>START CMDSERV</code> cmdserv <code>start_listener()</code> <code>START LISTENER</code> listener <code>start_qmgr()</code> <code>START QMGR</code> qmgr <code>start_service()</code> <code>START SERVICE</code> service <code>start_smdsconn()</code> <code>START SMDSCONN</code> smdsconn <code>start_trace()</code> <code>START TRACE</code> trace"},{"location":"api/commands/#stop-methods","title":"STOP methods","text":"Method MQSC command Qualifier mapping <code>stop_channel()</code> <code>STOP CHANNEL</code> channel <code>stop_chinit()</code> <code>STOP CHINIT</code> chinit <code>stop_cmdserv()</code> <code>STOP CMDSERV</code> cmdserv <code>stop_conn()</code> <code>STOP CONN</code> conn <code>stop_listener()</code> <code>STOP LISTENER</code> listener <code>stop_qmgr()</code> <code>STOP QMGR</code> qmgr <code>stop_service()</code> <code>STOP SERVICE</code> service <code>stop_smdsconn()</code> <code>STOP SMDSCONN</code> smdsconn <code>stop_trace()</code> <code>STOP TRACE</code> trace"},{"location":"api/commands/#other-methods","title":"Other methods","text":"Method MQSC command Qualifier mapping <code>archive_log()</code> <code>ARCHIVE LOG</code> log <code>backup_cfstruct()</code> <code>BACKUP CFSTRUCT</code> cfstruct <code>clear_qlocal()</code> <code>CLEAR QLOCAL</code> queue <code>clear_topicstr()</code> <code>CLEAR TOPICSTR</code> topicstr <code>move_qlocal()</code> <code>MOVE QLOCAL</code> queue <code>ping_channel()</code> <code>PING CHANNEL</code> channel <code>ping_qmgr()</code> <code>PING QMGR</code> qmgr <code>purge_channel()</code> <code>PURGE CHANNEL</code> channel <code>recover_bsds()</code> <code>RECOVER BSDS</code> bsds <code>recover_cfstruct()</code> <code>RECOVER CFSTRUCT</code> cfstruct <code>refresh_cluster()</code> <code>REFRESH CLUSTER</code> cluster <code>refresh_qmgr()</code> <code>REFRESH QMGR</code> qmgr <code>refresh_security()</code> <code>REFRESH SECURITY</code> security <code>reset_cfstruct()</code> <code>RESET CFSTRUCT</code> cfstruct <code>reset_channel()</code> <code>RESET CHANNEL</code> channel <code>reset_cluster()</code> <code>RESET CLUSTER</code> cluster <code>reset_qmgr()</code> <code>RESET QMGR</code> qmgr <code>reset_qstats()</code> <code>RESET QSTATS</code> queue <code>reset_smds()</code> <code>RESET SMDS</code> smds <code>reset_tpipe()</code> <code>RESET TPIPE</code> tpipe <code>resolve_channel()</code> <code>RESOLVE CHANNEL</code> channel <code>resolve_indoubt()</code> <code>RESOLVE INDOUBT</code> indoubt <code>resume_qmgr()</code> <code>RESUME QMGR</code> qmgr <code>rverify_security()</code> <code>RVERIFY SECURITY</code> security <code>suspend_qmgr()</code> <code>SUSPEND QMGR</code> qmgr <p>Note</p> <p>The full list of command methods is generated from the mapping data. See the Qualifier Mapping Reference for per-qualifier details including attribute names and value mappings for each object type.</p>"},{"location":"api/ensure/","title":"Ensure","text":""},{"location":"api/ensure/#overview","title":"Overview","text":"<p>The ensure module provides the return types for the 16 idempotent ensure methods on <code>MQRESTSession</code>. These methods implement a declarative upsert pattern: DEFINE if the object does not exist, ALTER only attributes that differ, or no-op if the object already matches the desired state.</p>"},{"location":"api/ensure/#ensureaction","title":"EnsureAction","text":"<p>An enum indicating the action taken by an ensure method:</p> <pre><code>class EnsureAction(Enum):\n    CREATED    = \"created\"     # Object did not exist; DEFINE was issued\n    UPDATED    = \"updated\"     # Object existed but attributes differed; ALTER was issued\n    UNCHANGED  = \"unchanged\"   # Object already matched the desired state\n</code></pre>"},{"location":"api/ensure/#ensureresult","title":"EnsureResult","text":"<p>A named tuple containing the action taken and the list of attribute names that triggered the change (if any):</p> <pre><code>class EnsureResult(NamedTuple):\n    action: EnsureAction       # What happened\n    changed: list[str]         # Attribute names that differed (empty for CREATED/UNCHANGED)\n</code></pre> Attribute Type Description <code>action</code> <code>EnsureAction</code> What happened: <code>CREATED</code>, <code>UPDATED</code>, or <code>UNCHANGED</code> <code>changed</code> <code>list[str]</code> Attribute names that triggered an ALTER (in the caller's namespace)"},{"location":"api/ensure/#usage","title":"Usage","text":"<pre><code>result = session.ensure_qlocal(\"MY.QUEUE\",\n    request_parameters={\"max_queue_depth\": 50000, \"description\": \"App queue\"})\n\nmatch result.action:\n    case EnsureAction.CREATED:\n        print(\"Queue created\")\n    case EnsureAction.UPDATED:\n        print(f\"Changed: {result.changed}\")\n    case EnsureAction.UNCHANGED:\n        print(\"Already correct\")\n</code></pre> <p>See Ensure Methods for the full conceptual overview, comparison logic, and the complete list of available ensure methods.</p>"},{"location":"api/ensure/#api-reference","title":"API reference","text":"<p>               Bases: <code>Enum</code></p> <p>Action taken by an ensure operation.</p> <p>Attributes:</p> Name Type Description <code>CREATED</code> <p>The object did not exist and was defined.</p> <code>UPDATED</code> <p>The object existed but attributes differed and were altered.</p> <code>UNCHANGED</code> <p>The object existed and all specified attributes already matched.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>class EnsureAction(enum.Enum):\n    \"\"\"Action taken by an ensure operation.\n\n    Attributes:\n        CREATED: The object did not exist and was defined.\n        UPDATED: The object existed but attributes differed and were altered.\n        UNCHANGED: The object existed and all specified attributes already matched.\n\n    \"\"\"\n\n    CREATED = \"created\"\n    UPDATED = \"updated\"\n    UNCHANGED = \"unchanged\"\n</code></pre> <p>Result of an ensure operation.</p> <p>Attributes:</p> Name Type Description <code>action</code> <code>EnsureAction</code> <p>The :class:<code>EnsureAction</code> indicating what happened.</p> <code>changed</code> <code>tuple[str, ...]</code> <p>Attribute names that triggered the ALTER, in the caller's namespace (snake_case when mapping is enabled, MQSC when disabled).  Empty for CREATED and UNCHANGED actions.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>@dataclass(frozen=True)\nclass EnsureResult:\n    \"\"\"Result of an ensure operation.\n\n    Attributes:\n        action: The :class:`EnsureAction` indicating what happened.\n        changed: Attribute names that triggered the ALTER, in the caller's\n            namespace (snake_case when mapping is enabled, MQSC when\n            disabled).  Empty for CREATED and UNCHANGED actions.\n\n    \"\"\"\n\n    action: EnsureAction\n    changed: tuple[str, ...] = ()\n</code></pre> <p>Mixin providing idempotent ensure methods for MQ objects.</p> <p>Each <code>ensure_*</code> method implements a declarative upsert pattern: DEFINE when the object does not exist, ALTER only when specified attributes differ, and no-op when they already match \u2014 preserving <code>ALTDATE</code>/<code>ALTTIME</code> for unchanged objects.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>class MQRESTEnsureMixin:\n    \"\"\"Mixin providing idempotent ensure methods for MQ objects.\n\n    Each ``ensure_*`` method implements a declarative upsert pattern:\n    DEFINE when the object does not exist, ALTER only when specified\n    attributes differ, and no-op when they already match \u2014 preserving\n    ``ALTDATE``/``ALTTIME`` for unchanged objects.\n    \"\"\"\n\n    def _mqsc_command(  # noqa: PLR0913\n        self,\n        *,\n        command: str,\n        mqsc_qualifier: str,\n        name: str | None,\n        request_parameters: Mapping[str, object] | None,\n        response_parameters: Sequence[str] | None,\n        where: str | None = None,\n    ) -&gt; list[dict[str, object]]:\n        raise NotImplementedError  # pragma: no cover\n\n    def _ensure_object(\n        self,\n        *,\n        name: str,\n        request_parameters: Mapping[str, object] | None,\n        display_qualifier: str,\n        define_qualifier: str,\n        alter_qualifier: str,\n    ) -&gt; EnsureResult:\n        \"\"\"Core ensure logic shared by all ``ensure_*`` methods.\n\n        Args:\n            name: MQ object name.\n            request_parameters: Desired attributes to assert/set.\n            display_qualifier: MQSC qualifier for the DISPLAY command.\n            define_qualifier: MQSC qualifier for the DEFINE command.\n            alter_qualifier: MQSC qualifier for the ALTER command.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        try:\n            current_objects = self._mqsc_command(\n                command=\"DISPLAY\",\n                mqsc_qualifier=display_qualifier,\n                name=name,\n                request_parameters=None,\n                response_parameters=[\"all\"],\n            )\n        except MQRESTCommandError:\n            current_objects = []\n\n        params = dict(request_parameters) if request_parameters else {}\n\n        if not current_objects:\n            self._mqsc_command(\n                command=\"DEFINE\",\n                mqsc_qualifier=define_qualifier,\n                name=name,\n                request_parameters=params or None,\n                response_parameters=None,\n            )\n            return EnsureResult(EnsureAction.CREATED)\n\n        if not params:\n            return EnsureResult(EnsureAction.UNCHANGED)\n\n        current = current_objects[0]\n        changed: dict[str, object] = {}\n        for key, desired_value in params.items():\n            current_value = current.get(key)\n            if not _values_match(desired_value, current_value):\n                changed[key] = desired_value\n\n        if not changed:\n            return EnsureResult(EnsureAction.UNCHANGED)\n\n        self._mqsc_command(\n            command=\"ALTER\",\n            mqsc_qualifier=alter_qualifier,\n            name=name,\n            request_parameters=changed,\n            response_parameters=None,\n        )\n        return EnsureResult(EnsureAction.UPDATED, changed=tuple(changed.keys()))\n\n    def ensure_qmgr(\n        self,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure the queue manager has the specified attributes.\n\n        Unlike other ensure methods, the queue manager always exists and\n        cannot be defined or deleted.  This method compares the requested\n        attributes against the current state and issues ``ALTER QMGR``\n        only when values differ.  Returns ``UPDATED`` or ``UNCHANGED``\n        (never ``CREATED``).\n\n        Args:\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        params = dict(request_parameters) if request_parameters else {}\n        if not params:\n            return EnsureResult(EnsureAction.UNCHANGED)\n\n        current_objects = self._mqsc_command(\n            command=\"DISPLAY\",\n            mqsc_qualifier=\"QMGR\",\n            name=None,\n            request_parameters=None,\n            response_parameters=[\"all\"],\n        )\n\n        current = current_objects[0] if current_objects else {}\n        changed: dict[str, object] = {}\n        for key, desired_value in params.items():\n            current_value = current.get(key)\n            if not _values_match(desired_value, current_value):\n                changed[key] = desired_value\n\n        if not changed:\n            return EnsureResult(EnsureAction.UNCHANGED)\n\n        self._mqsc_command(\n            command=\"ALTER\",\n            mqsc_qualifier=\"QMGR\",\n            name=None,\n            request_parameters=changed,\n            response_parameters=None,\n        )\n        return EnsureResult(EnsureAction.UPDATED, changed=tuple(changed.keys()))\n\n    def ensure_qlocal(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a local queue exists with the specified attributes.\n\n        Args:\n            name: Queue name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"QUEUE\",\n            define_qualifier=\"QLOCAL\",\n            alter_qualifier=\"QLOCAL\",\n        )\n\n    def ensure_qremote(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a remote queue exists with the specified attributes.\n\n        Args:\n            name: Queue name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"QUEUE\",\n            define_qualifier=\"QREMOTE\",\n            alter_qualifier=\"QREMOTE\",\n        )\n\n    def ensure_qalias(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure an alias queue exists with the specified attributes.\n\n        Args:\n            name: Queue name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"QUEUE\",\n            define_qualifier=\"QALIAS\",\n            alter_qualifier=\"QALIAS\",\n        )\n\n    def ensure_qmodel(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a model queue exists with the specified attributes.\n\n        Args:\n            name: Queue name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"QUEUE\",\n            define_qualifier=\"QMODEL\",\n            alter_qualifier=\"QMODEL\",\n        )\n\n    def ensure_channel(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a channel exists with the specified attributes.\n\n        Args:\n            name: Channel name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"CHANNEL\",\n            define_qualifier=\"CHANNEL\",\n            alter_qualifier=\"CHANNEL\",\n        )\n\n    def ensure_authinfo(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure an authentication information object exists with the specified attributes.\n\n        Args:\n            name: Authentication information object name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"AUTHINFO\",\n            define_qualifier=\"AUTHINFO\",\n            alter_qualifier=\"AUTHINFO\",\n        )\n\n    def ensure_listener(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a listener exists with the specified attributes.\n\n        Args:\n            name: Listener name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"LISTENER\",\n            define_qualifier=\"LISTENER\",\n            alter_qualifier=\"LISTENER\",\n        )\n\n    def ensure_namelist(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a namelist exists with the specified attributes.\n\n        Args:\n            name: Namelist name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"NAMELIST\",\n            define_qualifier=\"NAMELIST\",\n            alter_qualifier=\"NAMELIST\",\n        )\n\n    def ensure_process(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a process exists with the specified attributes.\n\n        Args:\n            name: Process name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"PROCESS\",\n            define_qualifier=\"PROCESS\",\n            alter_qualifier=\"PROCESS\",\n        )\n\n    def ensure_service(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a service exists with the specified attributes.\n\n        Args:\n            name: Service name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"SERVICE\",\n            define_qualifier=\"SERVICE\",\n            alter_qualifier=\"SERVICE\",\n        )\n\n    def ensure_topic(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a topic exists with the specified attributes.\n\n        Args:\n            name: Topic name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"TOPIC\",\n            define_qualifier=\"TOPIC\",\n            alter_qualifier=\"TOPIC\",\n        )\n\n    def ensure_sub(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a subscription exists with the specified attributes.\n\n        Args:\n            name: Subscription name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"SUB\",\n            define_qualifier=\"SUB\",\n            alter_qualifier=\"SUB\",\n        )\n\n    def ensure_stgclass(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a storage class exists with the specified attributes.\n\n        Args:\n            name: Storage class name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"STGCLASS\",\n            define_qualifier=\"STGCLASS\",\n            alter_qualifier=\"STGCLASS\",\n        )\n\n    def ensure_comminfo(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a communication information object exists with the specified attributes.\n\n        Args:\n            name: Communication information object name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"COMMINFO\",\n            define_qualifier=\"COMMINFO\",\n            alter_qualifier=\"COMMINFO\",\n        )\n\n    def ensure_cfstruct(\n        self,\n        name: str,\n        request_parameters: Mapping[str, object] | None = None,\n    ) -&gt; EnsureResult:\n        \"\"\"Ensure a CF structure exists with the specified attributes.\n\n        Args:\n            name: CF structure name.\n            request_parameters: Desired attributes to assert/set.\n\n        Returns:\n            The :class:`EnsureResult` indicating what action was taken.\n\n        \"\"\"\n        return self._ensure_object(\n            name=name,\n            request_parameters=request_parameters,\n            display_qualifier=\"CFSTRUCT\",\n            define_qualifier=\"CFSTRUCT\",\n            alter_qualifier=\"CFSTRUCT\",\n        )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.EnsureAction.CREATED","title":"<code>CREATED = 'created'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/ensure/#pymqrest.ensure.EnsureAction.UPDATED","title":"<code>UPDATED = 'updated'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/ensure/#pymqrest.ensure.EnsureAction.UNCHANGED","title":"<code>UNCHANGED = 'unchanged'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/ensure/#pymqrest.ensure.EnsureResult.action","title":"<code>action</code>  <code>instance-attribute</code>","text":""},{"location":"api/ensure/#pymqrest.ensure.EnsureResult.changed","title":"<code>changed = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/ensure/#pymqrest.ensure.EnsureResult.__init__","title":"<code>__init__(action, changed=())</code>","text":""},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin._mqsc_command","title":"<code>_mqsc_command(*, command, mqsc_qualifier, name, request_parameters, response_parameters, where=None)</code>","text":"Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def _mqsc_command(  # noqa: PLR0913\n    self,\n    *,\n    command: str,\n    mqsc_qualifier: str,\n    name: str | None,\n    request_parameters: Mapping[str, object] | None,\n    response_parameters: Sequence[str] | None,\n    where: str | None = None,\n) -&gt; list[dict[str, object]]:\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin._ensure_object","title":"<code>_ensure_object(*, name, request_parameters, display_qualifier, define_qualifier, alter_qualifier)</code>","text":"<p>Core ensure logic shared by all <code>ensure_*</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>MQ object name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> required <code>display_qualifier</code> <code>str</code> <p>MQSC qualifier for the DISPLAY command.</p> required <code>define_qualifier</code> <code>str</code> <p>MQSC qualifier for the DEFINE command.</p> required <code>alter_qualifier</code> <code>str</code> <p>MQSC qualifier for the ALTER command.</p> required <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def _ensure_object(\n    self,\n    *,\n    name: str,\n    request_parameters: Mapping[str, object] | None,\n    display_qualifier: str,\n    define_qualifier: str,\n    alter_qualifier: str,\n) -&gt; EnsureResult:\n    \"\"\"Core ensure logic shared by all ``ensure_*`` methods.\n\n    Args:\n        name: MQ object name.\n        request_parameters: Desired attributes to assert/set.\n        display_qualifier: MQSC qualifier for the DISPLAY command.\n        define_qualifier: MQSC qualifier for the DEFINE command.\n        alter_qualifier: MQSC qualifier for the ALTER command.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    try:\n        current_objects = self._mqsc_command(\n            command=\"DISPLAY\",\n            mqsc_qualifier=display_qualifier,\n            name=name,\n            request_parameters=None,\n            response_parameters=[\"all\"],\n        )\n    except MQRESTCommandError:\n        current_objects = []\n\n    params = dict(request_parameters) if request_parameters else {}\n\n    if not current_objects:\n        self._mqsc_command(\n            command=\"DEFINE\",\n            mqsc_qualifier=define_qualifier,\n            name=name,\n            request_parameters=params or None,\n            response_parameters=None,\n        )\n        return EnsureResult(EnsureAction.CREATED)\n\n    if not params:\n        return EnsureResult(EnsureAction.UNCHANGED)\n\n    current = current_objects[0]\n    changed: dict[str, object] = {}\n    for key, desired_value in params.items():\n        current_value = current.get(key)\n        if not _values_match(desired_value, current_value):\n            changed[key] = desired_value\n\n    if not changed:\n        return EnsureResult(EnsureAction.UNCHANGED)\n\n    self._mqsc_command(\n        command=\"ALTER\",\n        mqsc_qualifier=alter_qualifier,\n        name=name,\n        request_parameters=changed,\n        response_parameters=None,\n    )\n    return EnsureResult(EnsureAction.UPDATED, changed=tuple(changed.keys()))\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_qmgr","title":"<code>ensure_qmgr(request_parameters=None)</code>","text":"<p>Ensure the queue manager has the specified attributes.</p> <p>Unlike other ensure methods, the queue manager always exists and cannot be defined or deleted.  This method compares the requested attributes against the current state and issues <code>ALTER QMGR</code> only when values differ.  Returns <code>UPDATED</code> or <code>UNCHANGED</code> (never <code>CREATED</code>).</p> <p>Parameters:</p> Name Type Description Default <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_qmgr(\n    self,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure the queue manager has the specified attributes.\n\n    Unlike other ensure methods, the queue manager always exists and\n    cannot be defined or deleted.  This method compares the requested\n    attributes against the current state and issues ``ALTER QMGR``\n    only when values differ.  Returns ``UPDATED`` or ``UNCHANGED``\n    (never ``CREATED``).\n\n    Args:\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    params = dict(request_parameters) if request_parameters else {}\n    if not params:\n        return EnsureResult(EnsureAction.UNCHANGED)\n\n    current_objects = self._mqsc_command(\n        command=\"DISPLAY\",\n        mqsc_qualifier=\"QMGR\",\n        name=None,\n        request_parameters=None,\n        response_parameters=[\"all\"],\n    )\n\n    current = current_objects[0] if current_objects else {}\n    changed: dict[str, object] = {}\n    for key, desired_value in params.items():\n        current_value = current.get(key)\n        if not _values_match(desired_value, current_value):\n            changed[key] = desired_value\n\n    if not changed:\n        return EnsureResult(EnsureAction.UNCHANGED)\n\n    self._mqsc_command(\n        command=\"ALTER\",\n        mqsc_qualifier=\"QMGR\",\n        name=None,\n        request_parameters=changed,\n        response_parameters=None,\n    )\n    return EnsureResult(EnsureAction.UPDATED, changed=tuple(changed.keys()))\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_qlocal","title":"<code>ensure_qlocal(name, request_parameters=None)</code>","text":"<p>Ensure a local queue exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Queue name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_qlocal(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a local queue exists with the specified attributes.\n\n    Args:\n        name: Queue name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"QUEUE\",\n        define_qualifier=\"QLOCAL\",\n        alter_qualifier=\"QLOCAL\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_qremote","title":"<code>ensure_qremote(name, request_parameters=None)</code>","text":"<p>Ensure a remote queue exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Queue name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_qremote(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a remote queue exists with the specified attributes.\n\n    Args:\n        name: Queue name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"QUEUE\",\n        define_qualifier=\"QREMOTE\",\n        alter_qualifier=\"QREMOTE\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_qalias","title":"<code>ensure_qalias(name, request_parameters=None)</code>","text":"<p>Ensure an alias queue exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Queue name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_qalias(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure an alias queue exists with the specified attributes.\n\n    Args:\n        name: Queue name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"QUEUE\",\n        define_qualifier=\"QALIAS\",\n        alter_qualifier=\"QALIAS\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_qmodel","title":"<code>ensure_qmodel(name, request_parameters=None)</code>","text":"<p>Ensure a model queue exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Queue name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_qmodel(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a model queue exists with the specified attributes.\n\n    Args:\n        name: Queue name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"QUEUE\",\n        define_qualifier=\"QMODEL\",\n        alter_qualifier=\"QMODEL\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_channel","title":"<code>ensure_channel(name, request_parameters=None)</code>","text":"<p>Ensure a channel exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Channel name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_channel(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a channel exists with the specified attributes.\n\n    Args:\n        name: Channel name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"CHANNEL\",\n        define_qualifier=\"CHANNEL\",\n        alter_qualifier=\"CHANNEL\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_authinfo","title":"<code>ensure_authinfo(name, request_parameters=None)</code>","text":"<p>Ensure an authentication information object exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Authentication information object name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_authinfo(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure an authentication information object exists with the specified attributes.\n\n    Args:\n        name: Authentication information object name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"AUTHINFO\",\n        define_qualifier=\"AUTHINFO\",\n        alter_qualifier=\"AUTHINFO\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_listener","title":"<code>ensure_listener(name, request_parameters=None)</code>","text":"<p>Ensure a listener exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Listener name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_listener(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a listener exists with the specified attributes.\n\n    Args:\n        name: Listener name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"LISTENER\",\n        define_qualifier=\"LISTENER\",\n        alter_qualifier=\"LISTENER\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_namelist","title":"<code>ensure_namelist(name, request_parameters=None)</code>","text":"<p>Ensure a namelist exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Namelist name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_namelist(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a namelist exists with the specified attributes.\n\n    Args:\n        name: Namelist name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"NAMELIST\",\n        define_qualifier=\"NAMELIST\",\n        alter_qualifier=\"NAMELIST\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_process","title":"<code>ensure_process(name, request_parameters=None)</code>","text":"<p>Ensure a process exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Process name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_process(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a process exists with the specified attributes.\n\n    Args:\n        name: Process name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"PROCESS\",\n        define_qualifier=\"PROCESS\",\n        alter_qualifier=\"PROCESS\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_service","title":"<code>ensure_service(name, request_parameters=None)</code>","text":"<p>Ensure a service exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Service name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_service(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a service exists with the specified attributes.\n\n    Args:\n        name: Service name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"SERVICE\",\n        define_qualifier=\"SERVICE\",\n        alter_qualifier=\"SERVICE\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_topic","title":"<code>ensure_topic(name, request_parameters=None)</code>","text":"<p>Ensure a topic exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Topic name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_topic(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a topic exists with the specified attributes.\n\n    Args:\n        name: Topic name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"TOPIC\",\n        define_qualifier=\"TOPIC\",\n        alter_qualifier=\"TOPIC\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_sub","title":"<code>ensure_sub(name, request_parameters=None)</code>","text":"<p>Ensure a subscription exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Subscription name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_sub(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a subscription exists with the specified attributes.\n\n    Args:\n        name: Subscription name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"SUB\",\n        define_qualifier=\"SUB\",\n        alter_qualifier=\"SUB\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_stgclass","title":"<code>ensure_stgclass(name, request_parameters=None)</code>","text":"<p>Ensure a storage class exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Storage class name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_stgclass(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a storage class exists with the specified attributes.\n\n    Args:\n        name: Storage class name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"STGCLASS\",\n        define_qualifier=\"STGCLASS\",\n        alter_qualifier=\"STGCLASS\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_comminfo","title":"<code>ensure_comminfo(name, request_parameters=None)</code>","text":"<p>Ensure a communication information object exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Communication information object name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_comminfo(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a communication information object exists with the specified attributes.\n\n    Args:\n        name: Communication information object name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"COMMINFO\",\n        define_qualifier=\"COMMINFO\",\n        alter_qualifier=\"COMMINFO\",\n    )\n</code></pre>"},{"location":"api/ensure/#pymqrest.ensure.MQRESTEnsureMixin.ensure_cfstruct","title":"<code>ensure_cfstruct(name, request_parameters=None)</code>","text":"<p>Ensure a CF structure exists with the specified attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>CF structure name.</p> required <code>request_parameters</code> <code>Mapping[str, object] | None</code> <p>Desired attributes to assert/set.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>The</code> <code>EnsureResult</code> <p>class:<code>EnsureResult</code> indicating what action was taken.</p> Source code in <code>src/pymqrest/ensure.py</code> <pre><code>def ensure_cfstruct(\n    self,\n    name: str,\n    request_parameters: Mapping[str, object] | None = None,\n) -&gt; EnsureResult:\n    \"\"\"Ensure a CF structure exists with the specified attributes.\n\n    Args:\n        name: CF structure name.\n        request_parameters: Desired attributes to assert/set.\n\n    Returns:\n        The :class:`EnsureResult` indicating what action was taken.\n\n    \"\"\"\n    return self._ensure_object(\n        name=name,\n        request_parameters=request_parameters,\n        display_qualifier=\"CFSTRUCT\",\n        define_qualifier=\"CFSTRUCT\",\n        alter_qualifier=\"CFSTRUCT\",\n    )\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>All exceptions inherit from <code>MQRESTError</code>.</p> <pre><code>Exception\n\u2514\u2500\u2500 MQRESTError\n    \u251c\u2500\u2500 MQRESTAuthError        \u2014 authentication failures\n    \u251c\u2500\u2500 MQRESTTransportError   \u2014 network/connection failures\n    \u251c\u2500\u2500 MQRESTResponseError    \u2014 malformed responses\n    \u251c\u2500\u2500 MQRESTCommandError     \u2014 MQSC command failures\n    \u2514\u2500\u2500 MQRESTTimeoutError     \u2014 sync operation timeouts\n</code></pre>"},{"location":"api/exceptions/#mqresterror","title":"MQRESTError","text":"<p>The base exception class. All library exceptions inherit from this class.</p> <p>               Bases: <code>Exception</code></p> <p>Base error for all MQ REST session failures.</p> <p>All pymqrest exceptions inherit from this class, so <code>except MQRESTError</code> catches every error raised by the library.</p> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>class MQRESTError(Exception):\n    \"\"\"Base error for all MQ REST session failures.\n\n    All pymqrest exceptions inherit from this class, so\n    ``except MQRESTError`` catches every error raised by the library.\n    \"\"\"\n</code></pre>"},{"location":"api/exceptions/#mqresttransporterror","title":"MQRESTTransportError","text":"<p>Thrown when the HTTP request fails at the network level \u2014 connection refused, DNS resolution failure, TLS handshake error, etc.</p> <pre><code>from pymqrest.exceptions import MQRESTTransportError\n\ntry:\n    session.display_queue(\"MY.QUEUE\")\nexcept MQRESTTransportError as err:\n    print(f\"Cannot reach MQ: {err}\")\n    print(f\"Cause: {err.__cause__}\")\n</code></pre> <p>               Bases: <code>MQRESTError</code></p> <p>Raised when the transport fails to reach the MQ REST endpoint.</p> <p>This typically indicates a network-level problem such as a connection refusal, DNS failure, or TLS handshake error.</p> <p>Attributes:</p> Name Type Description <code>url</code> <p>The endpoint URL that could not be reached.</p> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>class MQRESTTransportError(MQRESTError):\n    \"\"\"Raised when the transport fails to reach the MQ REST endpoint.\n\n    This typically indicates a network-level problem such as a connection\n    refusal, DNS failure, or TLS handshake error.\n\n    Attributes:\n        url: The endpoint URL that could not be reached.\n\n    \"\"\"\n\n    def __init__(self, message: str, *, url: str) -&gt; None:\n        \"\"\"Initialize with the failing endpoint URL.\n\n        Args:\n            message: Human-readable error description.\n            url: The MQ REST endpoint URL that the transport tried to reach.\n\n        \"\"\"\n        super().__init__(message)\n        self.url = url\n</code></pre>"},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTTransportError.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTTransportError.__init__","title":"<code>__init__(message, *, url)</code>","text":"<p>Initialize with the failing endpoint URL.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error description.</p> required <code>url</code> <code>str</code> <p>The MQ REST endpoint URL that the transport tried to reach.</p> required Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>def __init__(self, message: str, *, url: str) -&gt; None:\n    \"\"\"Initialize with the failing endpoint URL.\n\n    Args:\n        message: Human-readable error description.\n        url: The MQ REST endpoint URL that the transport tried to reach.\n\n    \"\"\"\n    super().__init__(message)\n    self.url = url\n</code></pre>"},{"location":"api/exceptions/#mqrestresponseerror","title":"MQRESTResponseError","text":"<p>Thrown when the HTTP request succeeds but the response cannot be parsed \u2014 invalid JSON, missing expected fields, unexpected response structure.</p> <p>               Bases: <code>MQRESTError</code></p> <p>Raised when the MQ REST response is malformed or unexpected.</p> <p>This indicates the server returned a response that could not be parsed as valid JSON or did not conform to the expected <code>runCommandJSON</code> response structure.</p> <p>Attributes:</p> Name Type Description <code>response_text</code> <p>The raw response body, if available.</p> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>class MQRESTResponseError(MQRESTError):\n    \"\"\"Raised when the MQ REST response is malformed or unexpected.\n\n    This indicates the server returned a response that could not be\n    parsed as valid JSON or did not conform to the expected\n    ``runCommandJSON`` response structure.\n\n    Attributes:\n        response_text: The raw response body, if available.\n\n    \"\"\"\n\n    def __init__(self, message: str, *, response_text: str | None = None) -&gt; None:\n        \"\"\"Initialize with optional response payload text.\n\n        Args:\n            message: Human-readable error description.\n            response_text: The raw HTTP response body, or ``None`` if\n                unavailable.\n\n        \"\"\"\n        super().__init__(message)\n        self.response_text = response_text\n</code></pre>"},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTResponseError.response_text","title":"<code>response_text = response_text</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTResponseError.__init__","title":"<code>__init__(message, *, response_text=None)</code>","text":"<p>Initialize with optional response payload text.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error description.</p> required <code>response_text</code> <code>str | None</code> <p>The raw HTTP response body, or <code>None</code> if unavailable.</p> <code>None</code> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>def __init__(self, message: str, *, response_text: str | None = None) -&gt; None:\n    \"\"\"Initialize with optional response payload text.\n\n    Args:\n        message: Human-readable error description.\n        response_text: The raw HTTP response body, or ``None`` if\n            unavailable.\n\n    \"\"\"\n    super().__init__(message)\n    self.response_text = response_text\n</code></pre>"},{"location":"api/exceptions/#mqrestautherror","title":"MQRESTAuthError","text":"<p>Thrown when authentication or authorization fails \u2014 invalid credentials, expired tokens, insufficient permissions (HTTP 401/403).</p> <pre><code>from pymqrest.exceptions import MQRESTAuthError\n\ntry:\n    session.display_qmgr()\nexcept MQRESTAuthError as err:\n    print(f\"Authentication failed: {err}\")\n</code></pre> <p>               Bases: <code>MQRESTError</code></p> <p>Raised when authentication with the MQ REST API fails.</p> <p>This indicates the server rejected credentials or a required authentication token could not be obtained.</p> <p>Attributes:</p> Name Type Description <code>url</code> <p>The endpoint URL where authentication failed.</p> <code>status_code</code> <p>The HTTP status code, or <code>None</code> if unavailable.</p> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>class MQRESTAuthError(MQRESTError):\n    \"\"\"Raised when authentication with the MQ REST API fails.\n\n    This indicates the server rejected credentials or a required\n    authentication token could not be obtained.\n\n    Attributes:\n        url: The endpoint URL where authentication failed.\n        status_code: The HTTP status code, or ``None`` if unavailable.\n\n    \"\"\"\n\n    def __init__(self, message: str, *, url: str, status_code: int | None = None) -&gt; None:\n        \"\"\"Initialize with the failing endpoint URL and optional status code.\n\n        Args:\n            message: Human-readable error description.\n            url: The MQ REST endpoint URL where authentication failed.\n            status_code: The HTTP status code from the response.\n\n        \"\"\"\n        super().__init__(message)\n        self.url = url\n        self.status_code = status_code\n</code></pre>"},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTAuthError.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTAuthError.status_code","title":"<code>status_code = status_code</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTAuthError.__init__","title":"<code>__init__(message, *, url, status_code=None)</code>","text":"<p>Initialize with the failing endpoint URL and optional status code.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error description.</p> required <code>url</code> <code>str</code> <p>The MQ REST endpoint URL where authentication failed.</p> required <code>status_code</code> <code>int | None</code> <p>The HTTP status code from the response.</p> <code>None</code> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>def __init__(self, message: str, *, url: str, status_code: int | None = None) -&gt; None:\n    \"\"\"Initialize with the failing endpoint URL and optional status code.\n\n    Args:\n        message: Human-readable error description.\n        url: The MQ REST endpoint URL where authentication failed.\n        status_code: The HTTP status code from the response.\n\n    \"\"\"\n    super().__init__(message)\n    self.url = url\n    self.status_code = status_code\n</code></pre>"},{"location":"api/exceptions/#mqrestcommanderror","title":"MQRESTCommandError","text":"<p>Thrown when the MQSC command returns a non-zero completion or reason code. This is the most commonly caught exception \u2014 it indicates the command was delivered to MQ but the queue manager rejected it.</p> <pre><code>from pymqrest.exceptions import MQRESTCommandError\n\ntry:\n    session.define_qlocal(\"MY.QUEUE\")\nexcept MQRESTCommandError as err:\n    print(f\"Command failed: {err}\")\n    print(f\"Response payload: {err.payload}\")\n</code></pre> <p>Note</p> <p>For DISPLAY commands with no matches, MQ returns reason code 2085 (MQRC_UNKNOWN_OBJECT_NAME). The library treats this as an empty list rather than raising an exception.</p> <p>               Bases: <code>MQRESTError</code></p> <p>Raised when the MQ REST response indicates MQSC command failure.</p> <p>The server returned a valid JSON response, but the completion or reason codes indicate the MQSC command did not succeed.</p> <p>Attributes:</p> Name Type Description <code>payload</code> <p>The full JSON response payload as a dict.</p> <code>status_code</code> <p>The HTTP status code, or <code>None</code> if unavailable.</p> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>class MQRESTCommandError(MQRESTError):\n    \"\"\"Raised when the MQ REST response indicates MQSC command failure.\n\n    The server returned a valid JSON response, but the completion or\n    reason codes indicate the MQSC command did not succeed.\n\n    Attributes:\n        payload: The full JSON response payload as a dict.\n        status_code: The HTTP status code, or ``None`` if unavailable.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        payload: Mapping[str, object],\n        status_code: int | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize with response payload and HTTP status.\n\n        Args:\n            message: Human-readable error description including\n                completion and reason codes.\n            payload: The full JSON response payload from the MQ REST API.\n            status_code: The HTTP status code from the response.\n\n        \"\"\"\n        super().__init__(message)\n        self.payload = dict(payload)\n        self.status_code = status_code\n</code></pre>"},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTCommandError.payload","title":"<code>payload = dict(payload)</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTCommandError.status_code","title":"<code>status_code = status_code</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTCommandError.__init__","title":"<code>__init__(message, *, payload, status_code=None)</code>","text":"<p>Initialize with response payload and HTTP status.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error description including completion and reason codes.</p> required <code>payload</code> <code>Mapping[str, object]</code> <p>The full JSON response payload from the MQ REST API.</p> required <code>status_code</code> <code>int | None</code> <p>The HTTP status code from the response.</p> <code>None</code> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    payload: Mapping[str, object],\n    status_code: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize with response payload and HTTP status.\n\n    Args:\n        message: Human-readable error description including\n            completion and reason codes.\n        payload: The full JSON response payload from the MQ REST API.\n        status_code: The HTTP status code from the response.\n\n    \"\"\"\n    super().__init__(message)\n    self.payload = dict(payload)\n    self.status_code = status_code\n</code></pre>"},{"location":"api/exceptions/#mqresttimeouterror","title":"MQRESTTimeoutError","text":"<p>Thrown when a polling operation exceeds the configured timeout duration.</p> <pre><code>from pymqrest.exceptions import MQRESTTimeoutError\n\ntry:\n    session.start_channel_sync(\"BROKEN.CHL\")\nexcept MQRESTTimeoutError as err:\n    print(f\"Object: {err.name}\")\n    print(f\"Operation: {err.operation}\")\n    print(f\"Elapsed: {err.elapsed:.1f}s\")\n</code></pre> <p>               Bases: <code>MQRESTError</code></p> <p>Raised when a synchronous operation exceeds its timeout.</p> <p>This indicates that a start, stop, or restart operation did not reach the expected state within the configured timeout period.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>The MQ object name that timed out.</p> <code>operation</code> <p>A description of the operation that timed out (e.g. <code>\"start\"</code>, <code>\"stop\"</code>).</p> <code>elapsed</code> <p>The elapsed wall-clock seconds before the timeout.</p> Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>class MQRESTTimeoutError(MQRESTError):\n    \"\"\"Raised when a synchronous operation exceeds its timeout.\n\n    This indicates that a start, stop, or restart operation did not\n    reach the expected state within the configured timeout period.\n\n    Attributes:\n        name: The MQ object name that timed out.\n        operation: A description of the operation that timed out\n            (e.g. ``\"start\"``, ``\"stop\"``).\n        elapsed: The elapsed wall-clock seconds before the timeout.\n\n    \"\"\"\n\n    def __init__(self, message: str, *, name: str, operation: str, elapsed: float) -&gt; None:\n        \"\"\"Initialize with object name, operation, and elapsed time.\n\n        Args:\n            message: Human-readable error description.\n            name: The MQ object name.\n            operation: The operation that timed out.\n            elapsed: Seconds elapsed before the timeout was raised.\n\n        \"\"\"\n        super().__init__(message)\n        self.name = name\n        self.operation = operation\n        self.elapsed = elapsed\n</code></pre>"},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTTimeoutError.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTTimeoutError.operation","title":"<code>operation = operation</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTTimeoutError.elapsed","title":"<code>elapsed = elapsed</code>  <code>instance-attribute</code>","text":""},{"location":"api/exceptions/#pymqrest.exceptions.MQRESTTimeoutError.__init__","title":"<code>__init__(message, *, name, operation, elapsed)</code>","text":"<p>Initialize with object name, operation, and elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error description.</p> required <code>name</code> <code>str</code> <p>The MQ object name.</p> required <code>operation</code> <code>str</code> <p>The operation that timed out.</p> required <code>elapsed</code> <code>float</code> <p>Seconds elapsed before the timeout was raised.</p> required Source code in <code>src/pymqrest/exceptions.py</code> <pre><code>def __init__(self, message: str, *, name: str, operation: str, elapsed: float) -&gt; None:\n    \"\"\"Initialize with object name, operation, and elapsed time.\n\n    Args:\n        message: Human-readable error description.\n        name: The MQ object name.\n        operation: The operation that timed out.\n        elapsed: Seconds elapsed before the timeout was raised.\n\n    \"\"\"\n    super().__init__(message)\n    self.name = name\n    self.operation = operation\n    self.elapsed = elapsed\n</code></pre>"},{"location":"api/exceptions/#catching-exceptions","title":"Catching exceptions","text":"<p>Catch the base class for broad error handling, or specific subtypes for targeted recovery:</p> <pre><code>from pymqrest.exceptions import (\n    MQRESTCommandError,\n    MQRESTAuthError,\n    MQRESTTransportError,\n    MQRESTError,\n)\n\ntry:\n    session.define_qlocal(\"MY.QUEUE\", request_parameters={\"max_queue_depth\": 50000})\nexcept MQRESTCommandError as err:\n    # MQSC command failed \u2014 check reason code in payload\n    print(f\"Command failed: {err}\")\nexcept MQRESTAuthError:\n    # Credentials rejected\n    print(\"Not authorized\")\nexcept MQRESTTransportError:\n    # Network error\n    print(\"Connection failed\")\nexcept MQRESTError as err:\n    # Catch-all for any other library exception\n    print(f\"Unexpected error: {err}\")\n</code></pre>"},{"location":"api/mapping/","title":"Mapping","text":""},{"location":"api/mapping/#overview","title":"Overview","text":"<p>The mapping module provides bidirectional attribute translation between developer-friendly <code>snake_case</code> names and native MQSC parameter names. The mapper is used internally by <code>MQRESTSession</code> and is not typically called directly.</p> <p>See Mapping Pipeline for a conceptual overview of how mapping works.</p>"},{"location":"api/mapping/#mapping-functions","title":"Mapping functions","text":"<p>The module exposes three public functions that perform the actual translation. These are called internally by <code>MQRESTSession</code> during command execution:</p> <ul> <li> <p><code>map_request_attributes()</code> \u2014 Translates request parameters from   <code>snake_case</code> to MQSC before sending to the REST API. Performs key mapping,   value mapping, and key-value mapping in sequence.</p> </li> <li> <p><code>map_response_attributes()</code> \u2014 Translates a single response dict from   MQSC to <code>snake_case</code> after receiving from the REST API.</p> </li> <li> <p><code>map_response_list()</code> \u2014 Translates a list of response dicts (the common   return type for DISPLAY commands).</p> </li> </ul> <p>The mapper performs three types of translation in each direction:</p> <ul> <li>Key mapping: Attribute name translation (e.g. <code>current_queue_depth</code> \u2194   <code>CURDEPTH</code>)</li> <li>Value mapping: Enumerated value translation (e.g. <code>\"yes\"</code> \u2194 <code>\"YES\"</code>,   <code>\"server_connection\"</code> \u2194 <code>\"SVRCONN\"</code>)</li> <li>Key-value mapping: Combined name+value translation for cases where both   key and value change together (e.g. <code>channel_type=\"server_connection\"</code> \u2192   <code>CHLTYPE(\"SVRCONN\")</code>)</li> </ul>"},{"location":"api/mapping/#mapping-data","title":"Mapping data","text":"<p>The mapping tables are loaded from the JSON resource file at:</p> <pre><code>pymqrest/mapping_data.json\n</code></pre> <p>The data is organized by qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>) with separate maps for request and response directions. Each qualifier contains:</p> <ul> <li><code>request_key_map</code> \u2014 <code>snake_case</code> \u2192 MQSC key mapping for requests</li> <li><code>request_value_map</code> \u2014 value translations for request attributes</li> <li><code>request_key_value_map</code> \u2014 combined key+value translations for requests</li> <li><code>response_key_map</code> \u2014 MQSC \u2192 <code>snake_case</code> key mapping for responses</li> <li><code>response_value_map</code> \u2014 value translations for response attributes</li> </ul> <p>The mapping data was originally bootstrapped from IBM MQ 9.4 documentation and covers all standard MQSC attributes across 42 qualifiers.</p>"},{"location":"api/mapping/#diagnostics","title":"Diagnostics","text":""},{"location":"api/mapping/#mappingissue","title":"MappingIssue","text":"<p>Tracks mapping problems encountered during translation:</p> <ul> <li>Unknown attribute names (not found in key map)</li> <li>Unknown attribute values (not found in value map)</li> <li>Ambiguous mappings</li> </ul> <p>In strict mode, any <code>MappingIssue</code> causes a <code>MappingError</code>. In lenient mode, issues are collected but the unmapped values pass through unchanged.</p>"},{"location":"api/mapping/#mappingerror","title":"MappingError","text":"<p>Raised when attribute mapping fails in strict mode. Contains the list of <code>MappingIssue</code> instances that caused the failure.</p> <pre><code>try:\n    session.display_queue(\"MY.QUEUE\",\n        response_parameters=[\"invalid_attribute_name\"])\nexcept MappingError as e:\n    # e describes the unmappable attributes\n    print(e)\n</code></pre>"},{"location":"api/mapping/#api-reference","title":"API reference","text":"<p>Map request attributes from <code>snake_case</code> into MQSC parameter names.</p> <p>Translates Python-friendly attribute names and values into the native MQSC forms expected by the MQ REST API.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>str</code> <p>The mapping qualifier (e.g. <code>\"queue\"</code>, <code>\"channel\"</code>). See :doc:<code>/mappings/index</code> for available qualifiers.</p> required <code>attributes</code> <code>Mapping[str, object]</code> <p>Request attributes keyed by <code>snake_case</code> names.</p> required <code>strict</code> <code>bool</code> <p>When <code>True</code> (default), raise :class:<code>MappingError</code> on any unrecognised key, value, or qualifier. When <code>False</code>, pass unrecognised attributes through unchanged.</p> <code>True</code> <code>mapping_data</code> <code>Mapping[str, object] | None</code> <p>Optional mapping data to use instead of the built-in :data:<code>MAPPING_DATA</code>. When <code>None</code> (default), the module-level data is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>A new dict with MQSC parameter names as keys.</p> <p>Raises:</p> Type Description <code>MappingError</code> <p>If strict is <code>True</code> and any attribute cannot be mapped.</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def map_request_attributes(\n    qualifier: str,\n    attributes: Mapping[str, object],\n    *,\n    strict: bool = True,\n    mapping_data: Mapping[str, object] | None = None,\n) -&gt; dict[str, object]:\n    \"\"\"Map request attributes from ``snake_case`` into MQSC parameter names.\n\n    Translates Python-friendly attribute names and values into the\n    native MQSC forms expected by the MQ REST API.\n\n    Args:\n        qualifier: The mapping qualifier (e.g. ``\"queue\"``, ``\"channel\"``).\n            See :doc:`/mappings/index` for available qualifiers.\n        attributes: Request attributes keyed by ``snake_case`` names.\n        strict: When ``True`` (default), raise :class:`MappingError`\n            on any unrecognised key, value, or qualifier. When ``False``,\n            pass unrecognised attributes through unchanged.\n        mapping_data: Optional mapping data to use instead of the\n            built-in :data:`MAPPING_DATA`. When ``None`` (default),\n            the module-level data is used.\n\n    Returns:\n        A new dict with MQSC parameter names as keys.\n\n    Raises:\n        MappingError: If *strict* is ``True`` and any attribute cannot\n            be mapped.\n\n    \"\"\"\n    qualifier_data = _get_qualifier_data(qualifier, mapping_data=mapping_data)\n    if qualifier_data is None:\n        return _handle_unknown_qualifier(\n            qualifier,\n            attributes,\n            direction=\"request\",\n            strict=strict,\n        )\n    return _map_attributes(\n        qualifier=qualifier,\n        attributes=attributes,\n        key_map=_get_key_map(qualifier_data, \"request_key_map\"),\n        key_value_map=_get_key_value_map(qualifier_data, \"request_key_value_map\"),\n        value_map=_get_value_map(qualifier_data, \"request_value_map\"),\n        direction=\"request\",\n        strict=strict,\n    )\n</code></pre> <p>Map response attributes from MQSC parameter names to <code>snake_case</code>.</p> <p>Translates native MQSC attribute names and values returned by the MQ REST API into Python-friendly <code>snake_case</code> forms.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>str</code> <p>The mapping qualifier (e.g. <code>\"queue\"</code>, <code>\"channel\"</code>). See :doc:<code>/mappings/index</code> for available qualifiers.</p> required <code>attributes</code> <code>Mapping[str, object]</code> <p>Response attributes keyed by MQSC parameter names.</p> required <code>strict</code> <code>bool</code> <p>When <code>True</code> (default), raise :class:<code>MappingError</code> on any unrecognised key, value, or qualifier. When <code>False</code>, pass unrecognised attributes through unchanged.</p> <code>True</code> <code>mapping_data</code> <code>Mapping[str, object] | None</code> <p>Optional mapping data to use instead of the built-in :data:<code>MAPPING_DATA</code>. When <code>None</code> (default), the module-level data is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>A new dict with <code>snake_case</code> attribute names as keys.</p> <p>Raises:</p> Type Description <code>MappingError</code> <p>If strict is <code>True</code> and any attribute cannot be mapped.</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def map_response_attributes(\n    qualifier: str,\n    attributes: Mapping[str, object],\n    *,\n    strict: bool = True,\n    mapping_data: Mapping[str, object] | None = None,\n) -&gt; dict[str, object]:\n    \"\"\"Map response attributes from MQSC parameter names to ``snake_case``.\n\n    Translates native MQSC attribute names and values returned by the\n    MQ REST API into Python-friendly ``snake_case`` forms.\n\n    Args:\n        qualifier: The mapping qualifier (e.g. ``\"queue\"``, ``\"channel\"``).\n            See :doc:`/mappings/index` for available qualifiers.\n        attributes: Response attributes keyed by MQSC parameter names.\n        strict: When ``True`` (default), raise :class:`MappingError`\n            on any unrecognised key, value, or qualifier. When ``False``,\n            pass unrecognised attributes through unchanged.\n        mapping_data: Optional mapping data to use instead of the\n            built-in :data:`MAPPING_DATA`. When ``None`` (default),\n            the module-level data is used.\n\n    Returns:\n        A new dict with ``snake_case`` attribute names as keys.\n\n    Raises:\n        MappingError: If *strict* is ``True`` and any attribute cannot\n            be mapped.\n\n    \"\"\"\n    qualifier_data = _get_qualifier_data(qualifier, mapping_data=mapping_data)\n    if qualifier_data is None:\n        return _handle_unknown_qualifier(\n            qualifier,\n            attributes,\n            direction=\"response\",\n            strict=strict,\n        )\n    return _map_attributes(\n        qualifier=qualifier,\n        attributes=attributes,\n        key_map=_get_key_map(qualifier_data, \"response_key_map\"),\n        key_value_map={},\n        value_map=_get_value_map(qualifier_data, \"response_value_map\"),\n        direction=\"response\",\n        strict=strict,\n    )\n</code></pre> <p>Map a list of response objects from MQSC names to <code>snake_case</code>.</p> <p>This is the batch equivalent of :func:<code>map_response_attributes</code>. Each object in the list is mapped independently, and issue tracking includes the <code>object_index</code> so problems can be traced to a specific item.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>str</code> <p>The mapping qualifier (e.g. <code>\"queue\"</code>, <code>\"channel\"</code>). See :doc:<code>/mappings/index</code> for available qualifiers.</p> required <code>objects</code> <code>Sequence[Mapping[str, object]]</code> <p>Sequence of response attribute dicts to map.</p> required <code>strict</code> <code>bool</code> <p>When <code>True</code> (default), raise :class:<code>MappingError</code> if any attribute in any object cannot be mapped. When <code>False</code>, pass unrecognised attributes through unchanged.</p> <code>True</code> <code>mapping_data</code> <code>Mapping[str, object] | None</code> <p>Optional mapping data to use instead of the built-in :data:<code>MAPPING_DATA</code>. When <code>None</code> (default), the module-level data is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, object]]</code> <p>A list of dicts with <code>snake_case</code> attribute names.</p> <p>Raises:</p> Type Description <code>MappingError</code> <p>If strict is <code>True</code> and any attribute cannot be mapped. The error's :attr:<code>~MappingError.issues</code> may span multiple objects.</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def map_response_list(\n    qualifier: str,\n    objects: Sequence[Mapping[str, object]],\n    *,\n    strict: bool = True,\n    mapping_data: Mapping[str, object] | None = None,\n) -&gt; list[dict[str, object]]:\n    \"\"\"Map a list of response objects from MQSC names to ``snake_case``.\n\n    This is the batch equivalent of :func:`map_response_attributes`.\n    Each object in the list is mapped independently, and issue tracking\n    includes the ``object_index`` so problems can be traced to a\n    specific item.\n\n    Args:\n        qualifier: The mapping qualifier (e.g. ``\"queue\"``, ``\"channel\"``).\n            See :doc:`/mappings/index` for available qualifiers.\n        objects: Sequence of response attribute dicts to map.\n        strict: When ``True`` (default), raise :class:`MappingError`\n            if any attribute in any object cannot be mapped. When\n            ``False``, pass unrecognised attributes through unchanged.\n        mapping_data: Optional mapping data to use instead of the\n            built-in :data:`MAPPING_DATA`. When ``None`` (default),\n            the module-level data is used.\n\n    Returns:\n        A list of dicts with ``snake_case`` attribute names.\n\n    Raises:\n        MappingError: If *strict* is ``True`` and any attribute cannot\n            be mapped. The error's :attr:`~MappingError.issues` may\n            span multiple objects.\n\n    \"\"\"\n    qualifier_data = _get_qualifier_data(qualifier, mapping_data=mapping_data)\n    if qualifier_data is None:\n        return _handle_unknown_qualifier_list(\n            qualifier,\n            objects,\n            direction=\"response\",\n            strict=strict,\n        )\n    key_map = _get_key_map(qualifier_data, \"response_key_map\")\n    value_map = _get_value_map(qualifier_data, \"response_value_map\")\n    mapped_objects: list[dict[str, object]] = []\n    issues: list[MappingIssue] = []\n    for object_index, attributes in enumerate(objects):\n        mapped_attributes, attribute_issues = _map_attributes_internal(\n            qualifier=qualifier,\n            attributes=attributes,\n            key_map=key_map,\n            key_value_map={},\n            value_map=value_map,\n            direction=\"response\",\n            object_index=object_index,\n        )\n        mapped_objects.append(mapped_attributes)\n        issues.extend(attribute_issues)\n    if strict and issues:\n        raise MappingError(issues)\n    return mapped_objects\n</code></pre> <p>Single mapping issue recorded during attribute translation.</p> <p>Each issue describes one attribute that could not be fully mapped (unknown key, unknown value, or unknown qualifier).</p> <p>Attributes:</p> Name Type Description <code>direction</code> <code>MappingDirection</code> <p>Whether the issue occurred during <code>\"request\"</code> or <code>\"response\"</code> mapping.</p> <code>reason</code> <code>MappingReason</code> <p>Category of the mapping failure \u2014 <code>\"unknown_key\"</code>, <code>\"unknown_value\"</code>, or <code>\"unknown_qualifier\"</code>.</p> <code>attribute_name</code> <code>str</code> <p>The attribute name that triggered the issue.</p> <code>attribute_value</code> <code>object | None</code> <p>The attribute value, if relevant to the issue.</p> <code>object_index</code> <code>int | None</code> <p>Zero-based index within a response list, or <code>None</code> for single-object operations.</p> <code>qualifier</code> <code>str | None</code> <p>The qualifier that was being mapped, or <code>None</code> if not applicable.</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>@dataclass(frozen=True)\nclass MappingIssue:\n    \"\"\"Single mapping issue recorded during attribute translation.\n\n    Each issue describes one attribute that could not be fully mapped\n    (unknown key, unknown value, or unknown qualifier).\n\n    Attributes:\n        direction: Whether the issue occurred during ``\"request\"`` or\n            ``\"response\"`` mapping.\n        reason: Category of the mapping failure \u2014 ``\"unknown_key\"``,\n            ``\"unknown_value\"``, or ``\"unknown_qualifier\"``.\n        attribute_name: The attribute name that triggered the issue.\n        attribute_value: The attribute value, if relevant to the issue.\n        object_index: Zero-based index within a response list, or\n            ``None`` for single-object operations.\n        qualifier: The qualifier that was being mapped, or ``None``\n            if not applicable.\n\n    \"\"\"\n\n    direction: MappingDirection\n    reason: MappingReason\n    attribute_name: str\n    attribute_value: object | None = None\n    object_index: int | None = None\n    qualifier: str | None = None\n\n    def to_payload(self) -&gt; dict[str, object | None]:\n        \"\"\"Return the issue as a JSON-serialisable dict.\n\n        Returns:\n            A dict with keys ``direction``, ``reason``,\n            ``attribute_name``, ``attribute_value``, ``object_index``,\n            and ``qualifier``.\n\n        \"\"\"\n        return {\n            \"direction\": self.direction,\n            \"reason\": self.reason,\n            \"attribute_name\": self.attribute_name,\n            \"attribute_value\": _serialize_value(self.attribute_value),\n            \"object_index\": self.object_index,\n            \"qualifier\": self.qualifier,\n        }\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Raised when attribute mapping fails in strict mode.</p> <p>Contains one or more :class:<code>MappingIssue</code> instances describing exactly which attributes could not be mapped and why.</p> <p>Attributes:</p> Name Type Description <code>issues</code> <p>Tuple of :class:<code>MappingIssue</code> instances captured during the failed mapping operation.</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>class MappingError(Exception):\n    \"\"\"Raised when attribute mapping fails in strict mode.\n\n    Contains one or more :class:`MappingIssue` instances describing\n    exactly which attributes could not be mapped and why.\n\n    Attributes:\n        issues: Tuple of :class:`MappingIssue` instances captured\n            during the failed mapping operation.\n\n    \"\"\"\n\n    def __init__(self, issues: Sequence[MappingIssue], message: str | None = None) -&gt; None:\n        \"\"\"Initialize a mapping error with the captured issues.\n\n        Args:\n            issues: One or more mapping issues that caused the failure.\n            message: Optional override message. When ``None``, a message\n                is built automatically from the issues.\n\n        \"\"\"\n        self.issues = tuple(issues)\n        if message is None:\n            message = self._build_message()\n        super().__init__(message)\n\n    def _build_message(self) -&gt; str:\n        if not self.issues:\n            return \"Mapping failed with no issues reported.\"\n        issue_lines = []\n        for issue in self.issues:\n            index_label = \"-\"\n            if issue.object_index is not None:\n                index_label = str(issue.object_index)\n            qualifier_label = issue.qualifier or \"-\"\n            value_label = \"-\"\n            if issue.attribute_value is not None:\n                value_label = repr(issue.attribute_value)\n            issue_lines.append(\n                \" | \".join(\n                    [\n                        f\"index={index_label}\",\n                        f\"qualifier={qualifier_label}\",\n                        f\"direction={issue.direction}\",\n                        f\"reason={issue.reason}\",\n                        f\"attribute={issue.attribute_name}\",\n                        f\"value={value_label}\",\n                    ],\n                ),\n            )\n        header = f\"Mapping failed with {len(self.issues)} issue(s):\"\n        return \"\\n\".join([header, *issue_lines])\n\n    def to_payload(self) -&gt; list[dict[str, object | None]]:\n        \"\"\"Return mapping issues as JSON-serialisable dicts.\n\n        Returns:\n            A list of dicts, one per issue (see\n            :meth:`MappingIssue.to_payload`).\n\n        \"\"\"\n        return [issue.to_payload() for issue in self.issues]\n</code></pre>"},{"location":"api/mapping/#pymqrest.mapping.MappingIssue.to_payload","title":"<code>to_payload()</code>","text":"<p>Return the issue as a JSON-serialisable dict.</p> <p>Returns:</p> Type Description <code>dict[str, object | None]</code> <p>A dict with keys <code>direction</code>, <code>reason</code>,</p> <code>dict[str, object | None]</code> <p><code>attribute_name</code>, <code>attribute_value</code>, <code>object_index</code>,</p> <code>dict[str, object | None]</code> <p>and <code>qualifier</code>.</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def to_payload(self) -&gt; dict[str, object | None]:\n    \"\"\"Return the issue as a JSON-serialisable dict.\n\n    Returns:\n        A dict with keys ``direction``, ``reason``,\n        ``attribute_name``, ``attribute_value``, ``object_index``,\n        and ``qualifier``.\n\n    \"\"\"\n    return {\n        \"direction\": self.direction,\n        \"reason\": self.reason,\n        \"attribute_name\": self.attribute_name,\n        \"attribute_value\": _serialize_value(self.attribute_value),\n        \"object_index\": self.object_index,\n        \"qualifier\": self.qualifier,\n    }\n</code></pre>"},{"location":"api/mapping/#pymqrest.mapping.MappingError.issues","title":"<code>issues = tuple(issues)</code>  <code>instance-attribute</code>","text":""},{"location":"api/mapping/#pymqrest.mapping.MappingError.__init__","title":"<code>__init__(issues, message=None)</code>","text":"<p>Initialize a mapping error with the captured issues.</p> <p>Parameters:</p> Name Type Description Default <code>issues</code> <code>Sequence[MappingIssue]</code> <p>One or more mapping issues that caused the failure.</p> required <code>message</code> <code>str | None</code> <p>Optional override message. When <code>None</code>, a message is built automatically from the issues.</p> <code>None</code> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def __init__(self, issues: Sequence[MappingIssue], message: str | None = None) -&gt; None:\n    \"\"\"Initialize a mapping error with the captured issues.\n\n    Args:\n        issues: One or more mapping issues that caused the failure.\n        message: Optional override message. When ``None``, a message\n            is built automatically from the issues.\n\n    \"\"\"\n    self.issues = tuple(issues)\n    if message is None:\n        message = self._build_message()\n    super().__init__(message)\n</code></pre>"},{"location":"api/mapping/#pymqrest.mapping.MappingError._build_message","title":"<code>_build_message()</code>","text":"Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def _build_message(self) -&gt; str:\n    if not self.issues:\n        return \"Mapping failed with no issues reported.\"\n    issue_lines = []\n    for issue in self.issues:\n        index_label = \"-\"\n        if issue.object_index is not None:\n            index_label = str(issue.object_index)\n        qualifier_label = issue.qualifier or \"-\"\n        value_label = \"-\"\n        if issue.attribute_value is not None:\n            value_label = repr(issue.attribute_value)\n        issue_lines.append(\n            \" | \".join(\n                [\n                    f\"index={index_label}\",\n                    f\"qualifier={qualifier_label}\",\n                    f\"direction={issue.direction}\",\n                    f\"reason={issue.reason}\",\n                    f\"attribute={issue.attribute_name}\",\n                    f\"value={value_label}\",\n                ],\n            ),\n        )\n    header = f\"Mapping failed with {len(self.issues)} issue(s):\"\n    return \"\\n\".join([header, *issue_lines])\n</code></pre>"},{"location":"api/mapping/#pymqrest.mapping.MappingError.to_payload","title":"<code>to_payload()</code>","text":"<p>Return mapping issues as JSON-serialisable dicts.</p> <p>Returns:</p> Type Description <code>list[dict[str, object | None]]</code> <p>A list of dicts, one per issue (see</p> <code>list[dict[str, object | None]]</code> <p>meth:<code>MappingIssue.to_payload</code>).</p> Source code in <code>src/pymqrest/mapping.py</code> <pre><code>def to_payload(self) -&gt; list[dict[str, object | None]]:\n    \"\"\"Return mapping issues as JSON-serialisable dicts.\n\n    Returns:\n        A list of dicts, one per issue (see\n        :meth:`MappingIssue.to_payload`).\n\n    \"\"\"\n    return [issue.to_payload() for issue in self.issues]\n</code></pre>"},{"location":"api/session/","title":"Session","text":""},{"location":"api/session/#overview","title":"Overview","text":"<p>The <code>MQRESTSession</code> class is the main entry point for interacting with IBM MQ via the REST API. A session encapsulates connection details, authentication, attribute mapping configuration, and diagnostic state. It inherits MQSC command methods from <code>MQRESTCommandMixin</code> (see commands) and idempotent ensure methods from <code>MQRESTEnsureMixin</code> (see ensure).</p>"},{"location":"api/session/#creating-a-session","title":"Creating a session","text":"<pre><code>from pymqrest import MQRESTSession\nfrom pymqrest.auth import LTPAAuth\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n)\n</code></pre> <p>The constructor validates all required fields and constructs the transport, mapping data, and authentication state at creation time. Errors in configuration (e.g. invalid mapping overrides) are caught immediately.</p>"},{"location":"api/session/#constructor-parameters","title":"Constructor parameters","text":"Parameter Type Description <code>rest_base_url</code> Required Base URL of the MQ REST API (e.g. <code>https://host:9443/ibmmq/rest/v2</code>) <code>qmgr_name</code> Required Target queue manager name <code>credentials</code> Required Authentication credentials (<code>LTPAAuth</code>, <code>BasicAuth</code>, or <code>CertificateAuth</code>) <code>gateway_qmgr</code> Optional Gateway queue manager for remote routing <code>map_attributes</code> Optional Enable/disable attribute mapping (default: <code>True</code>) <code>mapping_strict</code> Optional Strict or lenient mapping mode (default: <code>True</code>) <code>mapping_overrides</code> Optional Custom mapping overrides (sparse merge) <code>verify_tls</code> Optional Verify server TLS certificates (default: <code>True</code>) <code>timeout</code> Optional Default request timeout in seconds <code>csrf_token</code> Optional Custom CSRF token value <code>transport</code> Optional Custom transport implementation"},{"location":"api/session/#minimal-example","title":"Minimal example","text":"<pre><code>session = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n)\n</code></pre>"},{"location":"api/session/#full-example","title":"Full example","text":"<pre><code>session = MQRESTSession(\n    rest_base_url=\"https://mq-server.example.com:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM2\",\n    credentials=LTPAAuth(\"mqadmin\", \"mqadmin\"),\n    gateway_qmgr=\"QM1\",\n    map_attributes=True,\n    mapping_strict=False,\n    mapping_overrides=overrides,\n    verify_tls=True,\n    timeout=30,\n)\n</code></pre>"},{"location":"api/session/#command-methods","title":"Command methods","text":"<p>The session provides ~144 command methods, one for each MQSC verb + qualifier combination. See Commands for the full list.</p> <pre><code># DISPLAY commands return a list of dicts\nqueues = session.display_queue(\"APP.*\")\n\n# Queue manager singletons return a single dict or None\nqmgr = session.display_qmgr()\n\n# Non-DISPLAY commands return None (raise on error)\nsession.define_qlocal(\"MY.QUEUE\", request_parameters={\"max_queue_depth\": 50000})\nsession.delete_queue(\"MY.QUEUE\")\n</code></pre>"},{"location":"api/session/#ensure-methods","title":"Ensure methods","text":"<p>The session provides 16 ensure methods for declarative object management. Each method implements an idempotent upsert: DEFINE if the object does not exist, ALTER only the attributes that differ, or no-op if already correct.</p> <pre><code>result = session.ensure_qlocal(\"MY.QUEUE\",\n    request_parameters={\"max_queue_depth\": 50000})\n# result.action is EnsureAction.CREATED, UPDATED, or UNCHANGED\n</code></pre> <p>See Ensure Methods for detailed usage and the full list of available ensure methods.</p>"},{"location":"api/session/#diagnostic-state","title":"Diagnostic state","text":"<p>The session retains the most recent request and response for inspection. This is useful for debugging command failures or understanding what the library sent to the MQ REST API:</p> <pre><code>session.display_queue(\"MY.QUEUE\")\n\nsession.last_command_payload    # the JSON sent to MQ (dict)\nsession.last_response_payload   # the parsed JSON response (dict)\nsession.last_http_status        # HTTP status code (int)\nsession.last_response_text      # raw response body (str)\n</code></pre>"},{"location":"api/session/#diagnostic-attributes","title":"Diagnostic attributes","text":"Attribute Type Description <code>qmgr_name</code> <code>str</code> Queue manager name <code>gateway_qmgr</code> <code>str \\| None</code> Gateway queue manager (or <code>None</code>) <code>last_http_status</code> <code>int</code> HTTP status code from last command <code>last_response_text</code> <code>str</code> Raw response body from last command <code>last_response_payload</code> <code>dict</code> Parsed response from last command <code>last_command_payload</code> <code>dict</code> Command sent in last request"},{"location":"api/session/#transport","title":"Transport","text":"<p>See Transport for the transport protocol, response type, and mock transport examples.</p>"},{"location":"api/session/#api-reference","title":"API reference","text":"<p>               Bases: <code>MQRESTSyncMixin</code>, <code>MQRESTEnsureMixin</code>, <code>MQRESTCommandMixin</code></p> <p>Session wrapper for MQ REST admin calls.</p> <p>Provides MQSC command execution via the IBM MQ <code>runCommandJSON</code> REST endpoint. Attribute mapping between <code>snake_case</code> and native MQSC parameter names is enabled by default.</p> <p>All MQSC command methods are inherited from :class:<code>~pymqrest.commands.MQRESTCommandMixin</code> \u2014 see :doc:<code>/api/commands</code> for the full list.</p> <p>Attributes:</p> Name Type Description <code>last_response_payload</code> <code>dict[str, object] | None</code> <p>The parsed JSON payload from the most recent command, or <code>None</code> before any command is executed.</p> <code>last_response_text</code> <code>str | None</code> <p>The raw HTTP response body from the most recent command, or <code>None</code>.</p> <code>last_http_status</code> <code>int | None</code> <p>The HTTP status code from the most recent command, or <code>None</code>.</p> <code>last_command_payload</code> <code>dict[str, object] | None</code> <p>The <code>runCommandJSON</code> request payload sent for the most recent command, or <code>None</code>.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>class MQRESTSession(MQRESTSyncMixin, MQRESTEnsureMixin, MQRESTCommandMixin):\n    \"\"\"Session wrapper for MQ REST admin calls.\n\n    Provides MQSC command execution via the IBM MQ ``runCommandJSON``\n    REST endpoint. Attribute mapping between ``snake_case`` and native\n    MQSC parameter names is enabled by default.\n\n    All MQSC command methods are inherited from\n    :class:`~pymqrest.commands.MQRESTCommandMixin` \u2014 see\n    :doc:`/api/commands` for the full list.\n\n    Attributes:\n        last_response_payload: The parsed JSON payload from the most\n            recent command, or ``None`` before any command is executed.\n        last_response_text: The raw HTTP response body from the most\n            recent command, or ``None``.\n        last_http_status: The HTTP status code from the most recent\n            command, or ``None``.\n        last_command_payload: The ``runCommandJSON`` request payload\n            sent for the most recent command, or ``None``.\n\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        rest_base_url: str,\n        qmgr_name: str,\n        *,\n        credentials: Credentials,\n        gateway_qmgr: str | None = None,\n        verify_tls: bool = True,\n        timeout_seconds: float | None = 30.0,\n        map_attributes: bool = True,\n        mapping_strict: bool = True,\n        mapping_overrides: Mapping[str, object] | None = None,\n        mapping_overrides_mode: MappingOverrideMode = MappingOverrideMode.MERGE,\n        csrf_token: str | None = DEFAULT_CSRF_TOKEN,\n        transport: MQRESTTransport | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize an MQ REST session.\n\n        Args:\n            rest_base_url: Base URL of the MQ REST API\n                (e.g. ``\"https://localhost:9443/ibmmq/rest/v2\"``).\n            qmgr_name: Name of the target queue manager.\n            credentials: A credential object (:class:`~pymqrest.auth.BasicAuth`,\n                :class:`~pymqrest.auth.LTPAAuth`, or\n                :class:`~pymqrest.auth.CertificateAuth`).\n            gateway_qmgr: Name of the gateway queue manager that routes\n                commands to *qmgr_name*. When set, the\n                ``ibm-mq-rest-gateway-qmgr`` header is included in\n                every request. When ``None`` (default), commands target\n                the queue manager directly.\n            verify_tls: Whether to verify the server's TLS certificate.\n                Set to ``False`` for self-signed certificates.\n            timeout_seconds: HTTP request timeout in seconds, or\n                ``None`` for no timeout.\n            map_attributes: When ``True`` (default), translate attribute\n                names between ``snake_case`` and MQSC forms\n                automatically.\n            mapping_strict: When ``True`` (default), raise\n                :class:`~pymqrest.mapping.MappingError` on any\n                unrecognised attribute. When ``False``, pass\n                unrecognised attributes through unchanged.\n            mapping_overrides: Optional overrides for the built-in\n                mapping data. Keys must be a subset of\n                ``{\"commands\", \"qualifiers\"}``. Behaviour depends on\n                *mapping_overrides_mode*.\n            mapping_overrides_mode: How to apply *mapping_overrides*.\n                :attr:`~MappingOverrideMode.MERGE` (default) performs a\n                sparse, additive merge.\n                :attr:`~MappingOverrideMode.REPLACE` treats the\n                overrides as a complete replacement \u2014 a ``ValueError``\n                is raised if any command or qualifier key from the\n                built-in data is missing.\n            csrf_token: CSRF token value for the\n                ``ibm-mq-rest-csrf-token`` header. Defaults to\n                ``\"local\"``. Set to ``None`` to omit the header.\n            transport: Custom :class:`MQRESTTransport` implementation.\n                Defaults to :class:`RequestsTransport`.\n\n        Raises:\n            MQRESTAuthError: If LTPA login fails at construction time.\n            ValueError: If *mapping_overrides* has an invalid structure.\n\n        \"\"\"\n        self._rest_base_url = rest_base_url.rstrip(\"/\")\n        self._qmgr_name = qmgr_name\n        self._gateway_qmgr = gateway_qmgr\n        self._verify_tls = verify_tls\n        self._timeout_seconds = timeout_seconds\n        self._map_attributes = map_attributes\n        self._mapping_strict = mapping_strict\n        self._csrf_token = csrf_token\n        self._credentials = credentials\n\n        if mapping_overrides is not None:\n            validate_mapping_overrides(mapping_overrides)\n            if mapping_overrides_mode is MappingOverrideMode.REPLACE:\n                validate_mapping_overrides_complete(MAPPING_DATA, mapping_overrides)\n                self._mapping_data: dict[str, object] = replace_mapping_data(mapping_overrides)\n            else:\n                self._mapping_data = merge_mapping_data(MAPPING_DATA, mapping_overrides)\n        else:\n            self._mapping_data = MAPPING_DATA\n\n        if isinstance(credentials, CertificateAuth) and transport is None:\n            cert = (\n                (credentials.cert_path, credentials.key_path)\n                if credentials.key_path is not None\n                else credentials.cert_path\n            )\n            self._transport: MQRESTTransport = RequestsTransport(client_cert=cert)\n        else:\n            self._transport = transport or RequestsTransport()\n\n        self._ltpa_token: str | None = None\n        if isinstance(credentials, LTPAAuth):\n            self._ltpa_token = _perform_ltpa_login(\n                self._transport,\n                self._rest_base_url,\n                credentials,\n                csrf_token=self._csrf_token,\n                timeout_seconds=self._timeout_seconds,\n                verify_tls=self._verify_tls,\n            )\n\n        self.last_response_payload: dict[str, object] | None = None\n        self.last_response_text: str | None = None\n        self.last_http_status: int | None = None\n        self.last_command_payload: dict[str, object] | None = None\n\n    @property\n    def qmgr_name(self) -&gt; str:\n        \"\"\"The queue manager name this session targets.\"\"\"\n        return self._qmgr_name\n\n    @property\n    def gateway_qmgr(self) -&gt; str | None:\n        \"\"\"The gateway queue manager name, or ``None`` for direct access.\"\"\"\n        return self._gateway_qmgr\n\n    def _mqsc_command(  # noqa: PLR0913\n        self,\n        *,\n        command: str,\n        mqsc_qualifier: str,\n        name: str | None,\n        request_parameters: Mapping[str, object] | None,\n        response_parameters: Sequence[str] | None,\n        where: str | None = None,\n    ) -&gt; list[dict[str, object]]:\n        command_upper = command.strip().upper()\n        qualifier_upper = mqsc_qualifier.strip().upper()\n        normalized_request_parameters = dict(request_parameters or {})\n        normalized_response_parameters = _normalize_response_parameters(\n            response_parameters,\n            is_display=command_upper == \"DISPLAY\",\n        )\n        map_attributes = self._map_attributes\n        mapping_qualifier = self._resolve_mapping_qualifier(command_upper, qualifier_upper)\n\n        if map_attributes:\n            normalized_request_parameters = map_request_attributes(\n                mapping_qualifier,\n                normalized_request_parameters,\n                strict=self._mapping_strict,\n                mapping_data=self._mapping_data,\n            )\n            normalized_response_parameters = self._map_response_parameters(\n                command_upper,\n                qualifier_upper,\n                mapping_qualifier,\n                normalized_response_parameters,\n            )\n\n        if where is not None and where.strip():\n            mapped_where = where\n            if map_attributes:\n                mapped_where = _map_where_keyword(\n                    where,\n                    mapping_qualifier,\n                    strict=self._mapping_strict,\n                    mapping_data=self._mapping_data,\n                )\n            normalized_request_parameters[\"WHERE\"] = mapped_where\n\n        payload = _build_command_payload(\n            command=command_upper,\n            qualifier=qualifier_upper,\n            name=name,\n            request_parameters=normalized_request_parameters,\n            response_parameters=normalized_response_parameters,\n        )\n        self.last_command_payload = dict(payload)\n        transport_response = self._transport.post_json(\n            self._build_mqsc_url(),\n            payload,\n            headers=self._build_headers(),\n            timeout_seconds=self._timeout_seconds,\n            verify_tls=self._verify_tls,\n        )\n        self.last_http_status = transport_response.status_code\n        self.last_response_text = transport_response.text\n        response_payload = _parse_response_payload(transport_response.text)\n        self.last_response_payload = response_payload\n        _raise_for_command_errors(response_payload, transport_response.status_code)\n\n        command_response = _extract_command_response(response_payload)\n        parameter_objects: list[dict[str, object]] = []\n        for command_response_item in command_response:\n            parameters = command_response_item.get(\"parameters\")\n            if isinstance(parameters, Mapping):\n                parameters_map = cast(\"Mapping[str, object]\", parameters)\n                parameter_objects.append(dict(parameters_map))\n            else:\n                parameter_objects.append({})\n\n        parameter_objects = _flatten_nested_objects(parameter_objects)\n\n        if map_attributes:\n            normalized_objects = [_normalize_response_attributes(item) for item in parameter_objects]\n            return map_response_list(\n                mapping_qualifier,\n                normalized_objects,\n                strict=self._mapping_strict,\n                mapping_data=self._mapping_data,\n            )\n        return parameter_objects\n\n    def _build_mqsc_url(self) -&gt; str:\n        return f\"{self._rest_base_url}/admin/action/qmgr/{self._qmgr_name}/mqsc\"\n\n    def _build_headers(self) -&gt; dict[str, str]:\n        headers: dict[str, str] = {\"Accept\": \"application/json\"}\n        if isinstance(self._credentials, BasicAuth):\n            headers[\"Authorization\"] = _build_basic_auth_header(\n                self._credentials.username,\n                self._credentials.password,\n            )\n        elif isinstance(self._credentials, LTPAAuth) and self._ltpa_token is not None:\n            headers[\"Cookie\"] = f\"{LTPA_COOKIE_NAME}={self._ltpa_token}\"\n        if self._csrf_token is not None:\n            headers[\"ibm-mq-rest-csrf-token\"] = self._csrf_token\n        if self._gateway_qmgr is not None:\n            headers[GATEWAY_HEADER] = self._gateway_qmgr\n        return headers\n\n    def _map_response_parameters(\n        self,\n        command: str,\n        mqsc_qualifier: str,\n        mapping_qualifier: str,\n        response_parameters: list[str],\n    ) -&gt; list[str]:\n        if _is_all_response_parameters(response_parameters):\n            return response_parameters\n        response_parameter_macros = _get_response_parameter_macros(\n            command,\n            mqsc_qualifier,\n            mapping_data=self._mapping_data,\n        )\n        macro_lookup = {macro.lower(): macro for macro in response_parameter_macros}\n        qualifier_entry = _get_qualifier_entry(mapping_qualifier, mapping_data=self._mapping_data)\n        if qualifier_entry is None:\n            if self._mapping_strict:\n                raise MappingError(_build_unknown_qualifier_issue(mapping_qualifier))\n            return response_parameters\n        combined_map = _build_snake_to_mqsc_map(qualifier_entry)\n        mapped, issues = _map_response_parameter_names(\n            response_parameters,\n            macro_lookup,\n            combined_map,\n            mapping_qualifier,\n        )\n        if self._mapping_strict and issues:\n            raise MappingError(issues)\n        return mapped\n\n    def _resolve_mapping_qualifier(self, command: str, mqsc_qualifier: str) -&gt; str:\n        command_map = _get_command_map(self._mapping_data)\n        command_key = f\"{command} {mqsc_qualifier}\"\n        command_definition = command_map.get(command_key)\n        if isinstance(command_definition, Mapping):\n            command_definition_map = cast(\"Mapping[str, object]\", command_definition)\n            qualifier = command_definition_map.get(\"qualifier\")\n            if isinstance(qualifier, str):\n                return qualifier\n        fallback = _DEFAULT_MAPPING_QUALIFIERS.get(mqsc_qualifier)\n        if fallback is not None:\n            return fallback\n        return mqsc_qualifier.lower()\n</code></pre>"},{"location":"api/session/#pymqrest.session.MQRESTSession._rest_base_url","title":"<code>_rest_base_url = rest_base_url.rstrip('/')</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._qmgr_name","title":"<code>_qmgr_name = qmgr_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._gateway_qmgr","title":"<code>_gateway_qmgr = gateway_qmgr</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._verify_tls","title":"<code>_verify_tls = verify_tls</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._timeout_seconds","title":"<code>_timeout_seconds = timeout_seconds</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._map_attributes","title":"<code>_map_attributes = map_attributes</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._mapping_strict","title":"<code>_mapping_strict = mapping_strict</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._csrf_token","title":"<code>_csrf_token = csrf_token</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._credentials","title":"<code>_credentials = credentials</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._mapping_data","title":"<code>_mapping_data = replace_mapping_data(mapping_overrides)</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._transport","title":"<code>_transport = RequestsTransport(client_cert=cert)</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession._ltpa_token","title":"<code>_ltpa_token = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession.last_response_payload","title":"<code>last_response_payload = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession.last_response_text","title":"<code>last_response_text = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession.last_http_status","title":"<code>last_http_status = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession.last_command_payload","title":"<code>last_command_payload = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#pymqrest.session.MQRESTSession.qmgr_name","title":"<code>qmgr_name</code>  <code>property</code>","text":"<p>The queue manager name this session targets.</p>"},{"location":"api/session/#pymqrest.session.MQRESTSession.gateway_qmgr","title":"<code>gateway_qmgr</code>  <code>property</code>","text":"<p>The gateway queue manager name, or <code>None</code> for direct access.</p>"},{"location":"api/session/#pymqrest.session.MQRESTSession.__init__","title":"<code>__init__(rest_base_url, qmgr_name, *, credentials, gateway_qmgr=None, verify_tls=True, timeout_seconds=30.0, map_attributes=True, mapping_strict=True, mapping_overrides=None, mapping_overrides_mode=MappingOverrideMode.MERGE, csrf_token=DEFAULT_CSRF_TOKEN, transport=None)</code>","text":"<p>Initialize an MQ REST session.</p> <p>Parameters:</p> Name Type Description Default <code>rest_base_url</code> <code>str</code> <p>Base URL of the MQ REST API (e.g. <code>\"https://localhost:9443/ibmmq/rest/v2\"</code>).</p> required <code>qmgr_name</code> <code>str</code> <p>Name of the target queue manager.</p> required <code>credentials</code> <code>Credentials</code> <p>A credential object (:class:<code>~pymqrest.auth.BasicAuth</code>, :class:<code>~pymqrest.auth.LTPAAuth</code>, or :class:<code>~pymqrest.auth.CertificateAuth</code>).</p> required <code>gateway_qmgr</code> <code>str | None</code> <p>Name of the gateway queue manager that routes commands to qmgr_name. When set, the <code>ibm-mq-rest-gateway-qmgr</code> header is included in every request. When <code>None</code> (default), commands target the queue manager directly.</p> <code>None</code> <code>verify_tls</code> <code>bool</code> <p>Whether to verify the server's TLS certificate. Set to <code>False</code> for self-signed certificates.</p> <code>True</code> <code>timeout_seconds</code> <code>float | None</code> <p>HTTP request timeout in seconds, or <code>None</code> for no timeout.</p> <code>30.0</code> <code>map_attributes</code> <code>bool</code> <p>When <code>True</code> (default), translate attribute names between <code>snake_case</code> and MQSC forms automatically.</p> <code>True</code> <code>mapping_strict</code> <code>bool</code> <p>When <code>True</code> (default), raise :class:<code>~pymqrest.mapping.MappingError</code> on any unrecognised attribute. When <code>False</code>, pass unrecognised attributes through unchanged.</p> <code>True</code> <code>mapping_overrides</code> <code>Mapping[str, object] | None</code> <p>Optional overrides for the built-in mapping data. Keys must be a subset of <code>{\"commands\", \"qualifiers\"}</code>. Behaviour depends on mapping_overrides_mode.</p> <code>None</code> <code>mapping_overrides_mode</code> <code>MappingOverrideMode</code> <p>How to apply mapping_overrides. :attr:<code>~MappingOverrideMode.MERGE</code> (default) performs a sparse, additive merge. :attr:<code>~MappingOverrideMode.REPLACE</code> treats the overrides as a complete replacement \u2014 a <code>ValueError</code> is raised if any command or qualifier key from the built-in data is missing.</p> <code>MERGE</code> <code>csrf_token</code> <code>str | None</code> <p>CSRF token value for the <code>ibm-mq-rest-csrf-token</code> header. Defaults to <code>\"local\"</code>. Set to <code>None</code> to omit the header.</p> <code>DEFAULT_CSRF_TOKEN</code> <code>transport</code> <code>MQRESTTransport | None</code> <p>Custom :class:<code>MQRESTTransport</code> implementation. Defaults to :class:<code>RequestsTransport</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>MQRESTAuthError</code> <p>If LTPA login fails at construction time.</p> <code>ValueError</code> <p>If mapping_overrides has an invalid structure.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    rest_base_url: str,\n    qmgr_name: str,\n    *,\n    credentials: Credentials,\n    gateway_qmgr: str | None = None,\n    verify_tls: bool = True,\n    timeout_seconds: float | None = 30.0,\n    map_attributes: bool = True,\n    mapping_strict: bool = True,\n    mapping_overrides: Mapping[str, object] | None = None,\n    mapping_overrides_mode: MappingOverrideMode = MappingOverrideMode.MERGE,\n    csrf_token: str | None = DEFAULT_CSRF_TOKEN,\n    transport: MQRESTTransport | None = None,\n) -&gt; None:\n    \"\"\"Initialize an MQ REST session.\n\n    Args:\n        rest_base_url: Base URL of the MQ REST API\n            (e.g. ``\"https://localhost:9443/ibmmq/rest/v2\"``).\n        qmgr_name: Name of the target queue manager.\n        credentials: A credential object (:class:`~pymqrest.auth.BasicAuth`,\n            :class:`~pymqrest.auth.LTPAAuth`, or\n            :class:`~pymqrest.auth.CertificateAuth`).\n        gateway_qmgr: Name of the gateway queue manager that routes\n            commands to *qmgr_name*. When set, the\n            ``ibm-mq-rest-gateway-qmgr`` header is included in\n            every request. When ``None`` (default), commands target\n            the queue manager directly.\n        verify_tls: Whether to verify the server's TLS certificate.\n            Set to ``False`` for self-signed certificates.\n        timeout_seconds: HTTP request timeout in seconds, or\n            ``None`` for no timeout.\n        map_attributes: When ``True`` (default), translate attribute\n            names between ``snake_case`` and MQSC forms\n            automatically.\n        mapping_strict: When ``True`` (default), raise\n            :class:`~pymqrest.mapping.MappingError` on any\n            unrecognised attribute. When ``False``, pass\n            unrecognised attributes through unchanged.\n        mapping_overrides: Optional overrides for the built-in\n            mapping data. Keys must be a subset of\n            ``{\"commands\", \"qualifiers\"}``. Behaviour depends on\n            *mapping_overrides_mode*.\n        mapping_overrides_mode: How to apply *mapping_overrides*.\n            :attr:`~MappingOverrideMode.MERGE` (default) performs a\n            sparse, additive merge.\n            :attr:`~MappingOverrideMode.REPLACE` treats the\n            overrides as a complete replacement \u2014 a ``ValueError``\n            is raised if any command or qualifier key from the\n            built-in data is missing.\n        csrf_token: CSRF token value for the\n            ``ibm-mq-rest-csrf-token`` header. Defaults to\n            ``\"local\"``. Set to ``None`` to omit the header.\n        transport: Custom :class:`MQRESTTransport` implementation.\n            Defaults to :class:`RequestsTransport`.\n\n    Raises:\n        MQRESTAuthError: If LTPA login fails at construction time.\n        ValueError: If *mapping_overrides* has an invalid structure.\n\n    \"\"\"\n    self._rest_base_url = rest_base_url.rstrip(\"/\")\n    self._qmgr_name = qmgr_name\n    self._gateway_qmgr = gateway_qmgr\n    self._verify_tls = verify_tls\n    self._timeout_seconds = timeout_seconds\n    self._map_attributes = map_attributes\n    self._mapping_strict = mapping_strict\n    self._csrf_token = csrf_token\n    self._credentials = credentials\n\n    if mapping_overrides is not None:\n        validate_mapping_overrides(mapping_overrides)\n        if mapping_overrides_mode is MappingOverrideMode.REPLACE:\n            validate_mapping_overrides_complete(MAPPING_DATA, mapping_overrides)\n            self._mapping_data: dict[str, object] = replace_mapping_data(mapping_overrides)\n        else:\n            self._mapping_data = merge_mapping_data(MAPPING_DATA, mapping_overrides)\n    else:\n        self._mapping_data = MAPPING_DATA\n\n    if isinstance(credentials, CertificateAuth) and transport is None:\n        cert = (\n            (credentials.cert_path, credentials.key_path)\n            if credentials.key_path is not None\n            else credentials.cert_path\n        )\n        self._transport: MQRESTTransport = RequestsTransport(client_cert=cert)\n    else:\n        self._transport = transport or RequestsTransport()\n\n    self._ltpa_token: str | None = None\n    if isinstance(credentials, LTPAAuth):\n        self._ltpa_token = _perform_ltpa_login(\n            self._transport,\n            self._rest_base_url,\n            credentials,\n            csrf_token=self._csrf_token,\n            timeout_seconds=self._timeout_seconds,\n            verify_tls=self._verify_tls,\n        )\n\n    self.last_response_payload: dict[str, object] | None = None\n    self.last_response_text: str | None = None\n    self.last_http_status: int | None = None\n    self.last_command_payload: dict[str, object] | None = None\n</code></pre>"},{"location":"api/session/#pymqrest.session.MQRESTSession._mqsc_command","title":"<code>_mqsc_command(*, command, mqsc_qualifier, name, request_parameters, response_parameters, where=None)</code>","text":"Source code in <code>src/pymqrest/session.py</code> <pre><code>def _mqsc_command(  # noqa: PLR0913\n    self,\n    *,\n    command: str,\n    mqsc_qualifier: str,\n    name: str | None,\n    request_parameters: Mapping[str, object] | None,\n    response_parameters: Sequence[str] | None,\n    where: str | None = None,\n) -&gt; list[dict[str, object]]:\n    command_upper = command.strip().upper()\n    qualifier_upper = mqsc_qualifier.strip().upper()\n    normalized_request_parameters = dict(request_parameters or {})\n    normalized_response_parameters = _normalize_response_parameters(\n        response_parameters,\n        is_display=command_upper == \"DISPLAY\",\n    )\n    map_attributes = self._map_attributes\n    mapping_qualifier = self._resolve_mapping_qualifier(command_upper, qualifier_upper)\n\n    if map_attributes:\n        normalized_request_parameters = map_request_attributes(\n            mapping_qualifier,\n            normalized_request_parameters,\n            strict=self._mapping_strict,\n            mapping_data=self._mapping_data,\n        )\n        normalized_response_parameters = self._map_response_parameters(\n            command_upper,\n            qualifier_upper,\n            mapping_qualifier,\n            normalized_response_parameters,\n        )\n\n    if where is not None and where.strip():\n        mapped_where = where\n        if map_attributes:\n            mapped_where = _map_where_keyword(\n                where,\n                mapping_qualifier,\n                strict=self._mapping_strict,\n                mapping_data=self._mapping_data,\n            )\n        normalized_request_parameters[\"WHERE\"] = mapped_where\n\n    payload = _build_command_payload(\n        command=command_upper,\n        qualifier=qualifier_upper,\n        name=name,\n        request_parameters=normalized_request_parameters,\n        response_parameters=normalized_response_parameters,\n    )\n    self.last_command_payload = dict(payload)\n    transport_response = self._transport.post_json(\n        self._build_mqsc_url(),\n        payload,\n        headers=self._build_headers(),\n        timeout_seconds=self._timeout_seconds,\n        verify_tls=self._verify_tls,\n    )\n    self.last_http_status = transport_response.status_code\n    self.last_response_text = transport_response.text\n    response_payload = _parse_response_payload(transport_response.text)\n    self.last_response_payload = response_payload\n    _raise_for_command_errors(response_payload, transport_response.status_code)\n\n    command_response = _extract_command_response(response_payload)\n    parameter_objects: list[dict[str, object]] = []\n    for command_response_item in command_response:\n        parameters = command_response_item.get(\"parameters\")\n        if isinstance(parameters, Mapping):\n            parameters_map = cast(\"Mapping[str, object]\", parameters)\n            parameter_objects.append(dict(parameters_map))\n        else:\n            parameter_objects.append({})\n\n    parameter_objects = _flatten_nested_objects(parameter_objects)\n\n    if map_attributes:\n        normalized_objects = [_normalize_response_attributes(item) for item in parameter_objects]\n        return map_response_list(\n            mapping_qualifier,\n            normalized_objects,\n            strict=self._mapping_strict,\n            mapping_data=self._mapping_data,\n        )\n    return parameter_objects\n</code></pre>"},{"location":"api/session/#pymqrest.session.MQRESTSession._build_mqsc_url","title":"<code>_build_mqsc_url()</code>","text":"Source code in <code>src/pymqrest/session.py</code> <pre><code>def _build_mqsc_url(self) -&gt; str:\n    return f\"{self._rest_base_url}/admin/action/qmgr/{self._qmgr_name}/mqsc\"\n</code></pre>"},{"location":"api/session/#pymqrest.session.MQRESTSession._build_headers","title":"<code>_build_headers()</code>","text":"Source code in <code>src/pymqrest/session.py</code> <pre><code>def _build_headers(self) -&gt; dict[str, str]:\n    headers: dict[str, str] = {\"Accept\": \"application/json\"}\n    if isinstance(self._credentials, BasicAuth):\n        headers[\"Authorization\"] = _build_basic_auth_header(\n            self._credentials.username,\n            self._credentials.password,\n        )\n    elif isinstance(self._credentials, LTPAAuth) and self._ltpa_token is not None:\n        headers[\"Cookie\"] = f\"{LTPA_COOKIE_NAME}={self._ltpa_token}\"\n    if self._csrf_token is not None:\n        headers[\"ibm-mq-rest-csrf-token\"] = self._csrf_token\n    if self._gateway_qmgr is not None:\n        headers[GATEWAY_HEADER] = self._gateway_qmgr\n    return headers\n</code></pre>"},{"location":"api/session/#pymqrest.session.MQRESTSession._map_response_parameters","title":"<code>_map_response_parameters(command, mqsc_qualifier, mapping_qualifier, response_parameters)</code>","text":"Source code in <code>src/pymqrest/session.py</code> <pre><code>def _map_response_parameters(\n    self,\n    command: str,\n    mqsc_qualifier: str,\n    mapping_qualifier: str,\n    response_parameters: list[str],\n) -&gt; list[str]:\n    if _is_all_response_parameters(response_parameters):\n        return response_parameters\n    response_parameter_macros = _get_response_parameter_macros(\n        command,\n        mqsc_qualifier,\n        mapping_data=self._mapping_data,\n    )\n    macro_lookup = {macro.lower(): macro for macro in response_parameter_macros}\n    qualifier_entry = _get_qualifier_entry(mapping_qualifier, mapping_data=self._mapping_data)\n    if qualifier_entry is None:\n        if self._mapping_strict:\n            raise MappingError(_build_unknown_qualifier_issue(mapping_qualifier))\n        return response_parameters\n    combined_map = _build_snake_to_mqsc_map(qualifier_entry)\n    mapped, issues = _map_response_parameter_names(\n        response_parameters,\n        macro_lookup,\n        combined_map,\n        mapping_qualifier,\n    )\n    if self._mapping_strict and issues:\n        raise MappingError(issues)\n    return mapped\n</code></pre>"},{"location":"api/session/#pymqrest.session.MQRESTSession._resolve_mapping_qualifier","title":"<code>_resolve_mapping_qualifier(command, mqsc_qualifier)</code>","text":"Source code in <code>src/pymqrest/session.py</code> <pre><code>def _resolve_mapping_qualifier(self, command: str, mqsc_qualifier: str) -&gt; str:\n    command_map = _get_command_map(self._mapping_data)\n    command_key = f\"{command} {mqsc_qualifier}\"\n    command_definition = command_map.get(command_key)\n    if isinstance(command_definition, Mapping):\n        command_definition_map = cast(\"Mapping[str, object]\", command_definition)\n        qualifier = command_definition_map.get(\"qualifier\")\n        if isinstance(qualifier, str):\n            return qualifier\n    fallback = _DEFAULT_MAPPING_QUALIFIERS.get(mqsc_qualifier)\n    if fallback is not None:\n        return fallback\n    return mqsc_qualifier.lower()\n</code></pre>"},{"location":"api/sync/","title":"Sync","text":""},{"location":"api/sync/#overview","title":"Overview","text":"<p>The sync module provides the types for the 9 synchronous start/stop/restart methods on <code>MQRESTSession</code>. These methods wrap fire-and-forget <code>START</code> and <code>STOP</code> commands with a polling loop that waits until the object reaches its target state or the timeout expires.</p>"},{"location":"api/sync/#syncoperation","title":"SyncOperation","text":"<p>An enum indicating the operation that was performed:</p> <pre><code>class SyncOperation(Enum):\n    STARTED    = \"started\"     # Object confirmed running\n    STOPPED    = \"stopped\"     # Object confirmed stopped\n    RESTARTED  = \"restarted\"   # Stop-then-start completed\n</code></pre>"},{"location":"api/sync/#syncconfig","title":"SyncConfig","text":"<p>Configuration controlling the polling behaviour:</p> <pre><code>@dataclass\nclass SyncConfig:\n    timeout: float = 30.0         # Max seconds before raising\n    poll_interval: float = 1.0    # Seconds between polls\n</code></pre> Attribute Type Description <code>timeout</code> <code>float</code> Maximum seconds to wait before raising <code>MQRESTTimeoutError</code> <code>poll_interval</code> <code>float</code> Seconds between <code>DISPLAY *STATUS</code> polls"},{"location":"api/sync/#syncresult","title":"SyncResult","text":"<p>Contains the outcome of a sync operation:</p> <pre><code>class SyncResult(NamedTuple):\n    operation: SyncOperation   # What happened\n    polls: int                 # Number of status polls issued\n    elapsed: float             # Wall-clock seconds from command to confirmation\n</code></pre> Attribute Type Description <code>operation</code> <code>SyncOperation</code> What happened: <code>STARTED</code>, <code>STOPPED</code>, or <code>RESTARTED</code> <code>polls</code> <code>int</code> Number of status polls issued <code>elapsed</code> <code>float</code> Wall-clock seconds from command to confirmation"},{"location":"api/sync/#method-signature-pattern","title":"Method signature pattern","text":"<p>All 9 sync methods follow the same signature pattern:</p> <pre><code>result = session.start_channel_sync(\"TO.PARTNER\")\nresult = session.start_channel_sync(\"TO.PARTNER\", config=SyncConfig(timeout=60))\n</code></pre>"},{"location":"api/sync/#usage","title":"Usage","text":"<pre><code>from pymqrest.sync import SyncConfig\n\nresult = session.start_channel_sync(\"TO.PARTNER\")\n\nmatch result.operation:\n    case SyncOperation.STARTED:\n        print(f\"Running after {result.polls} polls\")\n    case SyncOperation.STOPPED:\n        print(\"Stopped\")\n    case SyncOperation.RESTARTED:\n        print(f\"Restarted in {result.elapsed:.1f}s\")\n</code></pre> <p>See Sync Methods for the full conceptual overview, polling behaviour, and the complete list of available methods.</p>"},{"location":"api/sync/#api-reference","title":"API reference","text":"<p>Configuration for synchronous polling operations.</p> <p>Attributes:</p> Name Type Description <code>timeout_seconds</code> <code>float</code> <p>Maximum wall-clock seconds to wait for the object to reach the target state.</p> <code>poll_interval_seconds</code> <code>float</code> <p>Seconds to sleep between status polls.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>@dataclass(frozen=True)\nclass SyncConfig:\n    \"\"\"Configuration for synchronous polling operations.\n\n    Attributes:\n        timeout_seconds: Maximum wall-clock seconds to wait for the\n            object to reach the target state.\n        poll_interval_seconds: Seconds to sleep between status polls.\n\n    \"\"\"\n\n    timeout_seconds: float = 30.0\n    poll_interval_seconds: float = 1.0\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>Operation performed by a synchronous wrapper.</p> <p>Attributes:</p> Name Type Description <code>STARTED</code> <p>The object was started and confirmed running.</p> <code>STOPPED</code> <p>The object was stopped and confirmed stopped.</p> <code>RESTARTED</code> <p>The object was stopped then started.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>class SyncOperation(enum.Enum):\n    \"\"\"Operation performed by a synchronous wrapper.\n\n    Attributes:\n        STARTED: The object was started and confirmed running.\n        STOPPED: The object was stopped and confirmed stopped.\n        RESTARTED: The object was stopped then started.\n\n    \"\"\"\n\n    STARTED = \"started\"\n    STOPPED = \"stopped\"\n    RESTARTED = \"restarted\"\n</code></pre> <p>Result of a synchronous start/stop/restart operation.</p> <p>Attributes:</p> Name Type Description <code>operation</code> <code>SyncOperation</code> <p>The :class:<code>SyncOperation</code> that was performed.</p> <code>polls</code> <code>int</code> <p>Total number of status polls issued.</p> <code>elapsed_seconds</code> <code>float</code> <p>Total wall-clock seconds from command to target state confirmation.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>@dataclass(frozen=True)\nclass SyncResult:\n    \"\"\"Result of a synchronous start/stop/restart operation.\n\n    Attributes:\n        operation: The :class:`SyncOperation` that was performed.\n        polls: Total number of status polls issued.\n        elapsed_seconds: Total wall-clock seconds from command to\n            target state confirmation.\n\n    \"\"\"\n\n    operation: SyncOperation\n    polls: int\n    elapsed_seconds: float\n</code></pre> <p>Mixin providing synchronous start/stop/restart wrappers.</p> <p>Each <code>*_sync</code> method issues the MQSC command then polls the corresponding <code>DISPLAY *STATUS</code> until the object reaches a stable state or the timeout expires.  <code>restart_*</code> methods perform a synchronous stop followed by a synchronous start.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>class MQRESTSyncMixin:\n    \"\"\"Mixin providing synchronous start/stop/restart wrappers.\n\n    Each ``*_sync`` method issues the MQSC command then polls the\n    corresponding ``DISPLAY *STATUS`` until the object reaches a\n    stable state or the timeout expires.  ``restart_*`` methods\n    perform a synchronous stop followed by a synchronous start.\n    \"\"\"\n\n    def _mqsc_command(  # noqa: PLR0913\n        self,\n        *,\n        command: str,\n        mqsc_qualifier: str,\n        name: str | None,\n        request_parameters: Mapping[str, object] | None,\n        response_parameters: Sequence[str] | None,\n        where: str | None = None,\n    ) -&gt; list[dict[str, object]]:\n        raise NotImplementedError  # pragma: no cover\n\n    # ------------------------------------------------------------------\n    # Channel\n    # ------------------------------------------------------------------\n\n    def start_channel_sync(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Start a channel and wait until it is running.\n\n        Args:\n            name: Channel name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with operation details.\n\n        Raises:\n            MQRESTTimeoutError: If the channel does not reach RUNNING\n                within the timeout.\n\n        \"\"\"\n        return self._start_and_poll(name, _CHANNEL_CONFIG, config)\n\n    def stop_channel_sync(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop a channel and wait until it is stopped.\n\n        Args:\n            name: Channel name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with operation details.\n\n        Raises:\n            MQRESTTimeoutError: If the channel does not reach STOPPED\n                within the timeout.\n\n        \"\"\"\n        return self._stop_and_poll(name, _CHANNEL_CONFIG, config)\n\n    def restart_channel(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop then start a channel, waiting for each phase.\n\n        Each phase gets the full timeout independently.\n\n        Args:\n            name: Channel name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with total polls and elapsed time\n            across both phases.\n\n        Raises:\n            MQRESTTimeoutError: If either phase exceeds the timeout.\n\n        \"\"\"\n        return self._restart(name, _CHANNEL_CONFIG, config)\n\n    # ------------------------------------------------------------------\n    # Listener\n    # ------------------------------------------------------------------\n\n    def start_listener_sync(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Start a listener and wait until it is running.\n\n        Args:\n            name: Listener name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with operation details.\n\n        Raises:\n            MQRESTTimeoutError: If the listener does not reach RUNNING\n                within the timeout.\n\n        \"\"\"\n        return self._start_and_poll(name, _LISTENER_CONFIG, config)\n\n    def stop_listener_sync(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop a listener and wait until it is stopped.\n\n        Args:\n            name: Listener name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with operation details.\n\n        Raises:\n            MQRESTTimeoutError: If the listener does not reach STOPPED\n                within the timeout.\n\n        \"\"\"\n        return self._stop_and_poll(name, _LISTENER_CONFIG, config)\n\n    def restart_listener(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop then start a listener, waiting for each phase.\n\n        Each phase gets the full timeout independently.\n\n        Args:\n            name: Listener name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with total polls and elapsed time\n            across both phases.\n\n        Raises:\n            MQRESTTimeoutError: If either phase exceeds the timeout.\n\n        \"\"\"\n        return self._restart(name, _LISTENER_CONFIG, config)\n\n    # ------------------------------------------------------------------\n    # Service\n    # ------------------------------------------------------------------\n\n    def start_service_sync(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Start a service and wait until it is running.\n\n        Args:\n            name: Service name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with operation details.\n\n        Raises:\n            MQRESTTimeoutError: If the service does not reach RUNNING\n                within the timeout.\n\n        \"\"\"\n        return self._start_and_poll(name, _SERVICE_CONFIG, config)\n\n    def stop_service_sync(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop a service and wait until it is stopped.\n\n        Args:\n            name: Service name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with operation details.\n\n        Raises:\n            MQRESTTimeoutError: If the service does not reach STOPPED\n                within the timeout.\n\n        \"\"\"\n        return self._stop_and_poll(name, _SERVICE_CONFIG, config)\n\n    def restart_service(\n        self,\n        name: str,\n        *,\n        config: SyncConfig | None = None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop then start a service, waiting for each phase.\n\n        Each phase gets the full timeout independently.\n\n        Args:\n            name: Service name.\n            config: Optional polling configuration.\n\n        Returns:\n            A :class:`SyncResult` with total polls and elapsed time\n            across both phases.\n\n        Raises:\n            MQRESTTimeoutError: If either phase exceeds the timeout.\n\n        \"\"\"\n        return self._restart(name, _SERVICE_CONFIG, config)\n\n    # ------------------------------------------------------------------\n    # Core polling helpers\n    # ------------------------------------------------------------------\n\n    def _start_and_poll(\n        self,\n        name: str,\n        obj_config: _ObjectTypeConfig,\n        config: SyncConfig | None,\n    ) -&gt; SyncResult:\n        \"\"\"Issue START then poll until the object is RUNNING.\"\"\"\n        cfg = config or SyncConfig()\n        self._mqsc_command(\n            command=\"START\",\n            mqsc_qualifier=obj_config.start_qualifier,\n            name=name,\n            request_parameters=None,\n            response_parameters=None,\n        )\n        polls = 0\n        start_time = time.monotonic()\n        while True:\n            time.sleep(cfg.poll_interval_seconds)\n            status_rows = self._mqsc_command(\n                command=\"DISPLAY\",\n                mqsc_qualifier=obj_config.status_qualifier,\n                name=name,\n                request_parameters=None,\n                response_parameters=[\"all\"],\n            )\n            polls += 1\n            if _has_status(status_rows, obj_config.status_keys, _RUNNING_VALUES):\n                elapsed = time.monotonic() - start_time\n                return SyncResult(SyncOperation.STARTED, polls=polls, elapsed_seconds=elapsed)\n            elapsed = time.monotonic() - start_time\n            if elapsed &gt;= cfg.timeout_seconds:\n                msg = f\"{obj_config.start_qualifier} '{name}' did not reach RUNNING within {cfg.timeout_seconds}s\"\n                raise MQRESTTimeoutError(\n                    msg,\n                    name=name,\n                    operation=\"start\",\n                    elapsed=elapsed,\n                )\n\n    def _stop_and_poll(\n        self,\n        name: str,\n        obj_config: _ObjectTypeConfig,\n        config: SyncConfig | None,\n    ) -&gt; SyncResult:\n        \"\"\"Issue STOP then poll until the object is STOPPED.\"\"\"\n        cfg = config or SyncConfig()\n        self._mqsc_command(\n            command=\"STOP\",\n            mqsc_qualifier=obj_config.stop_qualifier,\n            name=name,\n            request_parameters=None,\n            response_parameters=None,\n        )\n        polls = 0\n        start_time = time.monotonic()\n        while True:\n            time.sleep(cfg.poll_interval_seconds)\n            status_rows = self._mqsc_command(\n                command=\"DISPLAY\",\n                mqsc_qualifier=obj_config.status_qualifier,\n                name=name,\n                request_parameters=None,\n                response_parameters=[\"all\"],\n            )\n            polls += 1\n            if obj_config.empty_means_stopped and not status_rows:\n                elapsed = time.monotonic() - start_time\n                return SyncResult(SyncOperation.STOPPED, polls=polls, elapsed_seconds=elapsed)\n            if _has_status(status_rows, obj_config.status_keys, _STOPPED_VALUES):\n                elapsed = time.monotonic() - start_time\n                return SyncResult(SyncOperation.STOPPED, polls=polls, elapsed_seconds=elapsed)\n            elapsed = time.monotonic() - start_time\n            if elapsed &gt;= cfg.timeout_seconds:\n                msg = f\"{obj_config.stop_qualifier} '{name}' did not reach STOPPED within {cfg.timeout_seconds}s\"\n                raise MQRESTTimeoutError(\n                    msg,\n                    name=name,\n                    operation=\"stop\",\n                    elapsed=elapsed,\n                )\n\n    def _restart(\n        self,\n        name: str,\n        obj_config: _ObjectTypeConfig,\n        config: SyncConfig | None,\n    ) -&gt; SyncResult:\n        \"\"\"Stop-sync then start-sync, returning combined totals.\"\"\"\n        stop_result = self._stop_and_poll(name, obj_config, config)\n        start_result = self._start_and_poll(name, obj_config, config)\n        return SyncResult(\n            SyncOperation.RESTARTED,\n            polls=stop_result.polls + start_result.polls,\n            elapsed_seconds=stop_result.elapsed_seconds + start_result.elapsed_seconds,\n        )\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.SyncConfig.timeout_seconds","title":"<code>timeout_seconds = 30.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncConfig.poll_interval_seconds","title":"<code>poll_interval_seconds = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncConfig.__init__","title":"<code>__init__(timeout_seconds=30.0, poll_interval_seconds=1.0)</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncOperation.STARTED","title":"<code>STARTED = 'started'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncOperation.STOPPED","title":"<code>STOPPED = 'stopped'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncOperation.RESTARTED","title":"<code>RESTARTED = 'restarted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncResult.operation","title":"<code>operation</code>  <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncResult.polls","title":"<code>polls</code>  <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncResult.elapsed_seconds","title":"<code>elapsed_seconds</code>  <code>instance-attribute</code>","text":""},{"location":"api/sync/#pymqrest.sync.SyncResult.__init__","title":"<code>__init__(operation, polls, elapsed_seconds)</code>","text":""},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin._mqsc_command","title":"<code>_mqsc_command(*, command, mqsc_qualifier, name, request_parameters, response_parameters, where=None)</code>","text":"Source code in <code>src/pymqrest/sync.py</code> <pre><code>def _mqsc_command(  # noqa: PLR0913\n    self,\n    *,\n    command: str,\n    mqsc_qualifier: str,\n    name: str | None,\n    request_parameters: Mapping[str, object] | None,\n    response_parameters: Sequence[str] | None,\n    where: str | None = None,\n) -&gt; list[dict[str, object]]:\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.start_channel_sync","title":"<code>start_channel_sync(name, *, config=None)</code>","text":"<p>Start a channel and wait until it is running.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Channel name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with operation details.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If the channel does not reach RUNNING within the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def start_channel_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Start a channel and wait until it is running.\n\n    Args:\n        name: Channel name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with operation details.\n\n    Raises:\n        MQRESTTimeoutError: If the channel does not reach RUNNING\n            within the timeout.\n\n    \"\"\"\n    return self._start_and_poll(name, _CHANNEL_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.stop_channel_sync","title":"<code>stop_channel_sync(name, *, config=None)</code>","text":"<p>Stop a channel and wait until it is stopped.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Channel name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with operation details.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If the channel does not reach STOPPED within the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def stop_channel_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Stop a channel and wait until it is stopped.\n\n    Args:\n        name: Channel name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with operation details.\n\n    Raises:\n        MQRESTTimeoutError: If the channel does not reach STOPPED\n            within the timeout.\n\n    \"\"\"\n    return self._stop_and_poll(name, _CHANNEL_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.restart_channel","title":"<code>restart_channel(name, *, config=None)</code>","text":"<p>Stop then start a channel, waiting for each phase.</p> <p>Each phase gets the full timeout independently.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Channel name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with total polls and elapsed time</p> <code>SyncResult</code> <p>across both phases.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If either phase exceeds the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def restart_channel(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Stop then start a channel, waiting for each phase.\n\n    Each phase gets the full timeout independently.\n\n    Args:\n        name: Channel name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with total polls and elapsed time\n        across both phases.\n\n    Raises:\n        MQRESTTimeoutError: If either phase exceeds the timeout.\n\n    \"\"\"\n    return self._restart(name, _CHANNEL_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.start_listener_sync","title":"<code>start_listener_sync(name, *, config=None)</code>","text":"<p>Start a listener and wait until it is running.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Listener name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with operation details.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If the listener does not reach RUNNING within the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def start_listener_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Start a listener and wait until it is running.\n\n    Args:\n        name: Listener name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with operation details.\n\n    Raises:\n        MQRESTTimeoutError: If the listener does not reach RUNNING\n            within the timeout.\n\n    \"\"\"\n    return self._start_and_poll(name, _LISTENER_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.stop_listener_sync","title":"<code>stop_listener_sync(name, *, config=None)</code>","text":"<p>Stop a listener and wait until it is stopped.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Listener name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with operation details.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If the listener does not reach STOPPED within the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def stop_listener_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Stop a listener and wait until it is stopped.\n\n    Args:\n        name: Listener name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with operation details.\n\n    Raises:\n        MQRESTTimeoutError: If the listener does not reach STOPPED\n            within the timeout.\n\n    \"\"\"\n    return self._stop_and_poll(name, _LISTENER_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.restart_listener","title":"<code>restart_listener(name, *, config=None)</code>","text":"<p>Stop then start a listener, waiting for each phase.</p> <p>Each phase gets the full timeout independently.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Listener name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with total polls and elapsed time</p> <code>SyncResult</code> <p>across both phases.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If either phase exceeds the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def restart_listener(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Stop then start a listener, waiting for each phase.\n\n    Each phase gets the full timeout independently.\n\n    Args:\n        name: Listener name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with total polls and elapsed time\n        across both phases.\n\n    Raises:\n        MQRESTTimeoutError: If either phase exceeds the timeout.\n\n    \"\"\"\n    return self._restart(name, _LISTENER_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.start_service_sync","title":"<code>start_service_sync(name, *, config=None)</code>","text":"<p>Start a service and wait until it is running.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Service name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with operation details.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If the service does not reach RUNNING within the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def start_service_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Start a service and wait until it is running.\n\n    Args:\n        name: Service name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with operation details.\n\n    Raises:\n        MQRESTTimeoutError: If the service does not reach RUNNING\n            within the timeout.\n\n    \"\"\"\n    return self._start_and_poll(name, _SERVICE_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.stop_service_sync","title":"<code>stop_service_sync(name, *, config=None)</code>","text":"<p>Stop a service and wait until it is stopped.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Service name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with operation details.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If the service does not reach STOPPED within the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def stop_service_sync(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Stop a service and wait until it is stopped.\n\n    Args:\n        name: Service name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with operation details.\n\n    Raises:\n        MQRESTTimeoutError: If the service does not reach STOPPED\n            within the timeout.\n\n    \"\"\"\n    return self._stop_and_poll(name, _SERVICE_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin.restart_service","title":"<code>restart_service(name, *, config=None)</code>","text":"<p>Stop then start a service, waiting for each phase.</p> <p>Each phase gets the full timeout independently.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Service name.</p> required <code>config</code> <code>SyncConfig | None</code> <p>Optional polling configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>A</code> <code>SyncResult</code> <p>class:<code>SyncResult</code> with total polls and elapsed time</p> <code>SyncResult</code> <p>across both phases.</p> <p>Raises:</p> Type Description <code>MQRESTTimeoutError</code> <p>If either phase exceeds the timeout.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def restart_service(\n    self,\n    name: str,\n    *,\n    config: SyncConfig | None = None,\n) -&gt; SyncResult:\n    \"\"\"Stop then start a service, waiting for each phase.\n\n    Each phase gets the full timeout independently.\n\n    Args:\n        name: Service name.\n        config: Optional polling configuration.\n\n    Returns:\n        A :class:`SyncResult` with total polls and elapsed time\n        across both phases.\n\n    Raises:\n        MQRESTTimeoutError: If either phase exceeds the timeout.\n\n    \"\"\"\n    return self._restart(name, _SERVICE_CONFIG, config)\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin._start_and_poll","title":"<code>_start_and_poll(name, obj_config, config)</code>","text":"<p>Issue START then poll until the object is RUNNING.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def _start_and_poll(\n    self,\n    name: str,\n    obj_config: _ObjectTypeConfig,\n    config: SyncConfig | None,\n) -&gt; SyncResult:\n    \"\"\"Issue START then poll until the object is RUNNING.\"\"\"\n    cfg = config or SyncConfig()\n    self._mqsc_command(\n        command=\"START\",\n        mqsc_qualifier=obj_config.start_qualifier,\n        name=name,\n        request_parameters=None,\n        response_parameters=None,\n    )\n    polls = 0\n    start_time = time.monotonic()\n    while True:\n        time.sleep(cfg.poll_interval_seconds)\n        status_rows = self._mqsc_command(\n            command=\"DISPLAY\",\n            mqsc_qualifier=obj_config.status_qualifier,\n            name=name,\n            request_parameters=None,\n            response_parameters=[\"all\"],\n        )\n        polls += 1\n        if _has_status(status_rows, obj_config.status_keys, _RUNNING_VALUES):\n            elapsed = time.monotonic() - start_time\n            return SyncResult(SyncOperation.STARTED, polls=polls, elapsed_seconds=elapsed)\n        elapsed = time.monotonic() - start_time\n        if elapsed &gt;= cfg.timeout_seconds:\n            msg = f\"{obj_config.start_qualifier} '{name}' did not reach RUNNING within {cfg.timeout_seconds}s\"\n            raise MQRESTTimeoutError(\n                msg,\n                name=name,\n                operation=\"start\",\n                elapsed=elapsed,\n            )\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin._stop_and_poll","title":"<code>_stop_and_poll(name, obj_config, config)</code>","text":"<p>Issue STOP then poll until the object is STOPPED.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def _stop_and_poll(\n    self,\n    name: str,\n    obj_config: _ObjectTypeConfig,\n    config: SyncConfig | None,\n) -&gt; SyncResult:\n    \"\"\"Issue STOP then poll until the object is STOPPED.\"\"\"\n    cfg = config or SyncConfig()\n    self._mqsc_command(\n        command=\"STOP\",\n        mqsc_qualifier=obj_config.stop_qualifier,\n        name=name,\n        request_parameters=None,\n        response_parameters=None,\n    )\n    polls = 0\n    start_time = time.monotonic()\n    while True:\n        time.sleep(cfg.poll_interval_seconds)\n        status_rows = self._mqsc_command(\n            command=\"DISPLAY\",\n            mqsc_qualifier=obj_config.status_qualifier,\n            name=name,\n            request_parameters=None,\n            response_parameters=[\"all\"],\n        )\n        polls += 1\n        if obj_config.empty_means_stopped and not status_rows:\n            elapsed = time.monotonic() - start_time\n            return SyncResult(SyncOperation.STOPPED, polls=polls, elapsed_seconds=elapsed)\n        if _has_status(status_rows, obj_config.status_keys, _STOPPED_VALUES):\n            elapsed = time.monotonic() - start_time\n            return SyncResult(SyncOperation.STOPPED, polls=polls, elapsed_seconds=elapsed)\n        elapsed = time.monotonic() - start_time\n        if elapsed &gt;= cfg.timeout_seconds:\n            msg = f\"{obj_config.stop_qualifier} '{name}' did not reach STOPPED within {cfg.timeout_seconds}s\"\n            raise MQRESTTimeoutError(\n                msg,\n                name=name,\n                operation=\"stop\",\n                elapsed=elapsed,\n            )\n</code></pre>"},{"location":"api/sync/#pymqrest.sync.MQRESTSyncMixin._restart","title":"<code>_restart(name, obj_config, config)</code>","text":"<p>Stop-sync then start-sync, returning combined totals.</p> Source code in <code>src/pymqrest/sync.py</code> <pre><code>def _restart(\n    self,\n    name: str,\n    obj_config: _ObjectTypeConfig,\n    config: SyncConfig | None,\n) -&gt; SyncResult:\n    \"\"\"Stop-sync then start-sync, returning combined totals.\"\"\"\n    stop_result = self._stop_and_poll(name, obj_config, config)\n    start_result = self._start_and_poll(name, obj_config, config)\n    return SyncResult(\n        SyncOperation.RESTARTED,\n        polls=stop_result.polls + start_result.polls,\n        elapsed_seconds=stop_result.elapsed_seconds + start_result.elapsed_seconds,\n    )\n</code></pre>"},{"location":"api/transport/","title":"Transport","text":""},{"location":"api/transport/#overview","title":"Overview","text":"<p>The transport layer abstracts HTTP communication from the session logic. The session builds <code>runCommandJSON</code> payloads and delegates HTTP delivery to a transport implementation. This separation enables testing the entire command pipeline without an MQ server by injecting a mock transport.</p>"},{"location":"api/transport/#mqresttransport","title":"MQRESTTransport","text":"<p>The transport protocol defines a single method for posting JSON payloads:</p> <p>               Bases: <code>Protocol</code></p> <p>Protocol for MQ REST transport implementations.</p> <p>Implement this protocol to provide a custom HTTP transport (e.g. for testing or for an alternative HTTP client library). The default implementation is :class:<code>RequestsTransport</code>.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>class MQRESTTransport(Protocol):\n    \"\"\"Protocol for MQ REST transport implementations.\n\n    Implement this protocol to provide a custom HTTP transport\n    (e.g. for testing or for an alternative HTTP client library).\n    The default implementation is :class:`RequestsTransport`.\n    \"\"\"\n\n    def post_json(\n        self,\n        url: str,\n        payload: Mapping[str, object],\n        *,\n        headers: Mapping[str, str],\n        timeout_seconds: float | None,\n        verify_tls: bool,\n    ) -&gt; TransportResponse:\n        \"\"\"Send a JSON payload via HTTP POST and return the response.\n\n        Args:\n            url: The fully-qualified URL to POST to.\n            payload: The JSON-serialisable request body.\n            headers: HTTP headers to include in the request.\n            timeout_seconds: Request timeout in seconds, or ``None``\n                for no timeout.\n            verify_tls: Whether to verify the server's TLS certificate.\n\n        Returns:\n            A :class:`TransportResponse` with the status code, body\n            text, and response headers.\n\n        Raises:\n            MQRESTTransportError: If the request cannot be completed.\n\n        \"\"\"\n</code></pre>"},{"location":"api/transport/#pymqrest.session.MQRESTTransport.post_json","title":"<code>post_json(url, payload, *, headers, timeout_seconds, verify_tls)</code>","text":"<p>Send a JSON payload via HTTP POST and return the response.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The fully-qualified URL to POST to.</p> required <code>payload</code> <code>Mapping[str, object]</code> <p>The JSON-serialisable request body.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>HTTP headers to include in the request.</p> required <code>timeout_seconds</code> <code>float | None</code> <p>Request timeout in seconds, or <code>None</code> for no timeout.</p> required <code>verify_tls</code> <code>bool</code> <p>Whether to verify the server's TLS certificate.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>TransportResponse</code> <p>class:<code>TransportResponse</code> with the status code, body</p> <code>TransportResponse</code> <p>text, and response headers.</p> <p>Raises:</p> Type Description <code>MQRESTTransportError</code> <p>If the request cannot be completed.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>def post_json(\n    self,\n    url: str,\n    payload: Mapping[str, object],\n    *,\n    headers: Mapping[str, str],\n    timeout_seconds: float | None,\n    verify_tls: bool,\n) -&gt; TransportResponse:\n    \"\"\"Send a JSON payload via HTTP POST and return the response.\n\n    Args:\n        url: The fully-qualified URL to POST to.\n        payload: The JSON-serialisable request body.\n        headers: HTTP headers to include in the request.\n        timeout_seconds: Request timeout in seconds, or ``None``\n            for no timeout.\n        verify_tls: Whether to verify the server's TLS certificate.\n\n    Returns:\n        A :class:`TransportResponse` with the status code, body\n        text, and response headers.\n\n    Raises:\n        MQRESTTransportError: If the request cannot be completed.\n\n    \"\"\"\n</code></pre>"},{"location":"api/transport/#transportresponse","title":"TransportResponse","text":"<p>An immutable result containing the HTTP response data:</p> <p>Container for the raw HTTP response returned by a transport.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The HTTP status code (e.g. <code>200</code>, <code>401</code>).</p> <code>text</code> <code>str</code> <p>The response body as text.</p> <code>headers</code> <code>Mapping[str, str]</code> <p>The response headers as a string-to-string mapping.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>@dataclass(frozen=True)\nclass TransportResponse:\n    \"\"\"Container for the raw HTTP response returned by a transport.\n\n    Attributes:\n        status_code: The HTTP status code (e.g. ``200``, ``401``).\n        text: The response body as text.\n        headers: The response headers as a string-to-string mapping.\n\n    \"\"\"\n\n    status_code: int\n    text: str\n    headers: Mapping[str, str]\n</code></pre>"},{"location":"api/transport/#pymqrest.session.TransportResponse.status_code","title":"<code>status_code</code>  <code>instance-attribute</code>","text":""},{"location":"api/transport/#pymqrest.session.TransportResponse.text","title":"<code>text</code>  <code>instance-attribute</code>","text":""},{"location":"api/transport/#pymqrest.session.TransportResponse.headers","title":"<code>headers</code>  <code>instance-attribute</code>","text":""},{"location":"api/transport/#pymqrest.session.TransportResponse.__init__","title":"<code>__init__(status_code, text, headers)</code>","text":""},{"location":"api/transport/#requeststransport","title":"RequestsTransport","text":"<p>The default transport implementation using the <code>requests</code> library:</p> <p>Default :class:<code>MQRESTTransport</code> implementation using <code>requests</code>.</p> <p>Wraps a :class:<code>requests.Session</code> to handle JSON POST requests to the MQ REST API. Connection-level errors are translated into :class:<code>~pymqrest.exceptions.MQRESTTransportError</code>.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>class RequestsTransport:\n    \"\"\"Default :class:`MQRESTTransport` implementation using ``requests``.\n\n    Wraps a :class:`requests.Session` to handle JSON POST requests\n    to the MQ REST API. Connection-level errors are translated into\n    :class:`~pymqrest.exceptions.MQRESTTransportError`.\n    \"\"\"\n\n    def __init__(\n        self,\n        session: requests.Session | None = None,\n        *,\n        client_cert: tuple[str, str] | str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the transport.\n\n        Args:\n            session: An existing :class:`requests.Session` to reuse,\n                or ``None`` to create a new one.\n            client_cert: Client certificate for mutual TLS. Either a\n                path to a combined cert/key PEM file, or a\n                ``(cert_path, key_path)`` tuple.\n\n        \"\"\"\n        self._session = session or requests.Session()\n        if client_cert is not None:\n            self._session.cert = client_cert\n\n    def post_json(\n        self,\n        url: str,\n        payload: Mapping[str, object],\n        *,\n        headers: Mapping[str, str],\n        timeout_seconds: float | None,\n        verify_tls: bool,\n    ) -&gt; TransportResponse:\n        \"\"\"Send a JSON payload via HTTP POST and return the response.\n\n        Args:\n            url: The fully-qualified URL to POST to.\n            payload: The JSON-serialisable request body.\n            headers: HTTP headers to include in the request.\n            timeout_seconds: Request timeout in seconds, or ``None``\n                for no timeout.\n            verify_tls: Whether to verify the server's TLS certificate.\n\n        Returns:\n            A :class:`TransportResponse` with the status code, body\n            text, and response headers.\n\n        Raises:\n            MQRESTTransportError: If the underlying ``requests`` call\n                raises a :class:`~requests.RequestException`.\n\n        \"\"\"\n        try:\n            response = self._session.post(\n                url,\n                json=dict(payload),\n                headers=dict(headers),\n                timeout=timeout_seconds,\n                verify=verify_tls,\n            )\n        except RequestException as error:\n            raise MQRESTTransportError(ERROR_TRANSPORT_FAILURE, url=url) from error\n        return TransportResponse(\n            status_code=response.status_code,\n            text=response.text,\n            headers=dict(response.headers.items()),\n        )\n</code></pre>"},{"location":"api/transport/#pymqrest.session.RequestsTransport._session","title":"<code>_session = session or requests.Session()</code>  <code>instance-attribute</code>","text":""},{"location":"api/transport/#pymqrest.session.RequestsTransport.__init__","title":"<code>__init__(session=None, *, client_cert=None)</code>","text":"<p>Initialize the transport.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session | None</code> <p>An existing :class:<code>requests.Session</code> to reuse, or <code>None</code> to create a new one.</p> <code>None</code> <code>client_cert</code> <code>tuple[str, str] | str | None</code> <p>Client certificate for mutual TLS. Either a path to a combined cert/key PEM file, or a <code>(cert_path, key_path)</code> tuple.</p> <code>None</code> Source code in <code>src/pymqrest/session.py</code> <pre><code>def __init__(\n    self,\n    session: requests.Session | None = None,\n    *,\n    client_cert: tuple[str, str] | str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the transport.\n\n    Args:\n        session: An existing :class:`requests.Session` to reuse,\n            or ``None`` to create a new one.\n        client_cert: Client certificate for mutual TLS. Either a\n            path to a combined cert/key PEM file, or a\n            ``(cert_path, key_path)`` tuple.\n\n    \"\"\"\n    self._session = session or requests.Session()\n    if client_cert is not None:\n        self._session.cert = client_cert\n</code></pre>"},{"location":"api/transport/#pymqrest.session.RequestsTransport.post_json","title":"<code>post_json(url, payload, *, headers, timeout_seconds, verify_tls)</code>","text":"<p>Send a JSON payload via HTTP POST and return the response.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The fully-qualified URL to POST to.</p> required <code>payload</code> <code>Mapping[str, object]</code> <p>The JSON-serialisable request body.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>HTTP headers to include in the request.</p> required <code>timeout_seconds</code> <code>float | None</code> <p>Request timeout in seconds, or <code>None</code> for no timeout.</p> required <code>verify_tls</code> <code>bool</code> <p>Whether to verify the server's TLS certificate.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>TransportResponse</code> <p>class:<code>TransportResponse</code> with the status code, body</p> <code>TransportResponse</code> <p>text, and response headers.</p> <p>Raises:</p> Type Description <code>MQRESTTransportError</code> <p>If the underlying <code>requests</code> call raises a :class:<code>~requests.RequestException</code>.</p> Source code in <code>src/pymqrest/session.py</code> <pre><code>def post_json(\n    self,\n    url: str,\n    payload: Mapping[str, object],\n    *,\n    headers: Mapping[str, str],\n    timeout_seconds: float | None,\n    verify_tls: bool,\n) -&gt; TransportResponse:\n    \"\"\"Send a JSON payload via HTTP POST and return the response.\n\n    Args:\n        url: The fully-qualified URL to POST to.\n        payload: The JSON-serialisable request body.\n        headers: HTTP headers to include in the request.\n        timeout_seconds: Request timeout in seconds, or ``None``\n            for no timeout.\n        verify_tls: Whether to verify the server's TLS certificate.\n\n    Returns:\n        A :class:`TransportResponse` with the status code, body\n        text, and response headers.\n\n    Raises:\n        MQRESTTransportError: If the underlying ``requests`` call\n            raises a :class:`~requests.RequestException`.\n\n    \"\"\"\n    try:\n        response = self._session.post(\n            url,\n            json=dict(payload),\n            headers=dict(headers),\n            timeout=timeout_seconds,\n            verify=verify_tls,\n        )\n    except RequestException as error:\n        raise MQRESTTransportError(ERROR_TRANSPORT_FAILURE, url=url) from error\n    return TransportResponse(\n        status_code=response.status_code,\n        text=response.text,\n        headers=dict(response.headers.items()),\n    )\n</code></pre>"},{"location":"api/transport/#custom-transport","title":"Custom transport","text":"<p>Implement the <code>MQRESTTransport</code> protocol to provide custom HTTP behavior or for testing. Because the protocol has a single method, a mock works naturally:</p> <pre><code>from unittest.mock import MagicMock\nfrom pymqrest.session import MQRESTTransport, TransportResponse\n\nmock_transport = MagicMock(spec=MQRESTTransport)\nmock_transport.post_json.return_value = TransportResponse(\n    status_code=200,\n    text='{\"commandResponse\": []}',\n    headers={},\n)\n\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM1\",\n    credentials=LTPAAuth(\"admin\", \"passw0rd\"),\n    transport=mock_transport,\n)\n</code></pre> <p>This pattern is used extensively in the library's own test suite to verify command payload construction, response parsing, and error handling without network access.</p>"},{"location":"design/","title":"Design","text":"<p>Architecture and design decisions behind <code>pymqrest</code>.</p> <ul> <li>Rationale \u2014 Why the library exists and key design choices</li> <li>runCommandJSON Endpoint \u2014 The IBM MQ REST API endpoint that pymqrest wraps</li> <li>Nested Object Flattening \u2014 How nested response structures are normalized</li> </ul>"},{"location":"design/nested-object-flattening/","title":"Nested Object Flattening","text":""},{"location":"design/nested-object-flattening/#problem-statement","title":"Problem statement","text":"<p>Most MQSC commands return a flat list of parameter objects \u2014 one map per matched MQ object. However, two commands return a nested structure when queried with <code>TYPE(HANDLE)</code>:</p> <ul> <li><code>DISPLAY CONN TYPE(HANDLE)</code> \u2014 connection handles</li> <li><code>DISPLAY QSTATUS TYPE(HANDLE)</code> \u2014 queue status handles</li> </ul> <p>In these responses each <code>commandResponse</code> item represents a parent entity (a connection or a queue) that may own multiple handles. The per-handle attributes are nested inside an <code>objects</code> array, while parent-scoped attributes sit alongside it.</p> <p>Without intervention this would force every caller to detect and unpack the nesting manually. The library instead applies transparent flattening so that all commands \u2014 nested or not \u2014 return uniform flat maps.</p>"},{"location":"design/nested-object-flattening/#raw-api-response-format","title":"Raw API response format","text":"<p>A <code>DISPLAY CONN TYPE(HANDLE)</code> response with two handles looks like this:</p> <pre><code>{\n  \"commandResponse\": [\n    {\n      \"completionCode\": 0,\n      \"reasonCode\": 0,\n      \"parameters\": {\n        \"conn\": \"A1B2C3D4E5F6\",\n        \"extconn\": \"G7H8I9J0K1L2\",\n        \"objects\": [\n          {\"objname\": \"MY.QUEUE\", \"hstate\": \"ACTIVE\", \"openopts\": 8225},\n          {\"objname\": \"MY.OTHER.QUEUE\", \"hstate\": \"INACTIVE\", \"openopts\": 8193}\n        ]\n      }\n    }\n  ],\n  \"overallCompletionCode\": 0,\n  \"overallReasonCode\": 0\n}\n</code></pre> Level Keys Description Parent <code>conn</code>, <code>extconn</code> Connection-scoped attributes shared by all handles Nested <code>objname</code>, <code>hstate</code>, <code>openopts</code> Per-handle attributes inside <code>objects</code>"},{"location":"design/nested-object-flattening/#flattening-algorithm","title":"Flattening algorithm","text":"<p>The flattening function processes the parameter objects list after extraction from the response but before attribute mapping:</p> <ol> <li>For each parameter map, check whether an <code>objects</code> key exists and its value    is a list.</li> <li>If yes: collect all other keys into a shared map, then for each    map-typed entry in <code>objects</code>, merge shared + nested item to produce a flat    output row. Non-map entries in <code>objects</code> are silently skipped.</li> <li>If no (the key is absent, or the value is not a list): pass the item    through unchanged.</li> </ol> <p>Nested-item keys override any same-named parent keys in the merge.</p>"},{"location":"design/nested-object-flattening/#flattened-result","title":"Flattened result","text":"<p>After flattening, the example above produces two flat maps:</p> <pre><code>[\n  {\n    \"conn\": \"A1B2C3D4E5F6\",\n    \"extconn\": \"G7H8I9J0K1L2\",\n    \"objname\": \"MY.QUEUE\",\n    \"hstate\": \"ACTIVE\",\n    \"openopts\": 8225\n  },\n  {\n    \"conn\": \"A1B2C3D4E5F6\",\n    \"extconn\": \"G7H8I9J0K1L2\",\n    \"objname\": \"MY.OTHER.QUEUE\",\n    \"hstate\": \"INACTIVE\",\n    \"openopts\": 8193\n  }\n]\n</code></pre>"},{"location":"design/nested-object-flattening/#edge-cases","title":"Edge cases","text":"Scenario Behaviour Empty <code>objects</code> list Parent produces no output rows <code>objects</code> value is not a list (e.g. a string) Item passes through unchanged Mixed flat and nested items in the same response Both handled correctly Non-map entries inside <code>objects</code> array Silently skipped Single nested entry Produces one flat map"},{"location":"design/nested-object-flattening/#where-flattening-occurs-in-the-pipeline","title":"Where flattening occurs in the pipeline","text":"<pre><code>HTTP response\n  \u2192 JSON parse\n  \u2192 extract commandResponse items\n  \u2192 collect parameter maps\n  \u2192 flatten nested objects          \u2190 here\n  \u2192 normalise attribute case\n  \u2192 map response (if mapping enabled)\n  \u2192 return to caller\n</code></pre> <p>Flattening happens before attribute mapping so that the mapping layer sees a uniform list of flat maps regardless of the original response shape.</p>"},{"location":"design/rationale/","title":"Design Rationale","text":""},{"location":"design/rationale/#why-wrap-the-rest-api","title":"Why wrap the REST API","text":"<p>IBM MQ provides an administrative REST API, but working with it directly requires constructing JSON payloads with MQSC-specific parameter names, handling CSRF tokens, parsing nested response structures, and interpreting completion/reason code pairs.</p> <p>The library wraps this complexity behind methods that map 1:1 to MQSC commands, translate attribute names to developer-friendly conventions, and surface errors as exceptions with full diagnostic context.</p>"},{"location":"design/rationale/#single-endpoint-design","title":"Single-endpoint design","text":"<p>All MQSC operations go through a single REST endpoint:</p> <pre><code>POST /ibmmq/rest/v2/admin/action/qmgr/{qmgr}/mqsc\n</code></pre> <p>The <code>runCommandJSON</code> payload structure carries the command verb, qualifier, object name, and parameters:</p> <pre><code>{\n  \"type\": \"runCommandJSON\",\n  \"command\": \"DISPLAY\",\n  \"qualifier\": \"QLOCAL\",\n  \"name\": \"MY.QUEUE\",\n  \"responseParameters\": [\"all\"]\n}\n</code></pre> <p>This means the library needs exactly one HTTP method, one URL pattern, and one payload schema to cover the entire MQSC command surface.</p>"},{"location":"design/rationale/#method-naming-conventions","title":"Method naming conventions","text":"<p>Command methods follow the pattern <code>&lt;verb&gt;_&lt;qualifier&gt;</code> (or <code>&lt;verb&gt;&lt;Qualifier&gt;</code> in camelCase languages) in lowercase with spaces converted to underscores or camelCase boundaries:</p> MQSC command Method name pattern <code>DISPLAY QUEUE</code> <code>display_queue</code> / <code>displayQueue</code> <code>DEFINE QLOCAL</code> <code>define_qlocal</code> / <code>defineQlocal</code> <code>DELETE CHANNEL</code> <code>delete_channel</code> / <code>deleteChannel</code> <code>ALTER QMGR</code> <code>alter_qmgr</code> / <code>alterQmgr</code> <p>This convention provides a predictable, discoverable API without inventing new abstractions over the MQSC command set.</p>"},{"location":"design/rationale/#return-shape-decisions","title":"Return shape decisions","text":"<p>DISPLAY commands return a list of attribute maps. An empty list means no objects matched \u2014 this is not an error. The caller can iterate without checking for null/None.</p> <p>Queue manager singletons (display queue manager status, etc.) return a single attribute map or null/None. These commands always return zero or one result, so a list would be misleading.</p> <p>Non-DISPLAY commands (DEFINE, DELETE, ALTER, etc.) return nothing on success and raise an exception on failure.</p>"},{"location":"design/rationale/#attribute-mapping-complexity","title":"Attribute mapping complexity","text":"<p>The mapping layer is the most complex part of the library. This complexity exists because IBM MQ uses terse uppercase tokens (<code>CURDEPTH</code>, <code>DEFPSIST</code>, <code>CHLTYPE</code>) that are unfriendly in application code. The mapping pipeline translates these to readable names (<code>current_depth</code>, <code>default_persistence</code>, <code>channel_type</code>) and back.</p> <p>The translation is not a simple case conversion. The mapping tables were originally bootstrapped from IBM MQ 9.4 documentation, then customized and rationalized. They contain:</p> <ul> <li>Key maps: Attribute name translations (e.g. <code>CURDEPTH</code> \u2194 <code>current_depth</code>).</li> <li>Value maps: Enumerated value translations (e.g. <code>\"YES\"</code> \u2194 <code>\"yes\"</code>,   <code>\"SVRCONN\"</code> \u2194 <code>\"server_connection\"</code>).</li> <li>Key-value maps: Cases where both key and value change together.</li> </ul>"},{"location":"design/runcommand-endpoint/","title":"The runCommandJSON Endpoint","text":""},{"location":"design/runcommand-endpoint/#payload-structure","title":"Payload structure","text":"<p>The IBM MQ administrative REST API provides a <code>runCommandJSON</code> endpoint that accepts MQSC commands as structured JSON:</p> <pre><code>POST /ibmmq/rest/v2/admin/action/qmgr/{qmgr}/mqsc\n</code></pre> <p>The request payload has this shape:</p> <pre><code>{\n  \"type\": \"runCommandJSON\",\n  \"command\": \"DISPLAY\",\n  \"qualifier\": \"QLOCAL\",\n  \"name\": \"MY.QUEUE\",\n  \"parameters\": {\n    \"DESCR\": \"Updated description\"\n  },\n  \"responseParameters\": [\"all\"]\n}\n</code></pre> Field Required Description <code>type</code> Yes Always <code>\"runCommandJSON\"</code> <code>command</code> Yes MQSC verb: <code>DISPLAY</code>, <code>DEFINE</code>, <code>DELETE</code>, <code>ALTER</code>, etc. <code>qualifier</code> Yes Object type: <code>QLOCAL</code>, <code>CHANNEL</code>, <code>QMGR</code>, etc. <code>name</code> No Object name or pattern. Omitted for queue manager commands. <code>parameters</code> No Request attributes as key-value pairs. <code>responseParameters</code> No List of attribute names to return."},{"location":"design/runcommand-endpoint/#response-structure","title":"Response structure","text":"<p>The response contains an array of command results:</p> <pre><code>{\n  \"commandResponse\": [\n    {\n      \"completionCode\": 0,\n      \"reasonCode\": 0,\n      \"parameters\": {\n        \"queue\": \"MY.QUEUE\",\n        \"curdepth\": 0,\n        \"maxdepth\": 5000\n      }\n    }\n  ],\n  \"overallCompletionCode\": 0,\n  \"overallReasonCode\": 0\n}\n</code></pre> <p>Each item in <code>commandResponse</code> represents one matched object and carries its own completion/reason code pair plus a <code>parameters</code> map.</p>"},{"location":"design/runcommand-endpoint/#error-handling","title":"Error handling","text":"<p>Errors are indicated by non-zero completion and reason codes at two levels:</p> <p>Overall codes: <code>overallCompletionCode</code> and <code>overallReasonCode</code> on the top-level response. A non-zero overall code means the command itself failed.</p> <p>Per-item codes: Each <code>commandResponse</code> item has <code>completionCode</code> and <code>reasonCode</code>. These indicate per-object errors (e.g. object not found in a wildcard display).</p> <p>For <code>DISPLAY</code> commands with no matches, MQ returns an error response with reason code 2085 (MQRC_UNKNOWN_OBJECT_NAME). The library intentionally treats this as an empty list rather than an exception.</p>"},{"location":"design/runcommand-endpoint/#csrf-tokens","title":"CSRF tokens","text":"<p>The MQ REST API requires a CSRF token header for non-GET requests. The library sends <code>ibm-mq-rest-csrf-token</code> with a default value. This can be overridden at session creation or omitted entirely.</p>"},{"location":"design/runcommand-endpoint/#authentication","title":"Authentication","text":"<p>The library supports HTTP Basic authentication as the primary method. The <code>Authorization</code> header is constructed from the username and password provided at session creation. Additional authentication methods (client certificates, LTPA tokens) may be supported depending on the language implementation.</p>"},{"location":"development/","title":"Development","text":"<p>Guides for contributing to and developing <code>pymqrest</code>.</p> <ul> <li>Developer Setup \u2014 Environment setup and prerequisites</li> <li>Contributing \u2014 Contribution guidelines</li> <li>Local MQ Container \u2014 Docker-based MQ environment for testing</li> <li>Generation Scripts \u2014 How mapping data and command methods are generated</li> <li>Namespace Origin \u2014 How the snake_case attribute names were derived</li> <li>Release Workflow \u2014 How releases are published</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":"<p>This project welcomes contributions from humans working with or without AI assistance. AI tooling is available but not required.</p>"},{"location":"development/contributing/#branching-and-workflow","title":"Branching and workflow","text":"<p>All contributors follow the same branching model:</p> <ul> <li>Branch from <code>develop</code> using <code>feature/*</code>, <code>bugfix/*</code>, <code>hotfix/*</code>, or   <code>chore/*</code> prefixes.</li> <li>Commit messages follow   conventional commits and are   validated by CI.</li> <li>PR body must include <code>Fixes #N</code> or <code>Ref #N</code> (validated by CI).</li> <li>Feature PRs: squash merge to <code>develop</code>.</li> <li>Release PRs: regular merge to <code>main</code> (preserves shared ancestry).</li> </ul> <p>See release workflow for the full release process.</p>"},{"location":"development/contributing/#code-quality-gates","title":"Code quality gates","text":"<p>Every PR must pass these gates, enforced both locally and in CI:</p> Gate Tool Linting Ruff with all rules enabled (<code>select = [\"ALL\"]</code>) Formatting Ruff format Type checking mypy (strict) and ty Test coverage pytest with 100% branch coverage Security audit pip-audit Markdown lint markdownlint Commit messages Conventional commit validation <p>Run the full suite locally before pushing:</p> <pre><code>uv run python3 scripts/dev/validate_local.py\n</code></pre> <p>For docs-only changes:</p> <pre><code>uv run python3 scripts/dev/validate_docs.py\n</code></pre>"},{"location":"development/contributing/#for-human-contributors","title":"For human contributors","text":"<ul> <li>Run <code>validate_local.py</code> before pushing to catch issues early.</li> <li>Reference <code>docs/repository-standards.md</code> for the full standards   specification.</li> <li>The <code>CLAUDE.md</code> and <code>AGENTS.md</code> files document architecture,   patterns, and key design decisions. They are useful as reference   material even when not using an AI agent.</li> <li>After changing mapping data in <code>mapping_data.py</code>, regenerate   downstream artifacts. See generation scripts for the   regeneration workflow.</li> </ul>"},{"location":"development/contributing/#for-ai-agent-contributors","title":"For AI agent contributors","text":""},{"location":"development/contributing/#agent-entry-points","title":"Agent entry points","text":"<ul> <li>Claude Code: reads <code>CLAUDE.md</code>, which loads repository standards   via include directives.</li> <li>Codex and other agents: reads <code>AGENTS.md</code>, which loads the same   standards plus shared skills from the <code>standards-and-conventions</code>   repository.</li> </ul>"},{"location":"development/contributing/#quality-expectations","title":"Quality expectations","text":"<p>AI-generated code must pass all the same validation gates listed above. There are no exceptions.</p>"},{"location":"development/contributing/#what-ai-agents-handle-well","title":"What AI agents handle well","text":"<ul> <li>Code generation from mapping data</li> <li>Test writing and coverage gap filling</li> <li>Linting and formatting fixes</li> <li>Refactoring with consistent patterns</li> <li>PR creation and submission</li> </ul>"},{"location":"development/contributing/#what-requires-human-judgment","title":"What requires human judgment","text":"<ul> <li>Architectural decisions and API design</li> <li>MQ domain knowledge and MQSC semantics</li> <li>Release decisions and version management</li> <li>Mapping data curation (attribute names, value translations)</li> </ul>"},{"location":"development/contributing/#co-author-trailers","title":"Co-author trailers","text":"<p>AI agents add co-author trailers to commits automatically when following the repository standards.</p>"},{"location":"development/developer-setup/","title":"Developer setup","text":"<p>This guide covers everything needed to develop and test pymqrest locally.</p>"},{"location":"development/developer-setup/#prerequisites","title":"Prerequisites","text":"Tool Version Purpose Python 3.12+ Runtime <code>uv</code> 0.9.26 Package and environment management Docker Latest Local MQ containers (integration tests) <code>markdownlint</code> Latest Docs validation <code>git-cliff</code> Latest Changelog generation (releases only) <p>Install <code>uv</code>:</p> <pre><code>python3 -m pip install uv==0.9.26\n</code></pre>"},{"location":"development/developer-setup/#required-repositories","title":"Required repositories","text":"<p>pymqrest depends on two sibling repositories:</p> Repository Purpose pymqrest This project standards-and-conventions Canonical project standards (referenced by <code>AGENTS.md</code> and git hooks) mq-dev-environment Dockerized MQ test infrastructure (local and CI)"},{"location":"development/developer-setup/#recommended-directory-layout","title":"Recommended directory layout","text":"<p>Clone all three repositories as siblings:</p> <pre><code>~/dev/\n\u251c\u2500\u2500 mq-rest-admin-python/\n\u251c\u2500\u2500 standards-and-conventions/\n\u2514\u2500\u2500 mq-dev-environment/\n</code></pre> <pre><code>cd ~/dev\ngit clone https://github.com/wphillipmoore/mq-rest-admin-python.git\ngit clone https://github.com/wphillipmoore/standards-and-conventions.git\ngit clone https://github.com/wphillipmoore/mq-dev-environment.git\n</code></pre>"},{"location":"development/developer-setup/#initial-setup","title":"Initial setup","text":"<pre><code>cd pymqrest\n\n# Install all dependencies including dev group\nuv sync --group dev\n\n# Enable repository git hooks\ngit config core.hooksPath scripts/git-hooks\n</code></pre>"},{"location":"development/developer-setup/#running-validation","title":"Running validation","text":"<p>The full validation suite matches CI hard gates:</p> <pre><code>uv run python3 scripts/dev/validate_local.py\n</code></pre> <p>This runs:</p> <ul> <li>Virtual environment validation</li> <li>Dependency specification validation</li> <li>Version validation</li> <li>Repository profile linting</li> <li>Markdown standards checking</li> <li>Commit message validation</li> <li>Lock file verification</li> <li>Security audit (<code>pip-audit</code>)</li> <li>Ruff linting and formatting</li> <li>mypy strict type checking</li> <li>ty type checking</li> <li>pytest with 100% branch coverage</li> </ul> <p>For docs-only changes, a lighter validation is available:</p> <pre><code>uv run python3 scripts/dev/validate_docs.py\n</code></pre>"},{"location":"development/developer-setup/#running-integration-tests","title":"Running integration tests","text":"<p>Integration tests require running MQ containers. Start the containers, seed test objects, then run the tests:</p> <pre><code># Start both queue managers\n./scripts/dev/mq_start.sh\n\n# Seed deterministic test objects\n./scripts/dev/mq_seed.sh\n\n# Run integration tests\nPYMQREST_RUN_INTEGRATION=1 uv run pytest -m integration\n</code></pre> <p>See local MQ container for full container configuration, credentials, gateway routing, and troubleshooting.</p>"},{"location":"development/developer-setup/#ci-pipeline-overview","title":"CI pipeline overview","text":"<p>CI runs on every pull request and enforces the same gates as local validation. The pipeline includes:</p> <ul> <li>Unit tests on Python 3.12, 3.13, and 3.14</li> <li>Integration tests against real MQ queue managers via the shared   <code>wphillipmoore/mq-dev-environment/.github/actions/setup-mq</code> action</li> <li>Standards compliance (ruff, mypy, ty, markdown lint, commit   messages, repository profile)</li> <li>Dependency audit (<code>pip-audit</code>)</li> <li>Release gates (version checks, changelog validation) for PRs   targeting <code>main</code></li> </ul>"},{"location":"development/generation-scripts/","title":"Generation scripts","text":"<p>Several artifacts in the repository are generated from the <code>MAPPING_DATA</code> structure in <code>src/pymqrest/mapping_data.py</code>. This page documents how to regenerate them.</p>"},{"location":"development/generation-scripts/#mapping-data","title":"Mapping data","text":"<p>The <code>MAPPING_DATA</code> dictionary in <code>src/pymqrest/mapping_data.py</code> contains all qualifier definitions, attribute name mappings, value mappings, and command metadata. It is maintained directly and is the sole source of truth for attribute mappings. See Namespace origin for the history of how this namespace was bootstrapped.</p>"},{"location":"development/generation-scripts/#command-methods","title":"Command methods","text":"<p>The MQSC command wrapper methods in <code>src/pymqrest/commands.py</code> are generated from the command definitions in <code>MAPPING_DATA</code>:</p> <pre><code>uv run python3 scripts/dev/generate_commands.py\n</code></pre> <p>The generated methods live between the <code># BEGIN GENERATED MQSC METHODS</code> and <code># END GENERATED MQSC METHODS</code> markers in <code>commands.py</code>.</p>"},{"location":"development/generation-scripts/#mapping-documentation","title":"Mapping documentation","text":"<p>The per-qualifier mapping reference pages in <code>docs/sphinx/mappings/</code> are generated from <code>MAPPING_DATA</code>:</p> <pre><code>uv run python3 scripts/dev/generate_mapping_docs.py\n</code></pre> <p>This produces one Markdown page per qualifier (48 total) plus an index page. The pages are committed to the repository so they are viewable on GitHub without building the Sphinx documentation.</p>"},{"location":"development/generation-scripts/#regeneration-workflow","title":"Regeneration workflow","text":"<p>When the mapping data changes, regenerate all downstream artifacts:</p> <pre><code># 1. Regenerate command methods\nuv run python3 scripts/dev/generate_commands.py\n\n# 2. Regenerate mapping documentation\nuv run python3 scripts/dev/generate_mapping_docs.py\n\n# 3. Verify everything still passes\nuv run python3 scripts/dev/validate_local.py\n</code></pre>"},{"location":"development/local-mq-container/","title":"Local MQ Container","text":"<p>A containerized IBM MQ environment provides two queue managers for development and integration testing.</p>"},{"location":"development/local-mq-container/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker Desktop or compatible Docker Engine.</li> <li>IBM MQ container image access (license acceptance required).</li> <li>The <code>mq-dev-environment</code> repository cloned as a sibling directory   (<code>../mq-dev-environment</code>), or set <code>MQ_DEV_ENV_PATH</code> to its location.</li> </ul>"},{"location":"development/local-mq-container/#configuration","title":"Configuration","text":"<p>The Docker Compose file in the <code>mq-dev-environment</code> repository runs two queue managers on a shared network (<code>mq-dev-net</code>):</p> Setting QM1 QM2 Queue manager <code>QM1</code> <code>QM2</code> MQ listener port <code>1414</code> <code>1415</code> REST API port <code>9443</code> <code>9444</code> Container name <code>mq-dev-qm1</code> <code>mq-dev-qm2</code> <p>Note</p> <p>Some language repos use offset ports (e.g. 9453/9454, 1424/1425) to allow running integration tests for multiple repos simultaneously without port conflicts. See the language-specific notes below for details.</p> <p>Both queue managers share the same credentials:</p> Setting Value Admin credentials <code>mqadmin</code> / <code>mqadmin</code> Read-only credentials <code>mqreader</code> / <code>mqreader</code> QM1 REST base URL <code>https://localhost:9443/ibmmq/rest/v2</code> QM2 REST base URL <code>https://localhost:9444/ibmmq/rest/v2</code>"},{"location":"development/local-mq-container/#quick-start","title":"Quick start","text":"<p>Start both queue managers:</p> <pre><code>./scripts/dev/mq_start.sh\n</code></pre> <p>Seed deterministic test objects on both QMs (all prefixed with <code>DEV.</code>):</p> <pre><code>./scripts/dev/mq_seed.sh\n</code></pre> <p>Verify REST-based MQSC responses on both QMs:</p> <pre><code>./scripts/dev/mq_verify.sh\n</code></pre>"},{"location":"development/local-mq-container/#seed-objects","title":"Seed objects","text":"<p>QM1 receives the full set of test objects (queues, channels, topics, namelists, listeners, processes) plus cross-QM objects for communicating with QM2. QM2 receives a smaller set of objects plus the reciprocal cross-QM definitions.</p> <p>The seed scripts are maintained in the <code>mq-dev-environment</code> repository at <code>seed/base-qm1.mqsc</code> and <code>seed/base-qm2.mqsc</code>. Both use <code>REPLACE</code> so they can be re-run at any time without side effects.</p>"},{"location":"development/local-mq-container/#lifecycle-scripts","title":"Lifecycle scripts","text":"Script Purpose <code>scripts/dev/mq_start.sh</code> Start both queue managers and wait for REST readiness <code>scripts/dev/mq_seed.sh</code> Seed deterministic test objects on both QMs <code>scripts/dev/mq_verify.sh</code> Verify REST-based MQSC responses on both QMs <code>scripts/dev/mq_stop.sh</code> Stop both queue managers <code>scripts/dev/mq_reset.sh</code> Reset to clean state (removes data volumes)"},{"location":"development/local-mq-container/#environment-variables","title":"Environment variables","text":"Variable Default Description <code>MQ_REST_BASE_URL</code> <code>https://localhost:9443/ibmmq/rest/v2</code> QM1 REST API base URL <code>MQ_REST_BASE_URL_QM2</code> <code>https://localhost:9444/ibmmq/rest/v2</code> QM2 REST API base URL <code>MQ_ADMIN_USER</code> <code>mqadmin</code> Admin username <code>MQ_ADMIN_PASSWORD</code> <code>mqadmin</code> Admin password <code>MQ_IMAGE</code> <code>icr.io/ibm-messaging/mq:latest</code> Container image <code>MQ_DEV_ENV_PATH</code> <code>../mq-dev-environment</code> Path to mq-dev-environment project"},{"location":"development/local-mq-container/#gateway-routing","title":"Gateway routing","text":"<p>The two-QM local setup supports gateway routing out of the box. The seed scripts create QM aliases and sender/receiver channels so each queue manager can route MQSC commands to the other.</p>"},{"location":"development/local-mq-container/#curl-example","title":"curl example","text":"<p>Query QM2's queue manager attributes through QM1's REST API:</p> <pre><code>curl -k -u mqadmin:mqadmin \\\n  -H \"Content-Type: application/json\" \\\n  -H \"ibm-mq-rest-csrf-token: local\" \\\n  -H \"ibm-mq-rest-gateway-qmgr: QM1\" \\\n  -d '{\"type\": \"runCommandJSON\", \"command\": \"DISPLAY\", \"qualifier\": \"QMGR\"}' \\\n  https://localhost:9443/ibmmq/rest/v2/admin/action/qmgr/QM2/mqsc\n</code></pre>"},{"location":"development/local-mq-container/#reset-workflow","title":"Reset workflow","text":"<p>To return to a completely clean state (removes both data volumes):</p> <pre><code>./scripts/dev/mq_reset.sh\n</code></pre>"},{"location":"development/local-mq-container/#troubleshooting","title":"Troubleshooting","text":"<p>If the REST API is not reachable, ensure the embedded web server is binding to all interfaces:</p> <pre><code>docker compose -f ../mq-dev-environment/config/docker-compose.yml exec -T qm1 \\\n    setmqweb properties -k httpHost -v \"*\"\n</code></pre> <p>Then restart the containers and retry the verification workflow.</p>"},{"location":"development/local-mq-container/#python-specific-notes","title":"Python-specific notes","text":""},{"location":"development/local-mq-container/#integration-tests","title":"Integration tests","text":"<p>Integration tests are opt-in and require running MQ containers:</p> <pre><code>PYMQREST_RUN_INTEGRATION=1 uv run pytest -m integration\n</code></pre> <p>When enabled, the test session:</p> <ol> <li>Starts both local MQ containers.</li> <li>Waits for both REST endpoints to become ready.</li> <li>Seeds deterministic test objects on both QMs.</li> <li>Runs DISPLAY checks plus define/alter/delete lifecycles.</li> <li>Stops both containers after the session.</li> </ol>"},{"location":"development/local-mq-container/#environment-variables_1","title":"Environment variables","text":"Variable Default Description <code>MQ_REST_BASE_URL</code> <code>https://localhost:9443/ibmmq/rest/v2</code> QM1 REST API base URL <code>MQ_REST_BASE_URL_QM2</code> <code>https://localhost:9444/ibmmq/rest/v2</code> QM2 REST API base URL <code>MQ_ADMIN_USER</code> <code>mqadmin</code> Admin username <code>MQ_ADMIN_PASSWORD</code> <code>mqadmin</code> Admin password <code>MQ_IMAGE</code> <code>icr.io/ibm-messaging/mq:latest</code> Container image"},{"location":"development/local-mq-container/#gateway-routing-with-pymqrest","title":"Gateway routing with pymqrest","text":"<pre><code>from pymqrest import MQRESTSession\nfrom pymqrest.auth import BasicAuth\n\n# Route commands to QM2 through QM1\nsession = MQRESTSession(\n    rest_base_url=\"https://localhost:9443/ibmmq/rest/v2\",\n    qmgr_name=\"QM2\",\n    credentials=BasicAuth(\"mqadmin\", \"mqadmin\"),\n    gateway_qmgr=\"QM1\",\n    verify_tls=False,\n)\n\nqmgr = session.display_qmgr()\nprint(qmgr)  # QM2's attributes, routed through QM1\n</code></pre>"},{"location":"development/namespace-origin/","title":"Namespace origin","text":""},{"location":"development/namespace-origin/#how-the-snake_case-namespace-was-created","title":"How the <code>snake_case</code> namespace was created","text":"<p>The <code>snake_case</code> attribute namespace in <code>mapping_data.py</code> was initialized by parsing IBM MQ 9.4 MQSC and PCF documentation using an automated extraction pipeline. The pipeline:</p> <ol> <li>Downloaded MQSC and PCF command reference pages from IBM documentation</li> <li>Extracted attribute names, types, and value constants</li> <li>Built a mapping between MQSC and PCF attribute names</li> <li>Proposed <code>snake_case</code> equivalents for each attribute</li> </ol> <p>The automated output was then reviewed, customized, and rationalized by hand. Many names were changed, value mappings were corrected, and qualifier-specific overrides were applied.</p>"},{"location":"development/namespace-origin/#current-source-of-truth","title":"Current source of truth","text":"<p><code>src/pymqrest/mapping_data.py</code> is the sole authoritative source for all attribute mappings. It is maintained directly \u2014 not generated from external documentation.</p> <p>The original extraction pipeline and its artifacts are archived in <code>docs/archive/extraction/</code> for historical reference.</p>"},{"location":"development/namespace-origin/#handling-future-mq-versions","title":"Handling future MQ versions","text":"<p>When IBM releases a new MQ version (for example, 9.5):</p> <ol> <li>Compare the previous and new MQSC command reference for new, changed,    or removed attributes</li> <li>Propose <code>snake_case</code> names for new attributes following the    established naming conventions in <code>mapping_data.py</code></li> <li>Update <code>mapping_data.py</code> directly with the new mappings</li> <li>Regenerate downstream artifacts:</li> </ol> <pre><code>uv run python3 scripts/dev/generate_commands.py\nuv run python3 scripts/dev/generate_mapping_docs.py\nuv run python3 scripts/dev/validate_local.py\n</code></pre> <p>Re-running the archived extraction pipeline is not recommended. The namespace has diverged significantly from what automation would produce, and manual maintenance preserves the naming consistency that has been built up over time.</p>"},{"location":"development/quality-gates/","title":"Quality gates","text":""},{"location":"development/quality-gates/#overview","title":"Overview","text":"<p>Every mq-rest-admin repository enforces a layered quality gate system. Local git hooks catch issues before code leaves the developer's machine, and CI pipelines enforce the same standards (plus additional checks) on every pull request. Pull requests cannot merge until all required jobs pass.</p>"},{"location":"development/quality-gates/#git-hooks","title":"Git hooks","text":"<p>Git hooks are stored in <code>scripts/git-hooks/</code> and activated with:</p> <pre><code>git config core.hooksPath scripts/git-hooks\n</code></pre>"},{"location":"development/quality-gates/#pre-commit","title":"pre-commit","text":"<p>The <code>pre-commit</code> hook runs before each commit and enforces:</p> <p>Protected branch blocking \u2014 Commits directly to <code>main</code>, <code>develop</code>, <code>release/*</code>, or a detached HEAD are rejected. All work must go through short-lived feature branches and pull requests.</p> <p>Branch naming enforcement \u2014 The hook reads the <code>branching_model</code> attribute from <code>docs/repository-standards.md</code> and enforces the corresponding naming convention:</p> Branching model Allowed prefixes <code>docs-single-branch</code> <code>feature/*</code>, <code>bugfix/*</code> <code>library-release</code> <code>feature/*</code>, <code>bugfix/*</code>, <code>hotfix/*</code> <code>application-promotion</code> <code>feature/*</code>, <code>bugfix/*</code>, <code>hotfix/*</code>, <code>promotion/*</code>"},{"location":"development/quality-gates/#commit-msg","title":"commit-msg","text":"<p>The <code>commit-msg</code> hook runs after the commit message is written and validates two things:</p> <p>Conventional Commits format \u2014 The subject line must match:</p> <pre><code>&lt;type&gt;(optional-scope): &lt;description&gt;\n</code></pre> <p>Allowed types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code>.</p> <p>Co-author identity validation \u2014 If the commit includes <code>Co-Authored-By</code> trailers, each trailer is checked against the approved identity list in <code>docs/repository-standards.md</code>. Unapproved identities are rejected. Commits without co-author trailers (human-only commits) are always valid.</p>"},{"location":"development/quality-gates/#ci-pipeline","title":"CI pipeline","text":"<p>The CI pipeline (<code>ci.yml</code>) runs on every pull request and on pushes to <code>develop</code> and <code>release/**</code>. It consists of several independent jobs, all of which must pass for a PR to merge.</p>"},{"location":"development/quality-gates/#docs-only-detection","title":"docs-only detection","text":"<p>A preliminary job detects whether the changeset is docs-only (as defined by the repository). When docs-only is detected, the test-intensive jobs (test-and-validate, CodeQL, Trivy, Semgrep, integration tests) are skipped, while standards-compliance and dependency-audit still run.</p>"},{"location":"development/quality-gates/#standards-compliance","title":"standards-compliance","text":"<p>Validates repository standards using a shared composite action:</p> <ul> <li>Conventional Commits \u2014 All commits in the PR are validated against   the <code>type(scope): description</code> format.</li> <li>Co-author trailers \u2014 All <code>Co-Authored-By</code> trailers are checked   against the approved list.</li> <li>PR issue linkage \u2014 The PR body must include <code>Fixes #N</code> or <code>Ref #N</code>   linking to a tracking issue. Other GitHub keywords (<code>Closes</code>,   <code>Resolves</code>) are rejected.</li> <li>Markdown standards \u2014 Documentation files are checked for exactly   one H1, no heading level skips, presence of a <code>## Table of Contents</code>   section, and markdownlint compliance.</li> <li>Repository profile \u2014 The <code>docs/repository-standards.md</code> file is   validated for required attributes: <code>repository_type</code>,   <code>versioning_scheme</code>, <code>branching_model</code>, <code>release_model</code>, and   <code>supported_release_lines</code>.</li> </ul>"},{"location":"development/quality-gates/#dependency-audit","title":"dependency-audit","text":"<p>Audits runtime dependencies for security vulnerabilities and license compliance:</p> Language Vulnerability scanner License checker Java <code>mvn dependency:tree</code> (resolution verification) <code>license-maven-plugin</code> with allow-list Python <code>pip-audit</code> against requirements files <code>pip-licenses</code> with allow-list Go <code>govulncheck ./...</code> <code>go-licenses check</code> with allow-list <p>Allowed licenses: Apache-2.0, MIT, BSD-2-Clause, BSD-3-Clause, ISC, MPL-2.0, GPL-3.0-or-later, and PSF-2.0.</p>"},{"location":"development/quality-gates/#release-gates","title":"release-gates","text":"<p>Validates version metadata on PRs targeting protected branches:</p> <p>PRs targeting main (release PRs):</p> <ul> <li>Version must be plain semver (<code>x.y.z</code>) with no pre-release suffix</li> <li>Version must not already exist on the package registry</li> <li>Changelog must include an entry for the release version</li> </ul> <p>PRs targeting develop:</p> <ul> <li>Version must differ from the version on <code>main</code>, preventing accidental   version collisions</li> </ul>"},{"location":"development/quality-gates/#test-and-validate","title":"test-and-validate","text":"<p>Runs the full validation pipeline across a matrix of language/runtime versions:</p> Language Versions tested Validation command Java 17, 21, 25-ea <code>./mvnw verify</code> Python 3.12, 3.13, 3.14 ruff + mypy + ty + pytest Go 1.25, 1.26 go vet + golangci-lint + go test <p>The validation pipeline includes (in order):</p> <ol> <li>Formatting check \u2014 Unformatted code fails the build</li> <li>Lint and style checks \u2014 Code smell and style rule enforcement</li> <li>Type checking \u2014 Strict type analysis (where applicable)</li> <li>Unit tests \u2014 Full test suite execution</li> <li>Coverage enforcement \u2014 100% line and branch coverage required</li> <li>Static analysis \u2014 Bug pattern and vulnerability detection</li> </ol>"},{"location":"development/quality-gates/#codeql","title":"CodeQL","text":"<p>GitHub's semantic code analysis runs on every non-docs PR. CodeQL performs deep data flow and taint tracking analysis to detect injection flaws, insecure data handling, and other vulnerability classes specific to each language.</p>"},{"location":"development/quality-gates/#trivy","title":"Trivy","text":"<p>Aqua Security's Trivy runs a filesystem vulnerability scan on every non-docs PR. It detects known CVEs in dependencies, lock files, and configuration files across all language ecosystems, complementing the language-specific scanners in the dependency-audit job with broader cross-ecosystem coverage.</p>"},{"location":"development/quality-gates/#semgrep","title":"Semgrep","text":"<p>Semgrep runs pattern-based Static Application Security Testing (SAST) on every non-docs PR. It complements CodeQL by providing broader language coverage and support for custom security rules. Each language repo configures Semgrep with language-specific rulesets.</p>"},{"location":"development/quality-gates/#integration-tests","title":"integration-tests","text":"<p>End-to-end tests run against containerized IBM MQ queue managers provisioned by the <code>mq-dev-environment</code> repository. These tests issue real MQSC commands through the REST API and verify that:</p> <ul> <li>Mapping data correctly translates between friendly names and MQ   attribute names</li> <li>Command methods produce valid REST API requests</li> <li>Response parsing handles real MQ response structures</li> </ul>"},{"location":"development/quality-gates/#documentation-deployment","title":"Documentation deployment","text":"<p>A separate <code>docs.yml</code> workflow deploys documentation on pushes to <code>main</code> and <code>develop</code> using mike for versioned deployment. Pushes to <code>develop</code> deploy the <code>dev</code> version; pushes to <code>main</code> deploy a numbered version (read from <code>VERSION</code> or the package metadata) with a <code>latest</code> alias.</p>"},{"location":"development/quality-gates/#python-specific-validation","title":"Python-specific validation","text":"<p>The Python validation pipeline runs via a local validation script:</p> <pre><code>scripts/dev/validate_local.py\n</code></pre> <p>This executes:</p> <ol> <li>ruff check \u2014 Lint with all rule categories enabled</li> <li>ruff format \u2014 Formatting check</li> <li>mypy \u2014 Strict type checking (<code>src/</code>)</li> <li>ty \u2014 Additional type checking (<code>src/</code>)</li> <li>pytest \u2014 Unit tests with 100% line and branch coverage enforcement</li> <li>pip-audit \u2014 Dependency vulnerability scanning</li> <li>uv lock --check \u2014 Lock file synchronization verification</li> </ol> <p>The CI matrix tests against Python 3.12, 3.13, and 3.14.</p>"},{"location":"development/release-workflow/","title":"Release workflow","text":"<p>This document describes how pymqrest versions are managed and published to PyPI.</p>"},{"location":"development/release-workflow/#version-management","title":"Version management","text":"<p>The version is stored statically in <code>pyproject.toml</code> under <code>[project].version</code>. It follows semantic versioning (<code>MAJOR.MINOR.PATCH</code>).</p> <p>After each release, the publish workflow automatically opens a PR to bump the patch version on <code>develop</code>. This default can be overridden at any time by changing the version to a minor or major bump instead.</p>"},{"location":"development/release-workflow/#release-flow","title":"Release flow","text":"<ol> <li>Develop \u2014 All feature work merges into <code>develop</code>. Ensure the    version in <code>pyproject.toml</code> is set to the desired release version.</li> <li>Prepare release \u2014 Run the release preparation script from    <code>develop</code>:</li> </ol> <pre><code>uv run python3 scripts/dev/prepare_release.py\n</code></pre> <p>The script automates everything needed to get a release PR open:    - Validates preconditions (on <code>develop</code>, clean tree, tools available)    - Creates a <code>release/X.Y.Z</code> branch from <code>develop</code>    - Generates the changelog via git-cliff    - Commits the changelog update on the release branch    - Pushes the branch and creates a PR to <code>main</code>    - Enables auto-merge (regular merge, delete branch)</p> <ol> <li>Merge to main \u2014 The PR merges automatically once CI passes    using a regular merge commit (not squash). This preserves shared    ancestry between <code>main</code> and <code>develop</code>, avoiding history divergence.    If auto-merge is not enabled on the repository, merge manually    with <code>--merge</code>.</li> <li>Automatic publish \u2014 The <code>publish.yml</code> workflow fires on push to    <code>main</code> and:</li> <li>Extracts the version from <code>pyproject.toml</code></li> <li>Skips if the version is already on PyPI (idempotent)</li> <li>Builds sdist and wheel with <code>uv build</code></li> <li>Publishes to PyPI via OIDC trusted publishing</li> <li>Creates an annotated git tag (<code>vX.Y.Z</code>)</li> <li>Creates a <code>develop-vX.Y.Z</code> lightweight tag on <code>develop</code> for      git-cliff boundary tracking</li> <li>Creates a GitHub Release with install instructions and dist      artifacts</li> <li>Opens a PR against <code>develop</code> to bump the patch version (e.g.      <code>1.0.0</code> \u2192 <code>1.0.1</code>), assuming the next release is a patch</li> </ol>"},{"location":"development/release-workflow/#automatic-version-bump","title":"Automatic version bump","text":"<p>After each successful publish, the workflow creates a PR to increment the patch version on <code>develop</code>. This keeps the working version ahead of the last release and ready for the next patch. The bump PR also refreshes all dependencies to their latest compatible versions via <code>uv lock --upgrade</code> and re-exports <code>requirements.txt</code> and <code>requirements-dev.txt</code>.</p> <p>If the next release should be a minor or major bump instead, simply change the version in <code>pyproject.toml</code> at any point during the development cycle \u2014 the automated PR is just a default starting point.</p> <p>The bump PR is skipped if <code>develop</code> already has the expected next version (e.g. if someone bumped it manually first).</p>"},{"location":"development/release-workflow/#changelog","title":"Changelog","text":"<p>The project changelog is maintained in <code>CHANGELOG.md</code> using git-cliff, configured via <code>cliff.toml</code> at the repository root.</p> <p>git-cliff is a local developer tool (not required in CI). Install it with Homebrew:</p> <pre><code>brew install git-cliff\n</code></pre>"},{"location":"development/release-workflow/#how-it-works","title":"How it works","text":"<p>git-cliff uses <code>develop-vX.Y.Z</code> lightweight tags as version boundary markers. These tags point to commits on <code>develop</code> and are created automatically by the publish workflow after each release. They allow git-cliff to determine which commits belong to each version when run on <code>develop</code> or a release branch.</p> <p>To regenerate the changelog from scratch:</p> <pre><code>git-cliff -o CHANGELOG.md\n</code></pre> <p>To generate the changelog with a new version heading (used during the release flow):</p> <pre><code>git-cliff --tag develop-vX.Y.Z -o CHANGELOG.md\n</code></pre>"},{"location":"development/release-workflow/#ci-validation","title":"CI validation","text":"<p>The <code>release-gates</code> CI job validates that <code>CHANGELOG.md</code> contains an entry matching the version in <code>pyproject.toml</code> for PRs targeting <code>main</code>. This ensures the changelog is always updated before a release.</p>"},{"location":"development/release-workflow/#ci-version-gates","title":"CI version gates","text":"<p>Pull requests trigger additional version checks:</p> <ul> <li>PRs targeting main: Version must not already exist on PyPI, must   be greater than the latest published version, and <code>CHANGELOG.md</code>   must contain an entry for the version.</li> <li>PRs targeting develop: Version must differ from the version on   <code>main</code> (prevents accidental no-op releases).</li> </ul>"},{"location":"development/release-workflow/#pypi-trusted-publisher-setup-one-time","title":"PyPI trusted publisher setup (one-time)","text":"<p>Before the first release, the repository owner must configure OIDC trusted publishing on PyPI:</p> <ol> <li>Go to https://pypi.org/manage/account/publishing/.</li> <li>Add a pending publisher:</li> <li>Project name: <code>pymqrest</code></li> <li>Owner: <code>wphillipmoore</code></li> <li>Repository: <code>pymqrest</code></li> <li>Workflow name: <code>publish.yml</code></li> <li>Environment: (leave blank)</li> <li>The first publish will claim the package name.</li> </ol> <p>See the PyPI trusted publisher documentation for details.</p>"},{"location":"development/release-workflow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/release-workflow/#version-already-exists-on-pypi","title":"Version already exists on PyPI","text":"<p>The publish workflow skips publishing if the version already exists. To release a new version, bump the version in <code>pyproject.toml</code> and go through the release flow again.</p>"},{"location":"development/release-workflow/#tag-already-exists","title":"Tag already exists","text":"<p>The publish workflow skips tag creation if the tag already exists. This is expected when re-running a failed workflow.</p>"},{"location":"development/release-workflow/#publish-fails","title":"Publish fails","text":"<p>Check the workflow logs for OIDC authentication errors. Ensure the trusted publisher is configured correctly on PyPI. The workflow only triggers on push to <code>main</code>, so the <code>id-token: write</code> permission is scoped to that branch.</p>"},{"location":"mappings/","title":"Qualifier Mapping Reference","text":"<p>Each page below documents the attribute mappings for one MQSC qualifier. These mappings translate between developer-friendly names and MQSC parameter names used by the IBM MQ REST API.</p> <ul> <li>apstatus</li> <li>archive</li> <li>authinfo</li> <li>authrec</li> <li>authserv</li> <li>cfstatus</li> <li>cfstruct</li> <li>channel</li> <li>chinit</li> <li>chlauth</li> <li>chstatus</li> <li>clusqmgr</li> <li>cluster</li> <li>comminfo</li> <li>conn</li> <li>entauth</li> <li>group</li> <li>indoubt</li> <li>listener</li> <li>log</li> <li>lsstatus</li> <li>namelist</li> <li>policy</li> <li>process</li> <li>pubsub</li> <li>qmgr</li> <li>qmstatus</li> <li>qstatus</li> <li>queue</li> <li>sbstatus</li> <li>security</li> <li>service</li> <li>smds</li> <li>smdsconn</li> <li>stgclass</li> <li>sub</li> <li>svstatus</li> <li>topic</li> <li>topicstr</li> <li>tpstatus</li> <li>usage</li> </ul>"},{"location":"mappings/apstatus/","title":"apstatus","text":"<p>Attribute mapping reference for the <code>apstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY APSTATUS</code></p>"},{"location":"mappings/apstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ACTIVE</code> <code>queue_manager_active</code> <code>BALANCED</code> <code>balanced</code> <code>BALOPTS</code> <code>balancing_options</code> <code>BALSTATE</code> <code>balance_state</code> <code>BALTMOUT</code> <code>timeout</code> <code>BALTYPE</code> <code>application_type</code> <code>CLUSTER</code> <code>cluster_name</code> <code>CONNS</code> <code>connections</code> <code>CONNTAG</code> <code>connection_tag</code> <code>COUNT</code> <code>instance_count</code> <code>IMMCOUNT</code> <code>immovable_count</code> <code>IMMDATE</code> <code>immovable_date</code> <code>IMMREASN</code> <code>immovable_reason</code> <code>IMMTIME</code> <code>immovable_time</code> <code>LMSGDATE</code> <code>last_message_date</code> <code>LMSGTIME</code> <code>last_message_time</code> <code>MOVABLE</code> <code>movable</code> <code>MOVCOUNT</code> <code>movable_instance_count</code> <code>QMID</code> <code>queue_manager_id</code> <code>QMNAME</code> <code>queue_manager_name</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/archive/","title":"archive","text":"<p>Attribute mapping reference for the <code>archive</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY ARCHIVE</code>, <code>SET ARCHIVE</code></p>"},{"location":"mappings/archive/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>allocation_primary</code> <code>PRIQTY</code> <code>allocation_secondary</code> <code>SECQTY</code> <code>allocation_units</code> <code>ALCUNIT</code> <code>archive_prefix1</code> <code>ARCPFX1</code> <code>archive_prefix2</code> <code>ARCPFX2</code> <code>archive_retention</code> <code>ARCRETN</code> <code>archive_routing_code</code> <code>ARCWRTC</code> <code>archive_unit2</code> <code>UNIT2</code> <code>archive_wait_for_reply</code> <code>ARCWTOR</code> <code>block_size</code> <code>BLKSIZE</code> <code>catalog</code> <code>CATALOG</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>compact</code> <code>COMPACT</code> <code>protect</code> <code>PROTECT</code> <code>quiesce_interval</code> <code>QUIESCE</code> <code>time_stamp_format</code> <code>TSTAMP</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/authinfo/","title":"authinfo","text":"<p>Attribute mapping reference for the <code>authinfo</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER AUTHINFO</code>, <code>DEFINE AUTHINFO</code>, <code>DELETE AUTHINFO</code>, <code>DISPLAY AUTHINFO</code></p>"},{"location":"mappings/authinfo/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>adopt_context</code> <code>ADOPTCTX</code> <code>authentication_info_type</code> <code>AUTHTYPE</code> <code>authentication_method</code> <code>AUTHENMD</code> <code>authorization_method</code> <code>AUTHORMD</code> <code>base_dn_group</code> <code>BASEDNG</code> <code>base_dn_user</code> <code>BASEDNU</code> <code>check_client</code> <code>CHCKCLNT</code> <code>check_local</code> <code>CHCKLOCL</code> <code>class_group</code> <code>CLASSGRP</code> <code>class_user</code> <code>CLASSUSR</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>connection_name</code> <code>CONNAME</code> <code>description</code> <code>DESCR</code> <code>failure_delay</code> <code>FAILDLAY</code> <code>find_group</code> <code>FINDGRP</code> <code>group_field</code> <code>GRPFIELD</code> <code>group_nesting</code> <code>NESTGRP</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>ldap_password</code> <code>LDAPPWD</code> <code>ldap_user_name</code> <code>LDAPUSER</code> <code>like</code> <code>LIKE</code> <code>ocsp_responder_url</code> <code>OCSPURL</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code> <code>secure_communications</code> <code>SECCOMM</code> <code>short_user</code> <code>SHORTUSR</code> <code>user_field</code> <code>USRFIELD</code>"},{"location":"mappings/authinfo/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ADOPTCTX</code> <code>adopt_context</code> <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>AUTHENMD</code> <code>authentication_method</code> <code>AUTHORMD</code> <code>authorization_method</code> <code>AUTHTYPE</code> <code>authentication_info_type</code> <code>BASEDNG</code> <code>base_dn_group</code> <code>BASEDNU</code> <code>base_dn_user</code> <code>CHCKCLNT</code> <code>check_client</code> <code>CHCKLOCL</code> <code>check_local</code> <code>CLASSGRP</code> <code>class_group</code> <code>CLASSUSR</code> <code>class_user</code> <code>CONNAME</code> <code>connection_name</code> <code>DESCR</code> <code>description</code> <code>FAILDLAY</code> <code>failure_delay</code> <code>FINDGRP</code> <code>find_group</code> <code>GRPFIELD</code> <code>group_field</code> <code>LDAPPWD</code> <code>ldap_password</code> <code>LDAPUSER</code> <code>ldap_user_name</code> <code>NESTGRP</code> <code>group_nesting</code> <code>OCSPURL</code> <code>ocsp_responder_url</code> <code>QSGDISP</code> <code>queue_sharing_group_disposition</code> <code>SECCOMM</code> <code>secure_communications</code> <code>SHORTUSR</code> <code>short_user</code> <code>USRFIELD</code> <code>user_field</code>"},{"location":"mappings/authinfo/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/authinfo/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/authinfo/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/authrec/","title":"authrec","text":"<p>Attribute mapping reference for the <code>authrec</code> qualifier.</p> <p>Related MQSC commands: <code>DELETE AUTHREC</code>, <code>DISPLAY AUTHREC</code>, <code>SET AUTHREC</code></p>"},{"location":"mappings/authrec/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>authority_add</code> <code>AUTHADD</code> <code>authority_remove</code> <code>AUTHRMV</code> <code>group_names</code> <code>GROUP</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>object_type</code> <code>OBJTYPE</code> <code>options</code> <code>MATCH</code> <code>principal_names</code> <code>PRINCIPAL</code> <code>profile_name</code> <code>PROFILE</code> <code>service_component</code> <code>SERVCOMP</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/authserv/","title":"authserv","text":"<p>Attribute mapping reference for the <code>authserv</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY AUTHSERV</code></p>"},{"location":"mappings/authserv/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>IFVER</code> <code>interface_version</code> <code>UIDSUPP</code> <code>user_id_support</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/cfstatus/","title":"cfstatus","text":"<p>Attribute mapping reference for the <code>cfstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY CFSTATUS</code></p>"},{"location":"mappings/cfstatus/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>shared_message_dataset</code> <code>SMDS</code>"},{"location":"mappings/cfstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ACCESS</code> <code>access</code> <code>BKUPDATE</code> <code>backup_date</code> <code>BKUPERBA</code> <code>backup_end_rba</code> <code>BKUPSIZE</code> <code>backup_size</code> <code>BKUPSRBA</code> <code>backup_start_rba</code> <code>BKUPTIME</code> <code>backup_time</code> <code>CFTYPE</code> <code>cf_struct_type</code> <code>ENTSMAX</code> <code>entries_max</code> <code>ENTSUSED</code> <code>entries_used</code> <code>FAILDATE</code> <code>fail_date</code> <code>FAILTIME</code> <code>fail_time</code> <code>LOGS</code> <code>log_queue_manager_names</code> <code>OFFLDUSE</code> <code>offload_use</code> <code>QMNAME</code> <code>queue_manager_name</code> <code>RCVDATE</code> <code>recovery_start_date</code> <code>RCVTIME</code> <code>recovery_start_time</code> <code>SIZEMAX</code> <code>size_max</code> <code>SIZEUSED</code> <code>size_used</code> <code>SMDS</code> <code>shared_message_dataset</code> <code>STATUS</code> <code>cf_status_type</code> <code>SYSNAME</code> <code>system_name</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/cfstruct/","title":"cfstruct","text":"<p>Attribute mapping reference for the <code>cfstruct</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER CFSTRUCT</code>, <code>BACKUP CFSTRUCT</code>, <code>DEFINE CFSTRUCT</code>, <code>DELETE CFSTRUCT</code>, <code>DISPLAY CFSTRUCT</code>, <code>RECOVER CFSTRUCT</code>, <code>RESET CFSTRUCT</code></p>"},{"location":"mappings/cfstruct/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>action</code> <code>ACTION</code> <code>cf_connection_lost</code> <code>CFCONLOS</code> <code>cf_level</code> <code>CFLEVEL</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>data_sharing_block</code> <code>DSBLOCK</code> <code>data_sharing_buffers</code> <code>DSBUFS</code> <code>data_sharing_expand</code> <code>DSEXPAND</code> <code>data_sharing_group</code> <code>DSGROUP</code> <code>description</code> <code>DESCR</code> <code>exclude_interval</code> <code>EXCLINT</code> <code>like</code> <code>LIKE</code> <code>offload</code> <code>OFFLOAD</code> <code>offload_size1</code> <code>OFFLD1SZ</code> <code>offload_size2</code> <code>OFFLD2SZ</code> <code>offload_size3</code> <code>OFFLD3SZ</code> <code>offload_threshold1</code> <code>OFFLD1TH</code> <code>offload_threshold2</code> <code>OFFLD2TH</code> <code>offload_threshold3</code> <code>OFFLD3TH</code> <code>purge</code> <code>TYPE</code> <code>recovery</code> <code>RECOVER</code> <code>recovery_auto</code> <code>RECAUTO</code>"},{"location":"mappings/cfstruct/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>CFCONLOS</code> <code>cf_connection_lost</code> <code>CFLEVEL</code> <code>cf_level</code> <code>DESCR</code> <code>description</code> <code>DSBLOCK</code> <code>data_sharing_block</code> <code>DSBUFS</code> <code>data_sharing_buffers</code> <code>DSEXPAND</code> <code>data_sharing_expand</code> <code>DSGROUP</code> <code>data_sharing_group</code> <code>OFFLD1SZ</code> <code>offload_size1</code> <code>OFFLD1TH</code> <code>offload_threshold1</code> <code>OFFLD2SZ</code> <code>offload_size2</code> <code>OFFLD2TH</code> <code>offload_threshold2</code> <code>OFFLD3SZ</code> <code>offload_size3</code> <code>OFFLD3TH</code> <code>offload_threshold3</code> <code>OFFLOAD</code> <code>offload</code> <code>RECAUTO</code> <code>recovery_auto</code> <code>RECOVER</code> <code>recovery</code>"},{"location":"mappings/cfstruct/#request-value-map","title":"Request value map","text":""},{"location":"mappings/cfstruct/#purge","title":"purge","text":"Friendly value MQSC value <code>no</code> <code>NORMAL</code> <code>yes</code> <code>PURGE</code>"},{"location":"mappings/cfstruct/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/cfstruct/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/cfstruct/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/channel/","title":"channel","text":"<p>Attribute mapping reference for the <code>channel</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER CHANNEL</code>, <code>DEFINE CHANNEL</code>, <code>DELETE CHANNEL</code>, <code>DISPLAY CHANNEL</code>, <code>PING CHANNEL</code>, <code>PURGE CHANNEL</code>, <code>RESET CHANNEL</code>, <code>RESOLVE CHANNEL</code>, <code>START CHANNEL</code>, <code>STOP CHANNEL</code></p>"},{"location":"mappings/channel/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>amqp_keep_alive</code> <code>AMQPKA</code> <code>backlog</code> <code>BACKLOG</code> <code>batch_data_limit</code> <code>BATCHLIM</code> <code>batch_heartbeat</code> <code>BATCHHB</code> <code>batch_interval</code> <code>BATCHINT</code> <code>batch_size</code> <code>BATCHSZ</code> <code>certificate_label</code> <code>CERTLABL</code> <code>channel_disposition</code> <code>CHLDISP</code> <code>channel_monitoring</code> <code>MONCHL</code> <code>channel_statistics</code> <code>STATCHL</code> <code>channel_status</code> <code>STATUS</code> <code>channel_table</code> <code>CHLTABLE</code> <code>channel_type</code> <code>CHLTYPE</code> <code>client_channel_weight</code> <code>CLNTWGHT</code> <code>client_id</code> <code>CLIENTID</code> <code>cluster_name</code> <code>CLUSTER</code> <code>cluster_namelist</code> <code>CLUSNL</code> <code>cluster_workload_channel_weight</code> <code>CLWLWGHT</code> <code>cluster_workload_priority</code> <code>CLWLPRTY</code> <code>cluster_workload_rank</code> <code>CLWLRANK</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>connection_affinity</code> <code>AFFINITY</code> <code>connection_name</code> <code>CONNAME</code> <code>data_conversion</code> <code>CONVERT</code> <code>data_count</code> <code>DATALEN</code> <code>default_channel_disposition</code> <code>DEFCDISP</code> <code>default_reconnect</code> <code>DEFRECON</code> <code>description</code> <code>DESCR</code> <code>disconnect_interval</code> <code>DISCINT</code> <code>header_compression</code> <code>COMPHDR</code> <code>heartbeat_interval</code> <code>HBINT</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>in_doubt</code> <code>ACTION</code> <code>jaas_config</code> <code>JAASCFG</code> <code>keep_alive_interval</code> <code>KAINT</code> <code>like</code> <code>LIKE</code> <code>local_address</code> <code>LOCLADDR</code> <code>long_retry_count</code> <code>LONGRTY</code> <code>long_retry_interval</code> <code>LONGTMR</code> <code>max_instances</code> <code>MAXINST</code> <code>max_instances_per_client</code> <code>MAXINSTC</code> <code>max_message_length</code> <code>MAXMSGL</code> <code>mca_name</code> <code>MCANAME</code> <code>mca_type</code> <code>MCATYPE</code> <code>mca_user</code> <code>MCAUSER</code> <code>message_compression</code> <code>COMPMSG</code> <code>message_exit</code> <code>MSGEXIT</code> <code>message_retry_count</code> <code>MRRTY</code> <code>message_retry_exit</code> <code>MREXIT</code> <code>message_retry_interval</code> <code>MRTMR</code> <code>message_retry_user_data</code> <code>MRDATA</code> <code>message_sequence_number</code> <code>SEQNUM</code> <code>message_user_data</code> <code>MSGDATA</code> <code>mode</code> <code>MODE</code> <code>mode_name</code> <code>MODENAME</code> <code>network_priority</code> <code>NETPRTY</code> <code>non_persistent_message_speed</code> <code>NPMSPEED</code> <code>password</code> <code>PASSWORD</code> <code>port</code> <code>PORT</code> <code>property_control</code> <code>PROPCTL</code> <code>protocol</code> <code>PROTOCOL</code> <code>put_authority</code> <code>PUTAUT</code> <code>queue_manager_name</code> <code>QMNAME</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code> <code>receive_exit</code> <code>RCVEXIT</code> <code>receive_user_data</code> <code>RCVDATA</code> <code>security_exit</code> <code>SCYEXIT</code> <code>security_policy_protection</code> <code>SPLPROT</code> <code>security_user_data</code> <code>SCYDATA</code> <code>send_exit</code> <code>SENDEXIT</code> <code>send_user_data</code> <code>SENDDATA</code> <code>sequence_number_wrap</code> <code>SEQWRAP</code> <code>sharing_conversations</code> <code>SHARECNV</code> <code>short_retry_count</code> <code>SHORTRTY</code> <code>short_retry_interval</code> <code>SHORTTMR</code> <code>ssl_cipher_spec</code> <code>SSLCIPH</code> <code>ssl_client_authentication</code> <code>SSLCAUTH</code> <code>ssl_key_repository</code> <code>SSLKEYR</code> <code>ssl_pass_phrase</code> <code>SSLKEYP</code> <code>ssl_peer_name</code> <code>SSLPEER</code> <code>temporary_model_queue_name</code> <code>TMPMODEL</code> <code>temporary_queue_prefix</code> <code>TMPQPRFX</code> <code>topic_root</code> <code>TPROOT</code> <code>transaction_program_name</code> <code>TPNAME</code> <code>transmission_queue_name</code> <code>XMITQ</code> <code>transport_type</code> <code>TRPTYPE</code> <code>use_client_id</code> <code>USECLTID</code> <code>use_dead_letter_queue</code> <code>USEDLQ</code> <code>user_id</code> <code>USERID</code>"},{"location":"mappings/channel/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>AFFINITY</code> <code>connection_affinity</code> <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>AMQPKA</code> <code>amqp_keep_alive</code> <code>AUTOSTART</code> <code>auto_start</code> <code>BATCHHB</code> <code>batch_heartbeat</code> <code>BATCHINT</code> <code>batch_interval</code> <code>BATCHLIM</code> <code>batch_data_limit</code> <code>BATCHSZ</code> <code>batch_size</code> <code>CERTLABL</code> <code>certificate_label</code> <code>CHANNEL</code> <code>channel_name</code> <code>CHLTYPE</code> <code>channel_type</code> <code>CLNTWGHT</code> <code>client_channel_weight</code> <code>CLUSNL</code> <code>cluster_namelist</code> <code>CLUSTER</code> <code>cluster_name</code> <code>CLWLPRTY</code> <code>cluster_workload_priority</code> <code>CLWLRANK</code> <code>cluster_workload_rank</code> <code>CLWLWGHT</code> <code>cluster_workload_channel_weight</code> <code>COMPHDR</code> <code>header_compression</code> <code>COMPMSG</code> <code>message_compression</code> <code>CONNAME</code> <code>connection_name</code> <code>CONVERT</code> <code>data_conversion</code> <code>DEFCDISP</code> <code>default_channel_disposition</code> <code>DEFRECON</code> <code>default_reconnect</code> <code>DESCR</code> <code>description</code> <code>DISCINT</code> <code>disconnect_interval</code> <code>HBINT</code> <code>heartbeat_interval</code> <code>KAINT</code> <code>keep_alive_interval</code> <code>LOCLADDR</code> <code>local_address</code> <code>LONGRTY</code> <code>long_retry_count</code> <code>LONGTMR</code> <code>long_retry_interval</code> <code>MAXINST</code> <code>max_instances</code> <code>MAXINSTC</code> <code>max_instances_per_client</code> <code>MAXMSGL</code> <code>max_message_length</code> <code>MCANAME</code> <code>mca_name</code> <code>MCATYPE</code> <code>mca_type</code> <code>MCAUSER</code> <code>mca_user</code> <code>MODENAME</code> <code>mode_name</code> <code>MONCHL</code> <code>channel_monitoring</code> <code>MRDATA</code> <code>message_retry_user_data</code> <code>MREXIT</code> <code>message_retry_exit</code> <code>MRRTY</code> <code>message_retry_count</code> <code>MRTMR</code> <code>message_retry_interval</code> <code>MSGDATA</code> <code>message_user_data</code> <code>MSGEXIT</code> <code>message_exit</code> <code>NETPRTY</code> <code>network_priority</code> <code>NPMSPEED</code> <code>non_persistent_message_speed</code> <code>PASSWORD</code> <code>password</code> <code>PORT</code> <code>port</code> <code>PROPCTL</code> <code>property_control</code> <code>PUTAUT</code> <code>put_authority</code> <code>QMNAME</code> <code>queue_manager_name</code> <code>RCVDATA</code> <code>receive_user_data</code> <code>RCVEXIT</code> <code>receive_exit</code> <code>RESETSEQ</code> <code>reset_sequence</code> <code>SCYDATA</code> <code>security_user_data</code> <code>SCYEXIT</code> <code>security_exit</code> <code>SENDDATA</code> <code>send_user_data</code> <code>SENDEXIT</code> <code>send_exit</code> <code>SEQWRAP</code> <code>sequence_number_wrap</code> <code>SHARECNV</code> <code>sharing_conversations</code> <code>SHORTRTY</code> <code>short_retry_count</code> <code>SHORTTMR</code> <code>short_retry_interval</code> <code>SPLPROT</code> <code>security_policy_protection</code> <code>SSLCAUTH</code> <code>ssl_client_authentication</code> <code>SSLCIPH</code> <code>ssl_cipher_spec</code> <code>SSLPEER</code> <code>ssl_peer_name</code> <code>STATCHL</code> <code>channel_statistics</code> <code>TMPMODEL</code> <code>temporary_model_queue_name</code> <code>TMPQPRFX</code> <code>temporary_queue_prefix</code> <code>TPNAME</code> <code>transaction_program_name</code> <code>TPROOT</code> <code>topic_root</code> <code>TRPTYPE</code> <code>transport_type</code> <code>USECLTID</code> <code>use_client_id</code> <code>USEDLQ</code> <code>use_dead_letter_queue</code> <code>USERID</code> <code>user_id</code> <code>XMITQ</code> <code>transmission_queue_name</code>"},{"location":"mappings/channel/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/channel/#channel_instance_type","title":"channel_instance_type","text":"Friendly value MQSC key MQSC value <code>current</code> <code>CURRENT</code> <code>YES</code> <code>saved</code> <code>SAVED</code> <code>YES</code> <code>short</code> <code>SHORT</code> <code>YES</code>"},{"location":"mappings/channel/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/channel/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/chinit/","title":"chinit","text":"<p>Attribute mapping reference for the <code>chinit</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY CHINIT</code>, <code>START CHINIT</code>, <code>STOP CHINIT</code></p>"},{"location":"mappings/chinit/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>environment_info</code> <code>ENVPARM</code> <code>initiation_queue_name</code> <code>INITQ</code> <code>shared_channel_restart</code> <code>SHARED</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/chlauth/","title":"chlauth","text":"<p>Attribute mapping reference for the <code>chlauth</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY CHLAUTH</code>, <code>SET CHLAUTH</code></p>"},{"location":"mappings/chlauth/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>action</code> <code>ACTION</code> <code>address</code> <code>ADDRESS</code> <code>address_list</code> <code>ADDRLIST</code> <code>check_client</code> <code>CHCKCLNT</code> <code>client_user</code> <code>CLNTUSER</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>custom</code> <code>CUSTOM</code> <code>description</code> <code>DESCR</code> <code>match</code> <code>MATCH</code> <code>mca_user</code> <code>MCAUSER</code> <code>queue_manager_name</code> <code>QMNAME</code> <code>ssl_certificate_issuer</code> <code>SSLCERTI</code> <code>ssl_peer_name</code> <code>SSLPEER</code> <code>type</code> <code>TYPE</code> <code>user_list</code> <code>USERLIST</code> <code>user_source</code> <code>USERSRC</code> <code>warn</code> <code>WARN</code>"},{"location":"mappings/chlauth/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ADDRESS</code> <code>address</code> <code>ADDRLIST</code> <code>address_list</code> <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>CHCKCLNT</code> <code>check_client</code> <code>CLNTUSER</code> <code>client_user</code> <code>CUSTOM</code> <code>custom</code> <code>DESCR</code> <code>description</code> <code>MCAUSER</code> <code>mca_user</code> <code>QMNAME</code> <code>queue_manager_name</code> <code>SSLCERTI</code> <code>ssl_certificate_issuer</code> <code>SSLPEER</code> <code>ssl_peer_name</code> <code>TYPE</code> <code>type</code> <code>USERLIST</code> <code>user_list</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/chstatus/","title":"chstatus","text":"<p>Attribute mapping reference for the <code>chstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY CHSTATUS</code></p>"},{"location":"mappings/chstatus/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>channel_disposition</code> <code>CHLDISP</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>connection_name</code> <code>CONNAME</code> <code>non_persistent_message_speed</code> <code>NPMSPEED</code> <code>transmission_queue_name</code> <code>XMITQ</code>"},{"location":"mappings/chstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>AMQPKA</code> <code>amqp_keep_alive</code> <code>BATCHES</code> <code>batches</code> <code>BATCHSZ</code> <code>batch_size</code> <code>BUFSRCVD</code> <code>buffers_received</code> <code>BUFSSENT</code> <code>buffers_sent</code> <code>BYTSRCVD</code> <code>bytes_received</code> <code>BYTSSENT</code> <code>bytes_sent</code> <code>CHANNEL</code> <code>channel_name</code> <code>CHLTYPE</code> <code>channel_type</code> <code>CHSTADA</code> <code>channel_start_date</code> <code>CHSTATI</code> <code>channel_start_time</code> <code>COMPHDR</code> <code>header_compression</code> <code>COMPMSG</code> <code>message_compression</code> <code>COMPRATE</code> <code>compression_rate</code> <code>COMPTIME</code> <code>compression_time</code> <code>CONNAME</code> <code>connection_name</code> <code>CURLUWID</code> <code>current_logical_unit_of_work_id</code> <code>CURMSGS</code> <code>current_messages</code> <code>CURRENT</code> <code>current</code> <code>CURSEQNO</code> <code>current_sequence_number</code> <code>CURSHCNV</code> <code>current_sharing_conversations</code> <code>EXITTIME</code> <code>exit_time</code> <code>HBINT</code> <code>heartbeat_interval</code> <code>INDOUBT</code> <code>in_doubt_input</code> <code>JOBNAME</code> <code>mca_job_name</code> <code>KAINT</code> <code>keep_alive_interval</code> <code>LOCLADDR</code> <code>local_address</code> <code>LONGRTS</code> <code>long_retries_left</code> <code>LSTLUWID</code> <code>last_logical_unit_of_work_id</code> <code>LSTMSGDA</code> <code>last_message_date</code> <code>LSTMSGTI</code> <code>last_message_time</code> <code>LSTSEQNO</code> <code>last_sequence_number</code> <code>MAXMSGL</code> <code>max_message_length</code> <code>MAXSHCNV</code> <code>max_sharing_conversations</code> <code>MCASTAT</code> <code>mca_status</code> <code>MCAUSER</code> <code>mca_user</code> <code>MONCHL</code> <code>channel_monitoring</code> <code>MSGS</code> <code>messages</code> <code>NETTIME</code> <code>net_time</code> <code>NPMSPEED</code> <code>non_persistent_message_speed</code> <code>PORT</code> <code>port</code> <code>QMNAME</code> <code>queue_manager_name</code> <code>RAPPLTAG</code> <code>remote_application_tag</code> <code>RPRODUCT</code> <code>remote_product</code> <code>RQMNAME</code> <code>remote_queue_manager_name</code> <code>RVERSION</code> <code>remote_version</code> <code>SECPROT</code> <code>security_protocol</code> <code>SHORTRTS</code> <code>short_retries_left</code> <code>SSLCERTI</code> <code>ssl_certificate_issuer</code> <code>SSLCERTU</code> <code>ssl_certificate_user_id</code> <code>SSLCIPH</code> <code>ssl_cipher_spec</code> <code>SSLKEYDA</code> <code>ssl_key_reset_date</code> <code>SSLKEYTI</code> <code>ssl_key_reset_time</code> <code>SSLPEER</code> <code>ssl_peer_name</code> <code>SSLRKEYS</code> <code>ssl_key_resets</code> <code>STATCHL</code> <code>channel_statistics</code> <code>STATUS</code> <code>channel_status</code> <code>STOPREQ</code> <code>stop_requested</code> <code>SUBSTATE</code> <code>sub_state</code> <code>TPROOT</code> <code>topic_root</code> <code>XBATCHSZ</code> <code>batch_size_indicator</code> <code>XMITQ</code> <code>transmission_queue_name</code> <code>XQMSGSA</code> <code>messages_available</code> <code>XQTIME</code> <code>transmission_queue_time</code>"},{"location":"mappings/chstatus/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/chstatus/#channel_instance_type","title":"channel_instance_type","text":"Friendly value MQSC key MQSC value <code>current</code> <code>CURRENT</code> <code>YES</code> <code>saved</code> <code>SAVED</code> <code>YES</code> <code>short</code> <code>SHORT</code> <code>YES</code>"},{"location":"mappings/chstatus/#monitor","title":"monitor","text":"Friendly value MQSC key MQSC value <code>no</code> <code>MONITOR</code> <code>NO</code> <code>yes</code> <code>MONITOR</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/clusqmgr/","title":"clusqmgr","text":"<p>Attribute mapping reference for the <code>clusqmgr</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY CLUSQMGR</code></p>"},{"location":"mappings/clusqmgr/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>channel_name</code> <code>CHANNEL</code> <code>cluster_name</code> <code>CLUSTER</code> <code>command_scope</code> <code>CMDSCOPE</code>"},{"location":"mappings/clusqmgr/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>CLUSDATE</code> <code>cluster_date</code> <code>CLUSTIME</code> <code>cluster_time</code> <code>DEFTYPE</code> <code>definition_type</code> <code>QMID</code> <code>queue_manager_id</code> <code>QMTYPE</code> <code>queue_manager_type</code> <code>STATUS</code> <code>channel_status</code> <code>SUSPEND</code> <code>suspend</code> <code>VERSION</code> <code>version</code> <code>XMITQ</code> <code>transmission_queue_name</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/cluster/","title":"cluster","text":"<p>Attribute mapping reference for the <code>cluster</code> qualifier.</p> <p>Related MQSC commands: <code>REFRESH CLUSTER</code>, <code>RESET CLUSTER</code></p>"},{"location":"mappings/cluster/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>action</code> <code>ACTION</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>queue_manager_id</code> <code>QMID</code> <code>queue_manager_name</code> <code>QMNAME</code> <code>refresh_repository</code> <code>REPOS</code> <code>remove_queues</code> <code>QUEUES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/comminfo/","title":"comminfo","text":"<p>Attribute mapping reference for the <code>comminfo</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER COMMINFO</code>, <code>DEFINE COMMINFO</code>, <code>DELETE COMMINFO</code>, <code>DISPLAY COMMINFO</code></p>"},{"location":"mappings/comminfo/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>bridge</code> <code>BRIDGE</code> <code>coded_character_set_id</code> <code>CCSID</code> <code>communication_event</code> <code>COMMEV</code> <code>description</code> <code>DESCR</code> <code>encoding</code> <code>ENCODING</code> <code>group_address</code> <code>GRPADDR</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>like</code> <code>LIKE</code> <code>message_history</code> <code>MSGHIST</code> <code>monitor_interval</code> <code>MONINT</code> <code>multicast_heartbeat</code> <code>MCHBINT</code> <code>multicast_property_control</code> <code>MCPROP</code> <code>new_subscription_history</code> <code>NSUBHIST</code> <code>port</code> <code>PORT</code> <code>type</code> <code>TYPE</code>"},{"location":"mappings/comminfo/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>BRIDGE</code> <code>bridge</code> <code>CCSID</code> <code>coded_character_set_id</code> <code>COMMEV</code> <code>communication_event</code> <code>DESCR</code> <code>description</code> <code>ENCODING</code> <code>encoding</code> <code>GRPADDR</code> <code>group_address</code> <code>MCHBINT</code> <code>multicast_heartbeat</code> <code>MCPROP</code> <code>multicast_property_control</code> <code>MONINT</code> <code>monitor_interval</code> <code>MSGHIST</code> <code>message_history</code> <code>NSUBHIST</code> <code>new_subscription_history</code> <code>PORT</code> <code>port</code> <code>TYPE</code> <code>type</code>"},{"location":"mappings/comminfo/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/comminfo/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/comminfo/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/conn/","title":"conn","text":"<p>Attribute mapping reference for the <code>conn</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY CONN</code>, <code>STOP CONN</code></p>"},{"location":"mappings/conn/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>connection_info_type</code> <code>TYPE</code> <code>connection_prefix</code> <code>EXTCONN</code> <code>unit_of_recovery_disposition</code> <code>URDISP</code>"},{"location":"mappings/conn/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>APPLDESC</code> <code>application_description</code> <code>APPLTAG</code> <code>application_tag</code> <code>APPLTYPE</code> <code>application_type</code> <code>CHANNEL</code> <code>channel_name</code> <code>CLIENTID</code> <code>client_id</code> <code>CONNAME</code> <code>connection_name</code> <code>CONNOPTS</code> <code>connection_options</code> <code>CONNTAG</code> <code>connection_tag</code> <code>DEST</code> <code>destination</code> <code>DESTQMGR</code> <code>destination_queue_manager</code> <code>EXTURID</code> <code>unit_of_work_id</code> <code>HSTATE</code> <code>handle_state</code> <code>OBJNAME</code> <code>object_name</code> <code>OBJTYPE</code> <code>object_type</code> <code>OPENOPTS</code> <code>open_options</code> <code>PID</code> <code>process_id</code> <code>PSBNAME</code> <code>program_spec_block_name</code> <code>PSTID</code> <code>partition_spec_table_region_id</code> <code>QMURID</code> <code>queue_manager_unit_of_work_id</code> <code>QSGDISP</code> <code>queue_sharing_group_disposition</code> <code>READA</code> <code>read_ahead</code> <code>SUBID</code> <code>subscription_id</code> <code>SUBNAME</code> <code>subscription_name</code> <code>TASKNO</code> <code>task_number</code> <code>TID</code> <code>thread_id</code> <code>TOPICSTR</code> <code>topic_string</code> <code>TRANSID</code> <code>transaction_id</code> <code>TYPE</code> <code>connection_info_type</code> <code>UOWLOG</code> <code>start_unit_of_work_log_extent</code> <code>UOWLOGDA</code> <code>unit_of_work_log_start_date</code> <code>UOWLOGTI</code> <code>unit_of_work_log_start_time</code> <code>UOWSTATE</code> <code>unit_of_work_state</code> <code>UOWSTDA</code> <code>unit_of_work_start_date</code> <code>UOWSTTI</code> <code>unit_of_work_start_time</code> <code>URTYPE</code> <code>unit_of_work_type</code> <code>USERID</code> <code>user_id</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/entauth/","title":"entauth","text":"<p>Attribute mapping reference for the <code>entauth</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY ENTAUTH</code></p>"},{"location":"mappings/entauth/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>group_name</code> <code>GROUP</code> <code>object_name</code> <code>OBJNAME</code> <code>principal_name</code> <code>PRINCIPAL</code> <code>service_component</code> <code>SERVCOMP</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/group/","title":"group","text":"<p>Attribute mapping reference for the <code>group</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY GROUP</code></p>"},{"location":"mappings/group/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>obsolete_db2_messages</code> <code>OBSMSGS</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/indoubt/","title":"indoubt","text":"<p>Attribute mapping reference for the <code>indoubt</code> qualifier.</p> <p>Related MQSC commands: <code>RESOLVE INDOUBT</code></p>"},{"location":"mappings/indoubt/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>in_doubt</code> <code>ACTION</code> <code>origin_id</code> <code>NID</code> <code>queue_manager_name</code> <code>QMNAME</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/listener/","title":"listener","text":"<p>Attribute mapping reference for the <code>listener</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER LISTENER</code>, <code>DEFINE LISTENER</code>, <code>DELETE LISTENER</code>, <code>DISPLAY LISTENER</code>, <code>START LISTENER</code>, <code>STOP LISTENER</code></p>"},{"location":"mappings/listener/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>adapter</code> <code>ADAPTER</code> <code>backlog</code> <code>BACKLOG</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>commands</code> <code>COMMANDS</code> <code>description</code> <code>DESCR</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>inbound_disposition</code> <code>INDISP</code> <code>ip_address</code> <code>IPADDR</code> <code>like</code> <code>LIKE</code> <code>local_name</code> <code>LOCLNAME</code> <code>lu_name</code> <code>LUNAME</code> <code>netbios_names</code> <code>NTBNAMES</code> <code>port</code> <code>PORT</code> <code>sessions</code> <code>SESSIONS</code> <code>socket</code> <code>SOCKET</code> <code>start_mode</code> <code>CONTROL</code> <code>transaction_program_name</code> <code>TPNAME</code> <code>transport_type</code> <code>TRPTYPE</code>"},{"location":"mappings/listener/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ADAPTER</code> <code>adapter</code> <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>BACKLOG</code> <code>backlog</code> <code>COMMANDS</code> <code>commands</code> <code>CONTROL</code> <code>start_mode</code> <code>DESCR</code> <code>description</code> <code>IPADDR</code> <code>ip_address</code> <code>LISTENER</code> <code>listener_name</code> <code>LOCLNAME</code> <code>local_name</code> <code>NTBNAMES</code> <code>netbios_names</code> <code>PORT</code> <code>port</code> <code>SESSIONS</code> <code>sessions</code> <code>SOCKET</code> <code>socket</code> <code>TPNAME</code> <code>transaction_program_name</code> <code>TRPTYPE</code> <code>transport_type</code>"},{"location":"mappings/listener/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/listener/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/listener/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/log/","title":"log","text":"<p>Attribute mapping reference for the <code>log</code> qualifier.</p> <p>Related MQSC commands: <code>ARCHIVE LOG</code>, <code>DEFINE LOG</code>, <code>DISPLAY LOG</code>, <code>SET LOG</code></p>"},{"location":"mappings/log/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>deallocate_interval</code> <code>DEALLCT</code> <code>log_compression</code> <code>COMPLOG</code> <code>max_archive_log</code> <code>MAXARCH</code> <code>max_concurrent_offloads</code> <code>MAXCNOFF</code> <code>max_read_tape_units</code> <code>MAXRTU</code> <code>output_buffer_count</code> <code>WRTHRSH</code> <code>z_hyper_link</code> <code>ZHYLINK</code> <code>z_hyper_write</code> <code>ZHYWRITE</code>"},{"location":"mappings/log/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>COMMANDS</code> <code>commands</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/lsstatus/","title":"lsstatus","text":"<p>Attribute mapping reference for the <code>lsstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY LSSTATUS</code></p>"},{"location":"mappings/lsstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ADAPTER</code> <code>adapter</code> <code>BACKLOG</code> <code>backlog</code> <code>CONTROL</code> <code>start_mode</code> <code>DESCR</code> <code>description</code> <code>IPADDR</code> <code>ip_address</code> <code>LOCLNAME</code> <code>local_name</code> <code>NTBNAMES</code> <code>netbios_names</code> <code>PID</code> <code>process_id</code> <code>PORT</code> <code>port</code> <code>SESSIONS</code> <code>sessions</code> <code>SOCKET</code> <code>socket</code> <code>STARTDA</code> <code>start_date</code> <code>STARTTI</code> <code>start_time</code> <code>STATUS</code> <code>status</code> <code>TPNAME</code> <code>transaction_program_name</code> <code>TRPTYPE</code> <code>transport_type</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/namelist/","title":"namelist","text":"<p>Attribute mapping reference for the <code>namelist</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER NAMELIST</code>, <code>DEFINE NAMELIST</code>, <code>DELETE NAMELIST</code>, <code>DISPLAY NAMELIST</code></p>"},{"location":"mappings/namelist/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>description</code> <code>DESCR</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>like</code> <code>LIKE</code> <code>namelist_type</code> <code>NLTYPE</code> <code>names</code> <code>NAMES</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code>"},{"location":"mappings/namelist/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>DESCR</code> <code>description</code> <code>NAMCOUNT</code> <code>name_count</code> <code>NAMELIST</code> <code>namelist_name</code> <code>NAMES</code> <code>names</code>"},{"location":"mappings/namelist/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/namelist/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/namelist/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/policy/","title":"policy","text":"<p>Attribute mapping reference for the <code>policy</code> qualifier.</p> <p>Related MQSC commands: <code>DELETE POLICY</code>, <code>DISPLAY POLICY</code>, <code>SET POLICY</code></p>"},{"location":"mappings/policy/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>action</code> <code>ACTION</code> <code>encryption_algorithm</code> <code>ENCALG</code> <code>enforce</code> <code>ENFORCE</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>key_reuse</code> <code>KEYREUSE</code> <code>recipient</code> <code>RECIP</code> <code>sign_algorithm</code> <code>SIGNALG</code> <code>signer</code> <code>SIGNER</code> <code>tolerate</code> <code>TOLERATE</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/process/","title":"process","text":"<p>Attribute mapping reference for the <code>process</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER PROCESS</code>, <code>DEFINE PROCESS</code>, <code>DELETE PROCESS</code>, <code>DISPLAY PROCESS</code></p>"},{"location":"mappings/process/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>application_id</code> <code>APPLICID</code> <code>application_type</code> <code>APPLTYPE</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>description</code> <code>DESCR</code> <code>environment_data</code> <code>ENVRDATA</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>like</code> <code>LIKE</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code> <code>user_data</code> <code>USERDATA</code>"},{"location":"mappings/process/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>APPLICID</code> <code>application_id</code> <code>APPLTYPE</code> <code>application_type</code> <code>DESCR</code> <code>description</code> <code>ENVRDATA</code> <code>environment_data</code> <code>PROCESS</code> <code>process_name</code> <code>USERDATA</code> <code>user_data</code>"},{"location":"mappings/process/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/process/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/process/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/pubsub/","title":"pubsub","text":"<p>Attribute mapping reference for the <code>pubsub</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY PUBSUB</code></p>"},{"location":"mappings/pubsub/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>type</code> <code>TYPE</code>"},{"location":"mappings/pubsub/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>QMNAME</code> <code>queue_manager_name</code> <code>STATUS</code> <code>status</code> <code>SUBCOUNT</code> <code>subscription_count</code> <code>TPCOUNT</code> <code>topic_node_count</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/qmgr/","title":"qmgr","text":"<p>Attribute mapping reference for the <code>qmgr</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER QMGR</code>, <code>DISPLAY QMGR</code>, <code>PING QMGR</code>, <code>REFRESH QMGR</code>, <code>RESET QMGR</code>, <code>RESUME QMGR</code>, <code>START QMGR</code>, <code>STOP QMGR</code>, <code>SUSPEND QMGR</code></p>"},{"location":"mappings/qmgr/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>accounting_connection_override</code> <code>ACCTCONO</code> <code>accounting_interval</code> <code>ACCTINT</code> <code>activity_connection_override</code> <code>ACTVCONO</code> <code>activity_recording</code> <code>ACTIVREC</code> <code>activity_trace</code> <code>ACTVTRC</code> <code>adopt_new_mca_check</code> <code>ADOPTCHK</code> <code>adopt_new_mca_type</code> <code>ADOPTMCA</code> <code>authority_event</code> <code>AUTHOREV</code> <code>authority_event_scope</code> <code>AUTHEVSC</code> <code>bridge_event</code> <code>BRIDGEEV</code> <code>certificate_label</code> <code>CERTLABL</code> <code>certificate_validation_policy</code> <code>CERTVPOL</code> <code>cf_connection_lost</code> <code>CFCONLOS</code> <code>channel_authentication_records</code> <code>CHLAUTH</code> <code>channel_auto_define</code> <code>CHAD</code> <code>channel_auto_define_event</code> <code>CHADEV</code> <code>channel_auto_define_exit</code> <code>CHADEXIT</code> <code>channel_event</code> <code>CHLEV</code> <code>channel_initiator_control</code> <code>SCHINIT</code> <code>channel_monitoring</code> <code>MONCHL</code> <code>channel_statistics</code> <code>STATCHL</code> <code>chinit_adapters</code> <code>CHIADAPS</code> <code>chinit_dispatchers</code> <code>CHIDISPS</code> <code>chinit_service_parameter</code> <code>CHISERVP</code> <code>chinit_trace_auto_start</code> <code>TRAXSTR</code> <code>chinit_trace_table_size</code> <code>TRAXTBL</code> <code>cluster_namelist</code> <code>CLUSNL</code> <code>cluster_sender_monitoring_default</code> <code>MONACLS</code> <code>cluster_sender_statistics</code> <code>STATACLS</code> <code>cluster_work_load_data</code> <code>CLWLDATA</code> <code>cluster_work_load_exit</code> <code>CLWLEXIT</code> <code>cluster_work_load_length</code> <code>CLWLLEN</code> <code>cluster_workload_mru_channels</code> <code>CLWLMRUC</code> <code>cluster_workload_use_queue</code> <code>CLWLUSEQ</code> <code>coded_character_set_id</code> <code>CCSID</code> <code>command_event</code> <code>CMDEV</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>command_server_control</code> <code>SCMDSERV</code> <code>configuration_event</code> <code>CONFIGEV</code> <code>connection_authentication</code> <code>CONNAUTH</code> <code>custom</code> <code>CUSTOM</code> <code>dead_letter_queue_name</code> <code>DEADQ</code> <code>default_cluster_transmission_queue_type</code> <code>DEFCLXQ</code> <code>default_transmission_queue_name</code> <code>DEFXMITQ</code> <code>description</code> <code>DESCR</code> <code>encryption_policy_suite_b</code> <code>SUITEB</code> <code>expiry_interval</code> <code>EXPRYINT</code> <code>facility</code> <code>FACILITY</code> <code>force</code> <code>FORCE</code> <code>group_unit_of_recovery</code> <code>GROUPUR</code> <code>image_interval</code> <code>IMGINTVL</code> <code>image_log_length</code> <code>IMGLOGLN</code> <code>image_recover_object</code> <code>IMGRCOVO</code> <code>image_recover_queue</code> <code>IMGRCOVQ</code> <code>image_schedule</code> <code>IMGSCHED</code> <code>inhibit_event</code> <code>INHIBTEV</code> <code>initial_key</code> <code>INITKEY</code> <code>intragroup_queueing_put_authority</code> <code>IGQAUT</code> <code>intragroup_queueing_user_id</code> <code>IGQUSER</code> <code>ip_address_version</code> <code>IPADDRV</code> <code>listener_timer</code> <code>LSTRTMR</code> <code>local_event</code> <code>LOCALEV</code> <code>logger_event</code> <code>LOGGEREV</code> <code>lu62_arm_suffix</code> <code>LU62ARM</code> <code>lu62_channels</code> <code>LU62CHL</code> <code>lu_group_name</code> <code>LUGROUP</code> <code>lu_name</code> <code>LUNAME</code> <code>max_active_channels</code> <code>ACTCHL</code> <code>max_channels</code> <code>MAXCHL</code> <code>max_handles</code> <code>MAXHANDS</code> <code>max_message_length</code> <code>MAXMSGL</code> <code>max_properties_length</code> <code>MAXPROPL</code> <code>max_uncommitted_messages</code> <code>MAXUMSGS</code> <code>message_mark_browse_interval</code> <code>MARKINT</code> <code>mqi_accounting</code> <code>ACCTMQI</code> <code>mqi_statistics</code> <code>STATMQI</code> <code>native_ha_type</code> <code>NHATYPE</code> <code>object_type</code> <code>OBJECT</code> <code>otel_propagation_control</code> <code>OTELPCTL</code> <code>otel_trace</code> <code>OTELTRAC</code> <code>outbound_port_max</code> <code>OPORTMAX</code> <code>outbound_port_min</code> <code>OPORTMIN</code> <code>parent</code> <code>PARENT</code> <code>performance_event</code> <code>PERFMEV</code> <code>pub_sub_cluster</code> <code>PSCLUS</code> <code>pub_sub_max_message_retry_count</code> <code>PSRTYCNT</code> <code>pub_sub_mode</code> <code>PSMODE</code> <code>pub_sub_non_persistent_input_message</code> <code>PSNPMSG</code> <code>pub_sub_non_persistent_response</code> <code>PSNPRES</code> <code>pub_sub_sync_point</code> <code>PSSYNCPT</code> <code>queue_accounting</code> <code>ACCTQ</code> <code>queue_monitoring</code> <code>MONQ</code> <code>queue_sharing_group_certificate_label</code> <code>CERTQSGL</code> <code>queue_statistics</code> <code>STATQ</code> <code>receive_timeout</code> <code>RCVTIME</code> <code>receive_timeout_min</code> <code>RCVTMIN</code> <code>receive_timeout_type</code> <code>RCVTTYPE</code> <code>refresh_interval</code> <code>INCLINT</code> <code>remote_event</code> <code>REMOTEEV</code> <code>repository_name</code> <code>REPOS</code> <code>repository_namelist</code> <code>REPOSNL</code> <code>reverse_dns</code> <code>REVDNS</code> <code>security_case</code> <code>SCYCASE</code> <code>shared_queue_queue_manager_name</code> <code>SQQMNAME</code> <code>ssl_crypto_hardware</code> <code>SSLCRYP</code> <code>ssl_event</code> <code>SSLEV</code> <code>ssl_fips_required</code> <code>SSLFIPS</code> <code>ssl_key_repository</code> <code>SSLKEYR</code> <code>ssl_key_repository_password</code> <code>KEYRPWD</code> <code>ssl_key_reset_count</code> <code>SSLRKEYC</code> <code>ssl_tasks</code> <code>SSLTASKS</code> <code>sslcrl_namelist</code> <code>SSLCRLNL</code> <code>start_stop_event</code> <code>STRSTPEV</code> <code>statistics_interval</code> <code>STATINT</code> <code>status_type</code> <code>TYPE</code> <code>tcp_channels</code> <code>TCPCHL</code> <code>tcp_keep_alive</code> <code>TCPKEEP</code> <code>tcp_name</code> <code>TCPNAME</code> <code>tcp_stack_type</code> <code>TCPSTACK</code> <code>trace_route_recording</code> <code>ROUTEREC</code> <code>tree_life_time</code> <code>TREELIFE</code> <code>trigger_interval</code> <code>TRIGINT</code>"},{"location":"mappings/qmgr/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ACCTCONO</code> <code>accounting_connection_override</code> <code>ACCTINT</code> <code>accounting_interval</code> <code>ACCTMQI</code> <code>mqi_accounting</code> <code>ACCTQ</code> <code>queue_accounting</code> <code>ACTCHL</code> <code>max_active_channels</code> <code>ACTIVREC</code> <code>activity_recording</code> <code>ACTVCONO</code> <code>activity_connection_override</code> <code>ACTVTRC</code> <code>activity_trace</code> <code>ADOPTCHK</code> <code>adopt_new_mca_check</code> <code>ADOPTMCA</code> <code>adopt_new_mca_type</code> <code>ADVCAP</code> <code>advanced_capability</code> <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>AMQPCAP</code> <code>amqp_capability</code> <code>ARCHLOG</code> <code>archive_log</code> <code>ARCHSZ</code> <code>archive_log_size</code> <code>AUTHEVSC</code> <code>authority_event_scope</code> <code>AUTHOREV</code> <code>authority_event</code> <code>AUTOCLUS</code> <code>auto_cluster</code> <code>BRIDGEEV</code> <code>bridge_event</code> <code>CCSID</code> <code>coded_character_set_id</code> <code>CERTLABL</code> <code>certificate_label</code> <code>CERTQSGL</code> <code>queue_sharing_group_certificate_label</code> <code>CERTVPOL</code> <code>certificate_validation_policy</code> <code>CFCONLOS</code> <code>cf_connection_lost</code> <code>CHAD</code> <code>channel_auto_define</code> <code>CHADEV</code> <code>channel_auto_define_event</code> <code>CHADEXIT</code> <code>channel_auto_define_exit</code> <code>CHIADAPS</code> <code>chinit_adapters</code> <code>CHIDISPS</code> <code>chinit_dispatchers</code> <code>CHISERVP</code> <code>chinit_service_parameter</code> <code>CHKPTCNT</code> <code>checkpoint_count</code> <code>CHKPTOPS</code> <code>checkpoint_operations</code> <code>CHKPTSZ</code> <code>checkpoint_size</code> <code>CHLAUTH</code> <code>channel_authentication_records</code> <code>CHLEV</code> <code>channel_event</code> <code>CLWLDATA</code> <code>cluster_work_load_data</code> <code>CLWLEXIT</code> <code>cluster_work_load_exit</code> <code>CLWLLEN</code> <code>cluster_work_load_length</code> <code>CLWLMRUC</code> <code>cluster_workload_mru_channels</code> <code>CLWLUSEQ</code> <code>cluster_workload_use_queue</code> <code>CMDEV</code> <code>command_event</code> <code>CMDLEVEL</code> <code>command_level</code> <code>CMDSERV</code> <code>command_server_status</code> <code>COMMANDQ</code> <code>command_input_queue_name</code> <code>CONFIGEV</code> <code>configuration_event</code> <code>CONNAUTH</code> <code>connection_authentication</code> <code>CPILEVEL</code> <code>cpi_level</code> <code>CRDATE</code> <code>creation_date</code> <code>CRTIME</code> <code>creation_time</code> <code>CURRLOG</code> <code>current_log</code> <code>CUSTOM</code> <code>custom</code> <code>DATFSSZ</code> <code>data_filesystem_size</code> <code>DATFSUSE</code> <code>data_filesystem_use</code> <code>DATPATH</code> <code>data_path</code> <code>DEADQ</code> <code>dead_letter_queue_name</code> <code>DEFCLXQ</code> <code>default_cluster_transmission_queue_type</code> <code>DEFXMITQ</code> <code>default_transmission_queue_name</code> <code>DESCR</code> <code>description</code> <code>DISKLSN</code> <code>disk_log_sequence_number</code> <code>DISTL</code> <code>distribution_lists</code> <code>EXPRYINT</code> <code>expiry_interval</code> <code>GROUPUR</code> <code>group_unit_of_recovery</code> <code>GRPLSN</code> <code>group_log_sequence_number</code> <code>GRPNAME</code> <code>group_name</code> <code>GRPROLE</code> <code>group_role</code> <code>HOSTNAME</code> <code>host_name</code> <code>IGQAUT</code> <code>intragroup_queueing_put_authority</code> <code>IGQUSER</code> <code>intragroup_queueing_user_id</code> <code>IMGINTVL</code> <code>image_interval</code> <code>IMGLOGLN</code> <code>image_log_length</code> <code>IMGRCOVO</code> <code>image_recover_object</code> <code>IMGRCOVQ</code> <code>image_recover_queue</code> <code>IMGSCHED</code> <code>image_schedule</code> <code>INHIBTEV</code> <code>inhibit_event</code> <code>INITKEY</code> <code>initial_key</code> <code>INSTANCE</code> <code>instance</code> <code>INSTDESC</code> <code>installation_description</code> <code>INSTNAME</code> <code>installation_name</code> <code>INSTPATH</code> <code>installation_path</code> <code>IPADDRV</code> <code>ip_address_version</code> <code>KEYRPWD</code> <code>ssl_key_repository_password</code> <code>LDAPCONN</code> <code>ldap_connection_status</code> <code>LOCALEV</code> <code>local_event</code> <code>LOGEXTSZ</code> <code>log_ext_size</code> <code>LOGFSSZ</code> <code>log_filesystem_size</code> <code>LOGFSUSE</code> <code>log_filesystem_use</code> <code>LOGGEREV</code> <code>logger_event</code> <code>LOGINUSE</code> <code>log_in_use</code> <code>LOGPATH</code> <code>log_path</code> <code>LOGPRIM</code> <code>log_primary</code> <code>LOGSEC</code> <code>log_secondary</code> <code>LOGSTRDA</code> <code>log_start_date</code> <code>LOGSTRL</code> <code>log_start_log_sequence_number</code> <code>LOGSTRTI</code> <code>log_start_time</code> <code>LOGTYPE</code> <code>log_type</code> <code>LOGUTIL</code> <code>log_utilization</code> <code>LSTRTMR</code> <code>listener_timer</code> <code>LU62ARM</code> <code>lu62_arm_suffix</code> <code>LU62CHL</code> <code>lu62_channels</code> <code>LUGROUP</code> <code>lu_group_name</code> <code>LUNAME</code> <code>lu_name</code> <code>MARKINT</code> <code>message_mark_browse_interval</code> <code>MAXCHL</code> <code>max_channels</code> <code>MAXHANDS</code> <code>max_handles</code> <code>MAXMSGL</code> <code>max_message_length</code> <code>MAXPROPL</code> <code>max_properties_length</code> <code>MAXPRTY</code> <code>max_priority</code> <code>MAXUMSGS</code> <code>max_uncommitted_messages</code> <code>MEDIALOG</code> <code>media_recovery_log_extent</code> <code>MEDIASZ</code> <code>media_recovery_log_size</code> <code>MONACLS</code> <code>cluster_sender_monitoring_default</code> <code>MONCHL</code> <code>channel_monitoring</code> <code>MONQ</code> <code>queue_monitoring</code> <code>OPORTMAX</code> <code>outbound_port_max</code> <code>OPORTMIN</code> <code>outbound_port_min</code> <code>OTELPCTL</code> <code>otel_propagation_control</code> <code>OTELTRAC</code> <code>otel_trace</code> <code>PARENT</code> <code>parent</code> <code>PERFMEV</code> <code>performance_event</code> <code>PLATFORM</code> <code>platform</code> <code>PSCLUS</code> <code>pub_sub_cluster</code> <code>PSMODE</code> <code>pub_sub_mode</code> <code>PSNPMSG</code> <code>pub_sub_non_persistent_input_message</code> <code>PSNPRES</code> <code>pub_sub_non_persistent_response</code> <code>PSRTYCNT</code> <code>pub_sub_max_message_retry_count</code> <code>PSSYNCPT</code> <code>pub_sub_sync_point</code> <code>QMFSENC</code> <code>queue_manager_encryption</code> <code>QMFSSZ</code> <code>queue_manager_filesystem_size</code> <code>QMFSUSE</code> <code>queue_manager_filesystem_use</code> <code>QMID</code> <code>queue_manager_id</code> <code>QMNAME</code> <code>queue_manager_name</code> <code>QSGNAME</code> <code>queue_sharing_group_name</code> <code>QUORUM</code> <code>quorum</code> <code>RCVTIME</code> <code>receive_timeout</code> <code>RCVTMIN</code> <code>receive_timeout_min</code> <code>RCVTTYPE</code> <code>receive_timeout_type</code> <code>REMOTEEV</code> <code>remote_event</code> <code>REPOS</code> <code>repository_name</code> <code>REPOSNL</code> <code>repository_namelist</code> <code>REUSESZ</code> <code>reusable_log_size</code> <code>REVDNS</code> <code>reverse_dns</code> <code>ROUTEREC</code> <code>trace_route_recording</code> <code>SCHINIT</code> <code>channel_initiator_control</code> <code>SCMDSERV</code> <code>command_server_control</code> <code>SCYCASE</code> <code>security_case</code> <code>SPLCAP</code> <code>security_policy_capability</code> <code>SQQMNAME</code> <code>shared_queue_queue_manager_name</code> <code>SSLCRLNL</code> <code>sslcrl_namelist</code> <code>SSLCRYP</code> <code>ssl_crypto_hardware</code> <code>SSLEV</code> <code>ssl_event</code> <code>SSLFIPS</code> <code>ssl_fips_required</code> <code>SSLKEYR</code> <code>ssl_key_repository</code> <code>SSLRKEYC</code> <code>ssl_key_reset_count</code> <code>SSLTASKS</code> <code>ssl_tasks</code> <code>STANDBY</code> <code>permit_standby</code> <code>STARTDA</code> <code>start_date</code> <code>STARTTI</code> <code>start_time</code> <code>STATACLS</code> <code>cluster_sender_statistics</code> <code>STATCHL</code> <code>channel_statistics</code> <code>STATINT</code> <code>statistics_interval</code> <code>STATMQI</code> <code>mqi_statistics</code> <code>STATQ</code> <code>queue_statistics</code> <code>STATUS</code> <code>ha_status</code> <code>STRSTPEV</code> <code>start_stop_event</code> <code>SUITEB</code> <code>encryption_policy_suite_b</code> <code>SYNCPT</code> <code>sync_point</code> <code>TCPCHL</code> <code>tcp_channels</code> <code>TCPKEEP</code> <code>tcp_keep_alive</code> <code>TCPNAME</code> <code>tcp_name</code> <code>TCPSTACK</code> <code>tcp_stack_type</code> <code>TRAXSTR</code> <code>chinit_trace_auto_start</code> <code>TRAXTBL</code> <code>chinit_trace_table_size</code> <code>TREELIFE</code> <code>tree_life_time</code> <code>TRIGINT</code> <code>trigger_interval</code> <code>UNICLUS</code> <code>uniform_cluster_name</code> <code>VERSION</code> <code>version</code> <code>XRCAP</code> <code>telemetry_capability</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/qmstatus/","title":"qmstatus","text":"<p>Attribute mapping reference for the <code>qmstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY QMSTATUS</code></p>"},{"location":"mappings/qmstatus/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>native_ha_type</code> <code>NHATYPE</code> <code>status_type</code> <code>TYPE</code>"},{"location":"mappings/qmstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ARCHLOG</code> <code>archive_log</code> <code>ARCHSZ</code> <code>archive_log_size</code> <code>AUTOCLUS</code> <code>auto_cluster</code> <code>CHINIT</code> <code>channel_initiator_status</code> <code>CHKPTCNT</code> <code>checkpoint_count</code> <code>CHKPTOPS</code> <code>checkpoint_operations</code> <code>CHKPTSZ</code> <code>checkpoint_size</code> <code>CMDSERV</code> <code>command_server_status</code> <code>CONNS</code> <code>connections</code> <code>CURRLOG</code> <code>current_log</code> <code>DATFSSZ</code> <code>data_filesystem_size</code> <code>DATFSUSE</code> <code>data_filesystem_use</code> <code>DATPATH</code> <code>data_path</code> <code>DISKLSN</code> <code>disk_log_sequence_number</code> <code>GRPLSN</code> <code>group_log_sequence_number</code> <code>GRPNAME</code> <code>group_name</code> <code>GRPROLE</code> <code>group_role</code> <code>HOSTNAME</code> <code>host_name</code> <code>INSTANCE</code> <code>instance</code> <code>INSTDESC</code> <code>installation_description</code> <code>INSTNAME</code> <code>installation_name</code> <code>INSTPATH</code> <code>installation_path</code> <code>LDAPCONN</code> <code>ldap_connection_status</code> <code>LOGEXTSZ</code> <code>log_ext_size</code> <code>LOGFSSZ</code> <code>log_filesystem_size</code> <code>LOGFSUSE</code> <code>log_filesystem_use</code> <code>LOGINUSE</code> <code>log_in_use</code> <code>LOGPATH</code> <code>log_path</code> <code>LOGPRIM</code> <code>log_primary</code> <code>LOGSEC</code> <code>log_secondary</code> <code>LOGSTRDA</code> <code>log_start_date</code> <code>LOGSTRL</code> <code>log_start_log_sequence_number</code> <code>LOGSTRTI</code> <code>log_start_time</code> <code>LOGTYPE</code> <code>log_type</code> <code>LOGUTIL</code> <code>log_utilization</code> <code>MEDIALOG</code> <code>media_recovery_log_extent</code> <code>MEDIASZ</code> <code>media_recovery_log_size</code> <code>QMFSENC</code> <code>queue_manager_encryption</code> <code>QMFSSZ</code> <code>queue_manager_filesystem_size</code> <code>QMFSUSE</code> <code>queue_manager_filesystem_use</code> <code>QMNAME</code> <code>queue_manager_name</code> <code>QUORUM</code> <code>quorum</code> <code>RECLOG</code> <code>recovery_log</code> <code>RECSZ</code> <code>recovery_log_size</code> <code>REUSESZ</code> <code>reusable_log_size</code> <code>STANDBY</code> <code>permit_standby</code> <code>STARTDA</code> <code>start_date</code> <code>STARTTI</code> <code>start_time</code> <code>STATUS</code> <code>ha_status</code> <code>TYPE</code> <code>status_type</code> <code>UNICLUS</code> <code>uniform_cluster_name</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/qstatus/","title":"qstatus","text":"<p>Attribute mapping reference for the <code>qstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY QSTATUS</code></p>"},{"location":"mappings/qstatus/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code>"},{"location":"mappings/qstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>APPLDESC</code> <code>application_description</code> <code>APPLTAG</code> <code>application_tag</code> <code>APPLTYPE</code> <code>application_type</code> <code>ASID</code> <code>address_space_id</code> <code>ASTATE</code> <code>asynchronous_state</code> <code>BROWSE</code> <code>open_browse</code> <code>CHANNEL</code> <code>channel_name</code> <code>CONNAME</code> <code>connection_name</code> <code>CURDEPTH</code> <code>current_queue_depth</code> <code>CURFSIZE</code> <code>current_queue_file_size</code> <code>CURMAXFS</code> <code>current_max_queue_file_size</code> <code>HSTATE</code> <code>handle_state</code> <code>INPUT</code> <code>open_input</code> <code>INQUIRE</code> <code>open_inquire</code> <code>IPPROCS</code> <code>open_input_count</code> <code>LGETDATE</code> <code>last_get_date</code> <code>LGETTIME</code> <code>last_get_time</code> <code>LPUTDATE</code> <code>last_put_date</code> <code>LPUTTIME</code> <code>last_put_time</code> <code>MEDIALOG</code> <code>media_recovery_log_extent</code> <code>MONQ</code> <code>queue_monitoring</code> <code>MSGAGE</code> <code>oldest_message_age</code> <code>OPPROCS</code> <code>open_output_count</code> <code>OUTPUT</code> <code>open_output</code> <code>PID</code> <code>process_id</code> <code>PSBNAME</code> <code>program_spec_block_name</code> <code>PSTID</code> <code>partition_spec_table_region_id</code> <code>QMURID</code> <code>queue_manager_unit_of_work_id</code> <code>QSGDISP</code> <code>queue_sharing_group_disposition</code> <code>QTIME</code> <code>on_queue_time</code> <code>QUEUE</code> <code>queue_name</code> <code>SET</code> <code>open_set</code> <code>TASKNO</code> <code>task_number</code> <code>TID</code> <code>thread_id</code> <code>TRANSID</code> <code>transaction_id</code> <code>TYPE</code> <code>status_type</code> <code>UNCOM</code> <code>uncommitted_messages</code> <code>URID</code> <code>unit_of_work_id</code> <code>URTYPE</code> <code>unit_of_work_type</code> <code>USERID</code> <code>user_id</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/queue/","title":"queue","text":"<p>Attribute mapping reference for the <code>queue</code> qualifier.</p> <p>Related MQSC commands: <code>CLEAR QLOCAL</code>, <code>DELETE QALIAS</code>, <code>DELETE QLOCAL</code>, <code>DELETE QMODEL</code>, <code>DELETE QREMOTE</code>, <code>DISPLAY QUEUE</code>, <code>MOVE QLOCAL</code>, <code>RESET QSTATS</code></p>"},{"location":"mappings/queue/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>authorization_record</code> <code>AUTHREC</code> <code>backout_requeue_name</code> <code>BOQNAME</code> <code>backout_threshold</code> <code>BOTHRESH</code> <code>cf_struct_name</code> <code>CFSTRUCT</code> <code>cluster_channel_name</code> <code>CLCHNAME</code> <code>cluster_name</code> <code>CLUSTER</code> <code>cluster_namelist</code> <code>CLUSNL</code> <code>cluster_workload_priority</code> <code>CLWLPRTY</code> <code>cluster_workload_rank</code> <code>CLWLRANK</code> <code>cluster_workload_use_queue</code> <code>CLWLUSEQ</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>custom</code> <code>CUSTOM</code> <code>default_bind</code> <code>DEFBIND</code> <code>default_input_open_option</code> <code>DEFSOPT</code> <code>default_persistence</code> <code>DEFPSIST</code> <code>default_priority</code> <code>DEFPRTY</code> <code>default_put_response</code> <code>DEFPRESP</code> <code>default_read_ahead</code> <code>DEFREADA</code> <code>definition_type</code> <code>DEFTYPE</code> <code>description</code> <code>DESCR</code> <code>distribution_lists</code> <code>DISTL</code> <code>force</code> <code>FORCE</code> <code>harden_get_backout</code> <code>HARDENBO</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>image_recover_queue</code> <code>IMGRCOVQ</code> <code>inhibit_get</code> <code>GET</code> <code>inhibit_put</code> <code>PUT</code> <code>initiation_queue_name</code> <code>INITQ</code> <code>like</code> <code>LIKE</code> <code>max_message_length</code> <code>MAXMSGL</code> <code>max_queue_depth</code> <code>MAXDEPTH</code> <code>max_queue_file_size</code> <code>MAXFSIZE</code> <code>message_delivery_sequence</code> <code>MSGDLVSQ</code> <code>non_persistent_message_class</code> <code>NPMCLASS</code> <code>page_set_id</code> <code>PSID</code> <code>process_name</code> <code>PROCESS</code> <code>property_control</code> <code>PROPCTL</code> <code>queue_accounting</code> <code>ACCTQ</code> <code>queue_depth_high_event</code> <code>QDPHIEV</code> <code>queue_depth_high_limit</code> <code>QDEPTHHI</code> <code>queue_depth_low_event</code> <code>QDPLOEV</code> <code>queue_depth_low_limit</code> <code>QDEPTHLO</code> <code>queue_depth_max_event</code> <code>QDPMAXEV</code> <code>queue_monitoring</code> <code>MONQ</code> <code>queue_service_interval</code> <code>QSVCINT</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code> <code>queue_statistics</code> <code>STATQ</code> <code>remote_queue_manager_name</code> <code>RQMNAME</code> <code>remote_queue_name</code> <code>RNAME</code> <code>retention_interval</code> <code>RETINTVL</code> <code>scope</code> <code>SCOPE</code> <code>shareability</code> <code>SHARE</code> <code>storage_class</code> <code>STGCLASS</code> <code>stream_queue</code> <code>STREAMQ</code> <code>stream_queue_service</code> <code>STRMQOS</code> <code>target_queue_name</code> <code>TARGET</code> <code>target_type</code> <code>TARGTYPE</code> <code>to_queue_name</code> <code>TOQLOCAL</code> <code>transmission_queue_name</code> <code>XMITQ</code> <code>trigger_control</code> <code>TRIGGER</code> <code>trigger_data</code> <code>TRIGDATA</code> <code>trigger_depth</code> <code>TRIGDPTH</code> <code>trigger_message_priority</code> <code>TRIGMPRI</code> <code>trigger_type</code> <code>TRIGTYPE</code> <code>usage</code> <code>USAGE</code>"},{"location":"mappings/queue/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ACCTQ</code> <code>queue_accounting</code> <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>APPLDESC</code> <code>application_description</code> <code>APPLTAG</code> <code>application_tag</code> <code>APPLTYPE</code> <code>application_type</code> <code>ASID</code> <code>address_space_id</code> <code>ASTATE</code> <code>asynchronous_state</code> <code>BOQNAME</code> <code>backout_requeue_name</code> <code>BOTHRESH</code> <code>backout_threshold</code> <code>BROWSE</code> <code>open_browse</code> <code>CAPEXPRY</code> <code>cap_expiry</code> <code>CFSTRUCT</code> <code>cf_struct_name</code> <code>CHANNEL</code> <code>channel_name</code> <code>CLCHNAME</code> <code>cluster_channel_name</code> <code>CLUSDATE</code> <code>cluster_date</code> <code>CLUSNL</code> <code>cluster_namelist</code> <code>CLUSQMGR</code> <code>cluster_queue_manager</code> <code>CLUSQT</code> <code>cluster_queue_type</code> <code>CLUSTER</code> <code>cluster_name</code> <code>CLUSTIME</code> <code>cluster_time</code> <code>CLWLPRTY</code> <code>cluster_workload_priority</code> <code>CLWLRANK</code> <code>cluster_workload_rank</code> <code>CLWLUSEQ</code> <code>cluster_workload_use_queue</code> <code>CONNAME</code> <code>connection_name</code> <code>CRDATE</code> <code>creation_date</code> <code>CRTIME</code> <code>creation_time</code> <code>CURDEPTH</code> <code>current_queue_depth</code> <code>CURFSIZE</code> <code>current_queue_file_size</code> <code>CURMAXFS</code> <code>current_max_queue_file_size</code> <code>CUSTOM</code> <code>custom</code> <code>DEFBIND</code> <code>default_bind</code> <code>DEFPRESP</code> <code>default_put_response</code> <code>DEFPRTY</code> <code>default_priority</code> <code>DEFPSIST</code> <code>default_persistence</code> <code>DEFREADA</code> <code>default_read_ahead</code> <code>DEFSOPT</code> <code>default_input_open_option</code> <code>DEFTYPE</code> <code>definition_type</code> <code>DESCR</code> <code>description</code> <code>DISTL</code> <code>distribution_lists</code> <code>GET</code> <code>inhibit_get</code> <code>HARDENBO</code> <code>harden_get_backout</code> <code>HSTATE</code> <code>handle_state</code> <code>IMGRCOVQ</code> <code>image_recover_queue</code> <code>INDXTYPE</code> <code>index_type</code> <code>INITQ</code> <code>initiation_queue_name</code> <code>INQUIRE</code> <code>open_inquire</code> <code>IPPROCS</code> <code>open_input_count</code> <code>LGETDATE</code> <code>last_get_date</code> <code>LGETTIME</code> <code>last_get_time</code> <code>LPUTDATE</code> <code>last_put_date</code> <code>LPUTTIME</code> <code>last_put_time</code> <code>MAXDEPTH</code> <code>max_queue_depth</code> <code>MAXFSIZE</code> <code>max_queue_file_size</code> <code>MAXMSGL</code> <code>max_message_length</code> <code>MEDIALOG</code> <code>media_recovery_log_extent</code> <code>MONQ</code> <code>queue_monitoring</code> <code>MSGAGE</code> <code>oldest_message_age</code> <code>MSGDLVSQ</code> <code>message_delivery_sequence</code> <code>NOSHARE</code> <code>no_share</code> <code>NOTRIGGER</code> <code>no_trigger</code> <code>NPMCLASS</code> <code>non_persistent_message_class</code> <code>OPPROCS</code> <code>open_output_count</code> <code>OTELPCTL</code> <code>otel_propagation_control</code> <code>OTELTRAC</code> <code>otel_trace</code> <code>OUTPUT</code> <code>open_output</code> <code>PID</code> <code>process_id</code> <code>PROCESS</code> <code>process_name</code> <code>PROPCTL</code> <code>property_control</code> <code>PSBNAME</code> <code>program_spec_block_name</code> <code>PSID</code> <code>page_set_id</code> <code>PSTID</code> <code>partition_spec_table_region_id</code> <code>PUT</code> <code>inhibit_put</code> <code>QDEPTHHI</code> <code>queue_depth_high_limit</code> <code>QDEPTHLO</code> <code>queue_depth_low_limit</code> <code>QDPHIEV</code> <code>queue_depth_high_event</code> <code>QDPLOEV</code> <code>queue_depth_low_event</code> <code>QDPMAXEV</code> <code>queue_depth_max_event</code> <code>QMID</code> <code>queue_manager_id</code> <code>QMURID</code> <code>queue_manager_unit_of_work_id</code> <code>QSGDISP</code> <code>queue_sharing_group_disposition</code> <code>QSVCIEV</code> <code>queue_service_interval_event</code> <code>QSVCINT</code> <code>queue_service_interval</code> <code>QTIME</code> <code>on_queue_time</code> <code>QTYPE</code> <code>queue_type</code> <code>QUEUE</code> <code>queue_name</code> <code>RETINTVL</code> <code>retention_interval</code> <code>RNAME</code> <code>remote_queue_name</code> <code>RQMNAME</code> <code>remote_queue_manager_name</code> <code>SCOPE</code> <code>scope</code> <code>SET</code> <code>open_set</code> <code>SHARE</code> <code>shareability</code> <code>STATQ</code> <code>queue_statistics</code> <code>STGCLASS</code> <code>storage_class</code> <code>STREAMQ</code> <code>stream_queue</code> <code>STRMQOS</code> <code>stream_queue_service</code> <code>TARGET</code> <code>target_queue_name</code> <code>TARGTYPE</code> <code>target_type</code> <code>TASKNO</code> <code>task_number</code> <code>TID</code> <code>thread_id</code> <code>TPIPE</code> <code>tpipe_names</code> <code>TRANSID</code> <code>transaction_id</code> <code>TRIGDATA</code> <code>trigger_data</code> <code>TRIGDPTH</code> <code>trigger_depth</code> <code>TRIGGER</code> <code>trigger_control</code> <code>TRIGMPRI</code> <code>trigger_message_priority</code> <code>TRIGTYPE</code> <code>trigger_type</code> <code>TYPE</code> <code>type</code> <code>UNCOM</code> <code>uncommitted_messages</code> <code>URID</code> <code>unit_of_work_id</code> <code>URTYPE</code> <code>unit_of_work_type</code> <code>USAGE</code> <code>usage</code> <code>USERID</code> <code>user_id</code> <code>XMITQ</code> <code>transmission_queue_name</code>"},{"location":"mappings/queue/#request-value-map","title":"Request value map","text":""},{"location":"mappings/queue/#default_persistence","title":"default_persistence","text":"Friendly value MQSC value <code>def</code> <code>DEF</code> <code>no</code> <code>NO</code> <code>not_fixed</code> <code>NOTFIXED</code> <code>yes</code> <code>YES</code>"},{"location":"mappings/queue/#response-value-map","title":"Response value map","text":""},{"location":"mappings/queue/#defpsist","title":"DEFPSIST","text":"MQSC value Friendly value <code>DEF</code> <code>def</code> <code>NO</code> <code>no</code> <code>NOTFIXED</code> <code>not_fixed</code> <code>YES</code> <code>yes</code>"},{"location":"mappings/queue/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/queue/#nopurge","title":"nopurge","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>PURGE</code> <code>NO</code>"},{"location":"mappings/queue/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/queue/#purge","title":"purge","text":"Friendly value MQSC key MQSC value <code>no</code> <code>PURGE</code> <code>NO</code> <code>yes</code> <code>PURGE</code> <code>YES</code>"},{"location":"mappings/queue/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/sbstatus/","title":"sbstatus","text":"<p>Attribute mapping reference for the <code>sbstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY SBSTATUS</code></p>"},{"location":"mappings/sbstatus/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>durable</code> <code>DURABLE</code> <code>subscription_type</code> <code>SUBTYPE</code>"},{"location":"mappings/sbstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ACTCONN</code> <code>active_connection</code> <code>DURABLE</code> <code>durable</code> <code>LMSGDATE</code> <code>last_message_date</code> <code>LMSGTIME</code> <code>last_message_time</code> <code>MCASTREL</code> <code>multicast_reliability_indicator</code> <code>NUMMSGS</code> <code>number_of_messages</code> <code>RESMDATE</code> <code>resume_date</code> <code>RESMTIME</code> <code>resume_time</code> <code>SUBID</code> <code>subscription_id</code> <code>SUBTYPE</code> <code>subscription_type</code> <code>SUBUSER</code> <code>subscription_user_id</code> <code>TOPICSTR</code> <code>topic_string</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/security/","title":"security","text":"<p>Attribute mapping reference for the <code>security</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER SECURITY</code>, <code>DISPLAY SECURITY</code>, <code>REFRESH SECURITY</code>, <code>RVERIFY SECURITY</code></p>"},{"location":"mappings/security/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>security_interval</code> <code>INTERVAL</code> <code>security_timeout</code> <code>TIMEOUT</code> <code>security_type</code> <code>TYPE</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/service/","title":"service","text":"<p>Attribute mapping reference for the <code>service</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER SERVICE</code>, <code>DEFINE SERVICE</code>, <code>DELETE SERVICE</code>, <code>DISPLAY SERVICE</code>, <code>START SERVICE</code>, <code>STOP SERVICE</code></p>"},{"location":"mappings/service/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>description</code> <code>DESCR</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>like</code> <code>LIKE</code> <code>service_type</code> <code>SERVTYPE</code> <code>start_arguments</code> <code>STARTARG</code> <code>start_command</code> <code>STARTCMD</code> <code>start_mode</code> <code>CONTROL</code> <code>stderr_destination</code> <code>STDERR</code> <code>stdout_destination</code> <code>STDOUT</code> <code>stop_arguments</code> <code>STOPARG</code> <code>stop_command</code> <code>STOPCMD</code>"},{"location":"mappings/service/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>CONTROL</code> <code>start_mode</code> <code>DESCR</code> <code>description</code> <code>SERVTYPE</code> <code>service_type</code> <code>STARTARG</code> <code>start_arguments</code> <code>STARTCMD</code> <code>start_command</code> <code>STDERR</code> <code>stderr_destination</code> <code>STDOUT</code> <code>stdout_destination</code> <code>STOPARG</code> <code>stop_arguments</code> <code>STOPCMD</code> <code>stop_command</code>"},{"location":"mappings/service/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/service/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/service/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/smds/","title":"smds","text":"<p>Attribute mapping reference for the <code>smds</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER SMDS</code>, <code>DISPLAY SMDS</code>, <code>RESET SMDS</code></p>"},{"location":"mappings/smds/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>access</code> <code>ACCESS</code> <code>cf_struct_name</code> <code>CFSTRUCT</code> <code>data_sharing_buffers</code> <code>DSBUFS</code> <code>data_sharing_expand</code> <code>DSEXPAND</code> <code>status</code> <code>STATUS</code>"},{"location":"mappings/smds/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>CFSTRUCT</code> <code>cf_struct_name</code> <code>DSBUFS</code> <code>data_sharing_buffers</code> <code>DSEXPAND</code> <code>data_sharing_expand</code> <code>SMDS</code> <code>shared_message_dataset</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/smdsconn/","title":"smdsconn","text":"<p>Attribute mapping reference for the <code>smdsconn</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY SMDSCONN</code>, <code>START SMDSCONN</code>, <code>STOP SMDSCONN</code></p>"},{"location":"mappings/smdsconn/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>cf_struct_name</code> <code>CFSTRUCT</code> <code>command_scope</code> <code>CMDSCOPE</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/stgclass/","title":"stgclass","text":"<p>Attribute mapping reference for the <code>stgclass</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER STGCLASS</code>, <code>DEFINE STGCLASS</code>, <code>DELETE STGCLASS</code>, <code>DISPLAY STGCLASS</code></p>"},{"location":"mappings/stgclass/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>description</code> <code>DESCR</code> <code>like</code> <code>LIKE</code> <code>page_set_id</code> <code>PSID</code> <code>pass_ticket_application</code> <code>PASSTKTA</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code> <code>xcf_group_name</code> <code>XCFGNAME</code> <code>xcf_member_name</code> <code>XCFMNAME</code>"},{"location":"mappings/stgclass/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>DESCR</code> <code>description</code> <code>PASSTKTA</code> <code>pass_ticket_application</code> <code>XCFGNAME</code> <code>xcf_group_name</code> <code>XCFMNAME</code> <code>xcf_member_name</code>"},{"location":"mappings/stgclass/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/stgclass/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/stgclass/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/sub/","title":"sub","text":"<p>Attribute mapping reference for the <code>sub</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER SUB</code>, <code>DEFINE SUB</code>, <code>DELETE SUB</code>, <code>DISPLAY SUB</code></p>"},{"location":"mappings/sub/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>alteration_date</code> <code>ALTDATE</code> <code>alteration_time</code> <code>ALTTIME</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>creation_date</code> <code>CRDATE</code> <code>creation_time</code> <code>CRTIME</code> <code>destination</code> <code>DEST</code> <code>destination_class</code> <code>DESTCLAS</code> <code>destination_correlation_id</code> <code>DESTCORL</code> <code>destination_queue_manager</code> <code>DESTQMGR</code> <code>display_type</code> <code>DISTYPE</code> <code>durable</code> <code>DURABLE</code> <code>expiry</code> <code>EXPIRY</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>publish_priority</code> <code>PUBPRTY</code> <code>publish_subscribe_properties</code> <code>PSPROP</code> <code>published_accounting_token</code> <code>PUBACCT</code> <code>published_application_id</code> <code>PUBAPPID</code> <code>request_only</code> <code>REQONLY</code> <code>selector</code> <code>SELECTOR</code> <code>selector_type</code> <code>SELTYPE</code> <code>subscription_id</code> <code>SUBID</code> <code>subscription_level</code> <code>SUBLEVEL</code> <code>subscription_type</code> <code>SUBTYPE</code> <code>subscription_user_id</code> <code>SUBUSER</code> <code>topic_object</code> <code>TOPICOBJ</code> <code>topic_string</code> <code>TOPICSTR</code> <code>user_data</code> <code>USERDATA</code> <code>variable_user</code> <code>VARUSER</code> <code>wildcard_schema</code> <code>WSCHEMA</code>"},{"location":"mappings/sub/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>CMDSCOPE</code> <code>command_scope</code> <code>CRDATE</code> <code>creation_date</code> <code>CRTIME</code> <code>creation_time</code> <code>DEST</code> <code>destination</code> <code>DESTCLAS</code> <code>destination_class</code> <code>DESTCORL</code> <code>destination_correlation_id</code> <code>DESTQMGR</code> <code>destination_queue_manager</code> <code>DISTYPE</code> <code>display_type</code> <code>DURABLE</code> <code>durable</code> <code>EXPIRY</code> <code>expiry</code> <code>PSPROP</code> <code>publish_subscribe_properties</code> <code>PUBACCT</code> <code>published_accounting_token</code> <code>PUBAPPID</code> <code>published_application_id</code> <code>PUBPRTY</code> <code>publish_priority</code> <code>REQONLY</code> <code>request_only</code> <code>SELECTOR</code> <code>selector</code> <code>SELTYPE</code> <code>selector_type</code> <code>SUB</code> <code>subscription_name</code> <code>SUBID</code> <code>subscription_id</code> <code>SUBLEVEL</code> <code>subscription_level</code> <code>SUBTYPE</code> <code>subscription_type</code> <code>SUBUSER</code> <code>subscription_user_id</code> <code>TOPICOBJ</code> <code>topic_object</code> <code>TOPICSTR</code> <code>topic_string</code> <code>USERDATA</code> <code>user_data</code> <code>VARUSER</code> <code>variable_user</code> <code>WSCHEMA</code> <code>wildcard_schema</code>"},{"location":"mappings/sub/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/sub/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/sub/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/svstatus/","title":"svstatus","text":"<p>Attribute mapping reference for the <code>svstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY SVSTATUS</code></p>"},{"location":"mappings/svstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>CONTROL</code> <code>start_mode</code> <code>DESCR</code> <code>description</code> <code>PID</code> <code>process_id</code> <code>SERVTYPE</code> <code>service_type</code> <code>STARTARG</code> <code>start_arguments</code> <code>STARTCMD</code> <code>start_command</code> <code>STARTDA</code> <code>start_date</code> <code>STARTTI</code> <code>start_time</code> <code>STATUS</code> <code>status</code> <code>STDERR</code> <code>stderr_destination</code> <code>STDOUT</code> <code>stdout_destination</code> <code>STOPARG</code> <code>stop_arguments</code> <code>STOPCMD</code> <code>stop_command</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/topic/","title":"topic","text":"<p>Attribute mapping reference for the <code>topic</code> qualifier.</p> <p>Related MQSC commands: <code>ALTER TOPIC</code>, <code>DEFINE TOPIC</code>, <code>DELETE TOPIC</code>, <code>DISPLAY TOPIC</code></p>"},{"location":"mappings/topic/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>authorization_record</code> <code>AUTHREC</code> <code>cap_expiry</code> <code>CAPEXPRY</code> <code>cluster_name</code> <code>CLUSTER</code> <code>cluster_publish_route</code> <code>CLROUTE</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>communication_info</code> <code>COMMINFO</code> <code>custom</code> <code>CUSTOM</code> <code>default_persistence</code> <code>DEFPSIST</code> <code>default_priority</code> <code>DEFPRTY</code> <code>default_put_response</code> <code>DEFPRESP</code> <code>description</code> <code>DESCR</code> <code>durable_model_queue_name</code> <code>MDURMDL</code> <code>durable_subscriptions</code> <code>DURSUB</code> <code>ignore_state</code> <code>IGNSTATE</code> <code>like</code> <code>LIKE</code> <code>multicast</code> <code>MCAST</code> <code>non_durable_model_queue_name</code> <code>MNDURMDL</code> <code>non_persistent_message_delivery</code> <code>NPMSGDLV</code> <code>persistent_message_delivery</code> <code>PMSGDLV</code> <code>proxy_subscriptions</code> <code>PROXYSUB</code> <code>publication_scope</code> <code>PUBSCOPE</code> <code>queue_sharing_group_disposition</code> <code>QSGDISP</code> <code>subscription_scope</code> <code>SUBSCOPE</code> <code>topic_string</code> <code>TOPICSTR</code> <code>topic_type</code> <code>TYPE</code> <code>use_dead_letter_queue</code> <code>USEDLQ</code> <code>wildcard_operation</code> <code>WILDCARD</code>"},{"location":"mappings/topic/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ALTDATE</code> <code>alteration_date</code> <code>ALTTIME</code> <code>alteration_time</code> <code>CAPEXPRY</code> <code>cap_expiry</code> <code>CLROUTE</code> <code>cluster_publish_route</code> <code>CLSTATE</code> <code>cluster_object_state</code> <code>CLUSTER</code> <code>cluster_name</code> <code>COMMINFO</code> <code>communication_info</code> <code>CUSTOM</code> <code>custom</code> <code>DEFPRESP</code> <code>default_put_response</code> <code>DEFPRTY</code> <code>default_priority</code> <code>DEFPSIST</code> <code>default_persistence</code> <code>DESCR</code> <code>description</code> <code>DURSUB</code> <code>durable_subscriptions</code> <code>MCAST</code> <code>multicast</code> <code>MDURMDL</code> <code>durable_model_queue_name</code> <code>MNDURMDL</code> <code>non_durable_model_queue_name</code> <code>NPMSGDLV</code> <code>non_persistent_message_delivery</code> <code>PMSGDLV</code> <code>persistent_message_delivery</code> <code>PROXYSUB</code> <code>proxy_subscriptions</code> <code>PUB</code> <code>publish</code> <code>PUBSCOPE</code> <code>publication_scope</code> <code>SUB</code> <code>subscribe</code> <code>SUBSCOPE</code> <code>subscription_scope</code> <code>TOPIC</code> <code>topic_name</code> <code>TOPICSTR</code> <code>topic_string</code> <code>TYPE</code> <code>topic_type</code> <code>USEDLQ</code> <code>use_dead_letter_queue</code> <code>WILDCARD</code> <code>wildcard_operation</code>"},{"location":"mappings/topic/#request-key-value-map","title":"Request key-value map","text":""},{"location":"mappings/topic/#noreplace","title":"noreplace","text":"Friendly value MQSC key MQSC value <code>yes</code> <code>REPLACE</code> <code>NO</code>"},{"location":"mappings/topic/#replace","title":"replace","text":"Friendly value MQSC key MQSC value <code>no</code> <code>REPLACE</code> <code>NO</code> <code>yes</code> <code>REPLACE</code> <code>YES</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/topicstr/","title":"topicstr","text":"<p>Attribute mapping reference for the <code>topicstr</code> qualifier.</p> <p>Related MQSC commands: <code>CLEAR TOPICSTR</code></p>"},{"location":"mappings/topicstr/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>clear_type</code> <code>CLRTYPE</code> <code>command_scope</code> <code>CMDSCOPE</code> <code>scope</code> <code>SCOPE</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/tpstatus/","title":"tpstatus","text":"<p>Attribute mapping reference for the <code>tpstatus</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY TPSTATUS</code></p>"},{"location":"mappings/tpstatus/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>status_type</code> <code>TYPE</code>"},{"location":"mappings/tpstatus/#response-key-map","title":"Response key map","text":"MQSC parameter Friendly name <code>ACTCONN</code> <code>active_connection</code> <code>ADMIN</code> <code>admin_topic_name</code> <code>CAPEXPRY</code> <code>cap_expiry</code> <code>CLROUTE</code> <code>cluster_publish_route</code> <code>CLUSTER</code> <code>cluster_name</code> <code>COMMINFO</code> <code>communication_info</code> <code>DEFPRESP</code> <code>default_put_response</code> <code>DEFPRTY</code> <code>default_priority</code> <code>DEFPSIST</code> <code>default_persistence</code> <code>DURABLE</code> <code>durable</code> <code>DURSUB</code> <code>durable_subscriptions</code> <code>LMSGDATE</code> <code>last_message_date</code> <code>LMSGTIME</code> <code>last_message_time</code> <code>LPUBDATE</code> <code>last_publication_date</code> <code>LPUBTIME</code> <code>last_publication_time</code> <code>MCAST</code> <code>multicast</code> <code>MCASTREL</code> <code>multicast_reliability_indicator</code> <code>MDURMDL</code> <code>durable_model_queue_name</code> <code>MNDURMDL</code> <code>non_durable_model_queue_name</code> <code>NPMSGDLV</code> <code>non_persistent_message_delivery</code> <code>NUMMSGS</code> <code>number_of_messages</code> <code>NUMPUBS</code> <code>number_of_publishes</code> <code>PMSGDLV</code> <code>persistent_message_delivery</code> <code>PUBCOUNT</code> <code>publish_count</code> <code>PUBSCOPE</code> <code>publication_scope</code> <code>RESMDATE</code> <code>resume_date</code> <code>RESMTIME</code> <code>resume_time</code> <code>RETAINED</code> <code>retained_publication</code> <code>SUBCOUNT</code> <code>subscription_count</code> <code>SUBID</code> <code>subscription_id</code> <code>SUBTYPE</code> <code>subscription_type</code> <code>SUBUSER</code> <code>subscription_user_id</code> <code>USEDLQ</code> <code>use_dead_letter_queue</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"},{"location":"mappings/usage/","title":"usage","text":"<p>Attribute mapping reference for the <code>usage</code> qualifier.</p> <p>Related MQSC commands: <code>DISPLAY USAGE</code></p>"},{"location":"mappings/usage/#request-key-map","title":"Request key map","text":"Friendly name MQSC parameter <code>command_scope</code> <code>CMDSCOPE</code> <code>page_set_id</code> <code>PSID</code> <code>usage_type</code> <code>TYPE</code> <p>Auto-generated from <code>mapping-data.json</code> by <code>scripts/dev/generate_mapping_docs.py</code>.</p>"}]}